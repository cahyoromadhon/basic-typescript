import * as _mysten_sui_dist_cjs_client from '@mysten/sui/dist/cjs/client';
import { SuiObjectDataOptions, GetOwnedObjectsParams, GetDynamicFieldsParams, GetDynamicFieldObjectParams, SuiObjectData, SuiObjectRef } from '@mysten/sui/dist/cjs/client';
import * as _scallop_io_sui_kit from '@scallop-io/sui-kit';
import { SuiObjectArg, SuiTxArg, NetworkType, SuiKit, Transaction, SuiTxBlock, DerivePathParams, SuiKitParams, SuiVecTxArg, SuiAmountsArg, SuiAddressArg, TransactionResult as TransactionResult$1 } from '@scallop-io/sui-kit';
import * as _tanstack_query_core from '@tanstack/query-core';
import { QueryClient, QueryClientConfig, QueryKey } from '@tanstack/query-core';
import { AxiosInstance, AxiosResponse, AxiosRequestConfig } from 'axios';
import { SuiObjectDataOptions as SuiObjectDataOptions$1, SuiObjectResponse, SuiObjectData as SuiObjectData$1, GetOwnedObjectsParams as GetOwnedObjectsParams$1, GetDynamicFieldsParams as GetDynamicFieldsParams$1, DynamicFieldPage, GetDynamicFieldObjectParams as GetDynamicFieldObjectParams$1, CoinBalance, GetBalanceParams, DevInspectResults, SuiTransactionBlockResponse, SuiObjectRef as SuiObjectRef$1 } from '@mysten/sui/client';
import { Transaction as Transaction$1, TransactionObjectArgument, TransactionResult, Argument } from '@mysten/sui/transactions';

/**
 * Default cache options for the QueryClient.
 * @type {QueryClientConfig}
 * @description Default cache options for the QueryClient
 * We set the default to 5s to prevent duplicate requests from being requested (e.g. query MarketObject, etc.)
 */
declare const DEFAULT_CACHE_OPTIONS: {
    defaultOptions: {
        queries: {
            staleTime: number;
            gcTime: number;
        };
    };
};

declare const API_BASE_URL: "https://sui.apis.scallop.io";
declare const SDK_API_BASE_URL: "https://sdk.api.scallop.io";
declare const IS_VE_SCA_TEST: boolean;
declare const USE_TEST_ADDRESS: boolean;
declare const SCA_COIN_TYPE: "0x6cd813061a3adf3602b76545f076205f0c8e7ec1d3b1eab9a1da7992c18c0524::sca::SCA" | "0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6::sca::SCA";
declare const OLD_BORROW_INCENTIVE_PROTOCOL_ID: "0xc63072e7f5f4983a2efaf5bdba1480d5e7d74d57948e1c7cc436f8e22cbeb410";

declare namespace QueryKeys {
    namespace API {
        type GetAddresses = {
            addressId?: string;
        };
    }
    namespace RPC {
        type BaseType = {
            node?: string;
        };
        export type GetInspectTxn = BaseType & {
            queryTarget?: string;
            args?: SuiObjectArg[];
            typeArgs?: any[];
        };
        export type GetObject = BaseType & {
            objectId?: string;
            options?: SuiObjectDataOptions;
        };
        export type GetObjects = BaseType & {
            objectIds?: string[];
        };
        export type GetOwnedObjects = BaseType & Partial<GetOwnedObjectsParams>;
        export type GetDynamicFields = BaseType & Partial<GetDynamicFieldsParams>;
        export type GetDynamicFieldObject = BaseType & Partial<GetDynamicFieldObjectParams>;
        export type getTotalVeScaTreasuryAmount = BaseType & {
            refreshArgs?: any[];
            vescaAmountArgs?: (string | SuiObjectData | SuiTxArg)[];
        };
        export type GetAllCoinBalances = BaseType & {
            activeAddress?: string;
        };
        export type GetNormalizedMoveFunction = BaseType & {
            target?: string;
        };
        export {  };
    }
}

declare const queryKeys: {
    api: {
        getAddresses: (props?: QueryKeys.API.GetAddresses) => (string | QueryKeys.API.GetAddresses | undefined)[];
        getWhiteList: () => string[];
        getPoolAddresses: () => string[];
        getMarket: () => string[];
        getSpools: () => string[];
        getBorrowIncentivePool: () => string[];
        getTotalValueLocked: () => string[];
    };
    rpc: {
        getInspectTxn: (props?: QueryKeys.RPC.GetInspectTxn) => (string | QueryKeys.RPC.GetInspectTxn | undefined)[];
        getObject: (props?: QueryKeys.RPC.GetObject) => (string | QueryKeys.RPC.GetObject | undefined)[];
        getObjects: (props?: QueryKeys.RPC.GetObjects) => (string | QueryKeys.RPC.GetObjects | undefined)[];
        getOwnedObjects: (props?: QueryKeys.RPC.GetOwnedObjects) => (string | {
            filter: string;
            node?: string;
            owner?: string | undefined;
            cursor?: string | null | undefined;
            limit?: number | null | undefined;
            signal?: AbortSignal;
            options?: _mysten_sui_dist_cjs_client.SuiObjectDataOptions | null;
        })[];
        getDynamicFields: (props?: QueryKeys.RPC.GetDynamicFields) => (string | QueryKeys.RPC.GetDynamicFields | undefined)[];
        getDynamicFieldObject: (props?: QueryKeys.RPC.GetDynamicFieldObject) => (string | QueryKeys.RPC.GetDynamicFieldObject | undefined)[];
        getTotalVeScaTreasuryAmount: (props?: QueryKeys.RPC.getTotalVeScaTreasuryAmount) => (string | {
            refreshArgs: string | undefined;
            vescaAmountArgs: string | undefined;
            node?: string;
        })[];
        getAllCoinBalances: (props?: QueryKeys.RPC.GetAllCoinBalances) => (string | QueryKeys.RPC.GetAllCoinBalances | undefined)[];
        getNormalizedMoveFunction: (props?: QueryKeys.RPC.GetNormalizedMoveFunction) => (string | QueryKeys.RPC.GetNormalizedMoveFunction | undefined)[];
    };
    oracle: {
        getPythLatestPriceFeeds: () => string[];
    };
};

declare const RPC_PROVIDERS: string[];

type ScallopQueryClientParams = {
    queryClient?: QueryClient;
    queryClientConfig?: QueryClientConfig;
};
declare class ScallopQueryClient {
    private _queryClient;
    constructor(params?: ScallopQueryClientParams);
    get queryClient(): QueryClient;
    set queryClient(queryClient: QueryClient);
    get defaultQueryClientConfig(): {
        defaultOptions: {
            queries: {
                staleTime: number;
                gcTime: number;
            };
        };
    };
}

type ScallopAxiosParams = {
    baseUrl?: string;
    axiosInstance?: AxiosInstance;
    axiosTimeout?: number;
} & ScallopQueryClientParams;
declare class ScallopAxios extends ScallopQueryClient {
    readonly axiosInstance: AxiosInstance;
    constructor(params?: ScallopAxiosParams);
    post<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
    post<T = any, R = AxiosResponse<T>, D = any>(url: string, queryKey: QueryKey, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
    get<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
    get<T = any, R = AxiosResponse<T>, D = any>(url: string, queryKey: QueryKey, config?: AxiosRequestConfig<D>): Promise<R>;
    put<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
    put<T = any, R = AxiosResponse<T>, D = any>(url: string, queryKey: QueryKey, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
    delete<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
    delete<T = any, R = AxiosResponse<T>, D = any>(url: string, queryKey: QueryKey, config?: AxiosRequestConfig<D>): Promise<R>;
}

type ScallopAddressParams = {
    addressId?: string;
    urls?: {
        addresses?: string[];
    };
    auth?: string;
    network?: NetworkType;
    forceAddressesInterface?: Partial<Record<NetworkType, AddressesInterface>>;
    defaultValues?: {
        addresses?: Partial<Record<NetworkType, AddressesInterface>>;
    };
} & ScallopAxiosParams;
declare class ScallopAddress {
    readonly params: ScallopAddressParams;
    private currentAddresses?;
    private addressId?;
    private network;
    private auth;
    readonly scallopAxios: ScallopAxios;
    private readonly addressMap;
    private readonly defaultParamValues;
    constructor(params?: ScallopAddressParams);
    private initializeForcedAddresses;
    get axiosClient(): ScallopAxios;
    get queryClient(): _tanstack_query_core.QueryClient;
    get defaultValues(): {
        addresses?: Partial<Record<NetworkType, AddressesInterface>>;
    } | undefined;
    getId(): string | undefined;
    /**
     * Get the address at the provided path.
     *
     * @param path - The path of the address to get.
     * @return The address at the provided path.
     */
    get(path: AddressStringPath): any;
    /**
     * Sets the address for the specified path, it does not interact with the API.
     *
     * @param path - The path of the address to set.
     * @param address - The address be setted to the tartget path.
     * @return The addresses.
     */
    set(path: AddressStringPath, address: string): AddressesInterface | undefined;
    /**
     * Synchronize the specified network addresses from the addresses map to the
     * current addresses and change the default network to specified network.
     *
     * @param network - Specifies which network's addresses you want to get.
     * @return Current addresses.
     */
    switchCurrentAddresses(network: NetworkType): AddressesInterface | undefined;
    /**
     * Get the addresses, If `network` is not provided, returns the current
     * addresses or the default network addresses in the addresses map.
     *
     * @param network - Specifies which network's addresses you want to get.
     */
    getAddresses(network?: NetworkType): AddressesInterface | undefined;
    /**
     * Set the addresses into addresses map. If the specified network is the same
     * as the current network, the current addresses will be updated at the same time.
     *
     * @param addresses - The addresses be setted to the tartget network.
     * @param network - Specifies which network's addresses you want to set.
     * @return The addresses.
     */
    setAddresses(addresses: AddressesInterface, network?: NetworkType): void;
    /**
     * Get all addresses.
     *
     * @return All addresses.
     */
    getAllAddresses(): {
        [k: string]: AddressesInterface;
    };
    /**
     * Create a new addresses through the API and synchronize it back to the
     * instance.
     *
     * @description
     * If the `network` is not specified, the mainnet is used by default.
     * If no `addresses` from instance or parameter is provided, an addresses with
     * all empty strings is created by default.
     *
     * This function only allows for one addresses to be input into a specific network
     * at a time, and does not provide an addresses map for setting addresses
     * across all networks at once.
     *
     * @param params.addresses - The addresses be setted to the tartget network.
     * @param params.network - Specifies which network's addresses you want to set.
     * @param params.auth - The authentication API key.
     * @param params.memo - Add memo to the addresses created in the API.
     * @return All addresses.
     */
    create(params?: {
        addresses?: AddressesInterface | undefined;
        network?: NetworkType | undefined;
        auth?: string | undefined;
        memo?: string | undefined;
    }): Promise<{
        [k: string]: AddressesInterface;
    }>;
    protected readApi<T>({ url, queryKey, config, }: {
        url: string;
        queryKey: QueryKey;
        config?: AxiosRequestConfig;
    }): Promise<T>;
    /**
     * Read and synchronizes all addresses from the API into instance.
     *
     * @param id - The id of the addresses to get.
     * @return All addresses.
     */
    read(id?: string): Promise<{
        [k: string]: AddressesInterface;
    }>;
    /**
     * Update the addresses through the API and synchronize it back to the
     * instance.
     *
     * @description
     * If the `network` is not specified, the mainnet is used by default.
     * If no `addresses` from instance or parameter is provided, an addresses with
     * all empty strings is created by default.
     *
     * This function only allows for one addresses to be input into a specific network
     * at a time, and does not provide an addresses map for setting addresses
     * across all networks at once.
     *
     * @param params.id - The id of the addresses to update.
     * @param params.addresses - The addresses be setted to the tartget network.
     * @param params.network - Specifies which network's addresses you want to set.
     * @param params.auth - The authentication api key.
     * @param params.memo - Add memo to the addresses created in the API.
     * @return All addresses.
     */
    update(params?: {
        id?: string;
        addresses?: AddressesInterface | undefined;
        network?: NetworkType | undefined;
        auth?: string | undefined;
        memo?: string | undefined;
    }): Promise<{
        [k: string]: AddressesInterface;
    }>;
    /**
     * Deletes all addresses of a specified id through the API and clear all
     * addresses in the instance.
     *
     * @param id - The id of the addresses to delete.
     * @param auth - The authentication API key.
     */
    delete(id?: string, auth?: string): Promise<void>;
}

type CoinName = string;
type CoinType = string;
type SCoinType = string;
type OldMarketCoinType = string;
/**
 *  @description `scallop_sui`, `scallop_usdt`, etc (parsed directly from coin type, ex: `0x...::scallop_sui::SCALLOP_SUI`)
 */
type SCoinRawName = string;
/**
 * @description `ssui`, `susdc`, etc..
 */
type SCoinName = string;
type ScallopConstantsParams = {
    urls?: {
        poolAddresses?: string[];
        whitelist?: string[];
    };
    forcePoolAddressInterface?: Record<string, PoolAddress>;
    forceWhitelistInterface?: Whitelist | Record<string, any>;
    defaultValues?: {
        poolAddresses?: Record<string, PoolAddress>;
        whitelist?: Whitelist | Record<string, any>;
    };
} & ScallopAddressParams;
declare class ScallopConstants extends ScallopAddress {
    readonly params: ScallopConstantsParams;
    private _poolAddresses;
    private _whitelist;
    /**
     * @description coin names to coin decimal map
     */
    coinDecimals: Record<CoinName, number | undefined>;
    coinNameToOldMarketCoinTypeMap: Record<CoinName, OldMarketCoinType | undefined>;
    scoinRawNameToSCoinNameMap: Record<SCoinRawName, SCoinName | undefined>;
    scoinTypeToSCoinNameMap: Record<SCoinType, SCoinName | undefined>;
    wormholeCoinTypeToCoinNameMap: Record<CoinType, CoinName | undefined>;
    voloCoinTypeToCoinNameMap: Record<CoinType, CoinName | undefined>;
    suiBridgeCoinTypeToCoinNameMap: Record<CoinType, CoinName | undefined>;
    /**
     * @description coin names to coin types map
     */
    coinTypes: Record<CoinName, CoinType | undefined>;
    /**
     * @description scoin names to scoin types map
     */
    sCoinTypes: Record<SCoinName, SCoinType | undefined>;
    coinTypeToCoinNameMap: Record<CoinType, CoinName | undefined>;
    /**
     * @description Supported borrow incentive reward coin names
     */
    supportedBorrowIncentiveRewards: Set<CoinName>;
    constructor(params?: ScallopConstantsParams);
    get protocolObjectId(): string;
    get isInitialized(): boolean;
    get whitelist(): Whitelist;
    get poolAddresses(): Record<string, PoolAddress | undefined>;
    get defaultValues(): ({
        poolAddresses?: Record<string, PoolAddress>;
        whitelist?: Whitelist | Record<string, any>;
    } & {
        addresses?: Partial<Record<NetworkType, AddressesInterface>>;
    }) | undefined;
    private isAddressInitialized;
    parseToOldMarketCoin(coinType: string): string;
    init({ networkType, force, addressId, constantsParams, }?: {
        networkType?: NetworkType;
        force?: boolean;
        addressId?: string;
        constantsParams?: Partial<ScallopConstantsParams>;
    }): Promise<void>;
    private initConstants;
    readWhiteList(): Promise<Whitelist>;
    readPoolAddresses(): Promise<Record<string, PoolAddress>>;
}

type ScallopIndexerParams = {
    indexerApiUrl?: string;
} & ScallopAxiosParams;
declare class ScallopIndexer extends ScallopAxios {
    constructor(params?: ScallopIndexerParams);
    /**
     * Get market index data.
     *
     * @return Market data.
     */
    getMarket(): Promise<Pick<Market, 'pools' | 'collaterals'>>;
    /**
     * Get market pools index data.
     *
     * @return Market pools data.
     */
    getMarketPools(): Promise<Required<MarketPools>>;
    /**
     * Get market pool index data.
     *
     * @return Market pool data.
     */
    getMarketPool(poolCoinName: string): Promise<MarketPool>;
    /**
     * Get market collaterals index data.
     *
     * @return Market collaterals data.
     */
    getMarketCollaterals(): Promise<Required<MarketCollaterals>>;
    /**
     * Get market collateral index data.
     *
     * @return Market collateral data.
     */
    getMarketCollateral(collateralCoinName: string): Promise<MarketCollateral>;
    /**
     * Get spools index data.
     *
     * @return Spools data.
     */
    getSpools(): Promise<Required<Spools>>;
    /**
     * Get spool index data.
     *
     * @return Spool data.
     */
    getSpool(marketCoinName: string): Promise<Spool>;
    /**
     * Get borrow incentive pools index data.
     *
     * @return Borrow incentive pools data.
     */
    getBorrowIncentivePools(): Promise<Required<BorrowIncentivePools>>;
    /**
     * Get borrow incentive pool index data.
     *
     * @return Borrow incentive pool data.
     */
    getBorrowIncentivePool(borrowIncentiveCoinName: string): Promise<BorrowIncentivePool>;
    /**
     * Get total value locked index data.
     *
     * @return Total value locked.
     */
    getTotalValueLocked(): Promise<TotalValueLocked & {
        totalValueChangeRatio: number;
        borrowValueChangeRatio: number;
        supplyValueChangeRatio: number;
    }>;
    /**
     * Get coin price index data.
     *
     * @return price data.
     */
    getCoinPrice(poolCoinName: string): Promise<number>;
    getCoinPrices(): Promise<Record<string, number>>;
}

type QueryInspectTxnParams = {
    queryTarget: string;
    args: SuiObjectArg[];
    typeArgs?: any[];
};
type ScallopSuiKitParams = {
    suiKit?: SuiKit;
    tokensPerSecond?: number;
    walletAddress?: string;
} & SuiKitParams & ScallopQueryClientParams;
declare class ScallopSuiKit extends ScallopQueryClient {
    readonly suiKit: SuiKit;
    private _walletAddress;
    private _tokensPerSecond;
    private rateLimiter;
    constructor(params?: ScallopSuiKitParams);
    switchFullNodes(fullNodes: string[]): void;
    get client(): _mysten_sui_dist_cjs_client.SuiClient;
    get walletAddress(): string;
    set walletAddress(value: string);
    get tokensPerSecond(): number;
    set tokensPerSecond(value: number);
    get currentFullNode(): string;
    signAndSendTxn(tx: Uint8Array | Transaction | SuiTxBlock, derivePathParams?: DerivePathParams): Promise<_mysten_sui_dist_cjs_client.SuiTransactionBlockResponse>;
    private callWithRateLimiter;
    private queryGetNormalizedMoveFunction;
    /**
     * @description Provides cache for getObject of the SuiKit.
     * @param objectId
     * @param QueryObjectParams
     * @returns Promise<SuiObjectResponse>
     */
    queryGetObject(objectId: string, options?: SuiObjectDataOptions$1): Promise<SuiObjectResponse>;
    /**
     * @description Provides cache for getObjects of the SuiKit.
     * @param objectIds
     * @returns Promise<SuiObjectData[]>
     */
    queryGetObjects(objectIds: string[], options?: SuiObjectDataOptions$1): Promise<SuiObjectData$1[]>;
    /**
     * @description Provides cache for getOwnedObjects of the SuiKit.
     * @param input
     * @returns Promise<PaginatedObjectsResponse>
     */
    queryGetOwnedObjects(input: GetOwnedObjectsParams$1): Promise<_mysten_sui_dist_cjs_client.PaginatedObjectsResponse>;
    queryGetDynamicFields(input: GetDynamicFieldsParams$1): Promise<DynamicFieldPage | null>;
    queryGetDynamicFieldObject(input: GetDynamicFieldObjectParams$1): Promise<SuiObjectResponse | null>;
    queryGetAllCoinBalances(owner: string): Promise<{
        [k: string]: CoinBalance;
    }>;
    queryGetCoinBalance(input: GetBalanceParams): Promise<CoinBalance | null>;
    /**
     * @description Provides cache for inspectTxn of the SuiKit.
     * @param QueryInspectTxnParams
     * @param txBlock
     * @returns Promise<DevInspectResults>
     */
    queryInspectTxn({ queryTarget, args, typeArgs, }: QueryInspectTxnParams): Promise<DevInspectResults | null>;
}

type ScallopQueryParams = {
    indexer?: ScallopIndexer;
    utils?: ScallopUtils;
} & ScallopUtilsParams & ScallopIndexerParams;
declare class ScallopQuery implements ScallopQueryInterface {
    readonly indexer: ScallopIndexer;
    readonly utils: ScallopUtils;
    constructor(params: ScallopQueryParams);
    initIndexerFallback(): void;
    /**
     * Request the scallop API to initialize data.
     *
     * @param force - Whether to force initialization.
     */
    init(force?: boolean): Promise<void>;
    get constants(): ScallopConstants;
    get walletAddress(): string;
    get scallopSuiKit(): ScallopSuiKit;
    get address(): ScallopConstants;
    /**
     * @deprecated use getMarketPools
     * Query market data.
     * @param indexer - Whether to use indexer.
     * @return Market data.
     */
    queryMarket(args?: {
        coinPrices?: CoinPrices;
        indexer?: boolean;
    }): Promise<Market>;
    /**
     * Get market pools.
     *
     * @description
     * To obtain all market pools at once, it is recommended to use
     * the `queryMarket` method to reduce time consumption.
     *
     * @param poolCoinNames - Specific an array of support pool coin name.
     * @param indexer - Whether to use indexer.
     * @return Market pools data.
     */
    getMarketPools(poolCoinNames?: string[], args?: {
        coinPrices?: CoinPrices;
        indexer?: boolean;
    }): Promise<{
        pools: MarketPools;
        collaterals: MarketCollaterals;
    }>;
    /**
     * Get  market pool
     *
     * @param poolCoinName - Specific support pool coin name.
     * @param indexer - Whether to use indexer.
     * @return Market pool data.
     */
    getMarketPool(poolCoinName: string, args?: {
        coinPrice?: number;
        indexer?: boolean;
    }): Promise<MarketPool | undefined>;
    /**
     * Get market collaterals.
     *
     * @description
     * To obtain all market collaterals at once, it is recommended to use
     * the `queryMarket` method to reduce time consumption.
     *
     * @param collateralCoinNames - Specific an array of support collateral coin name.
     * @param indexer - Whether to use indexer.
     * @return Market collaterals data.
     */
    getMarketCollaterals(collateralCoinNames?: string[], args?: {
        indexer?: boolean;
    }): Promise<{
        [x: string]: MarketCollateral | undefined;
    }>;
    /**
     * Get market collateral
     *
     * @param collateralCoinName - Specific support collateral coin name.
     * @param indexer - Whether to use indexer.
     * @return Market collateral data.
     */
    getMarketCollateral(collateralCoinName: string, args?: {
        indexer?: boolean;
    }): Promise<MarketCollateral | undefined>;
    /**
     * Get obligations data.
     *
     * @param ownerAddress - The owner address.
     * @return Obligations data.
     */
    getObligations(ownerAddress?: string): Promise<Obligation[]>;
    /**
     * Query obligation data.
     *
     * @param obligationId - The obligation id.
     * @return Obligation data.
     */
    queryObligation(obligationId: SuiObjectArg): Promise<ObligationQueryInterface | undefined>;
    /**
     * Get all asset coin amounts.
     *
     * @param assetCoinNames - Specific an array of support asset coin name.
     * @param ownerAddress - The owner address.
     * @return All coin amounts.
     */
    getCoinAmounts(assetCoinNames?: string[], ownerAddress?: string): Promise<OptionalKeys<Record<string, number>>>;
    /**
     * Get asset coin amount.
     *
     * @param assetCoinName - Specific support asset coin name.
     * @param ownerAddress - The owner address.
     * @return Coin amount.
     */
    getCoinAmount(assetCoinName: string, ownerAddress?: string): Promise<number>;
    /**
     * Get all market coin amounts.
     *
     * @param coinNames - Specific an array of support market coin name.
     * @param ownerAddress - The owner address.
     * @return All market market coin amounts.
     */
    getMarketCoinAmounts(marketCoinNames?: string[], ownerAddress?: string): Promise<OptionalKeys<Record<string, number>>>;
    /**
     * Get market coin amount.
     *
     * @param coinNames - Specific support market coin name.
     * @param ownerAddress - The owner address.
     * @return Market market coin amount.
     */
    getMarketCoinAmount(marketCoinName: string, ownerAddress?: string): Promise<number>;
    /**
     * Get price from pyth fee object.
     *
     * @param assetCoinName - Specific support asset coin name.
     * @return Asset coin price.
     */
    getPriceFromPyth(assetCoinName: string): Promise<number>;
    /**
     * Get prices from pyth fee object.
     *
     * @param assetCoinNames - Array of supported asset coin names.
     * @return Array of asset coin prices.
     */
    getPricesFromPyth(assetCoinNames: string[]): Promise<Record<string, number>>;
    /**
     * Get spools data.
     *
     * @param stakeMarketCoinNames - Specific an array of support stake market coin name.
     * @param indexer - Whether to use indexer.
     * @return Spools data.
     */
    getSpools(stakeMarketCoinNames?: string[], args?: {
        marketPools?: MarketPools;
        coinPrices?: CoinPrices;
        indexer?: boolean;
    }): Promise<{
        [x: string]: Spool | undefined;
    }>;
    /**
     * Get spool data.
     *
     * @param stakeMarketCoinName - Specific support stake market coin name.
     * @param indexer - Whether to use indexer.
     * @return Spool data.
     */
    getSpool(stakeMarketCoinName: string, args?: {
        marketPool?: MarketPool;
        coinPrices?: CoinPrices;
        indexer?: boolean;
    }): Promise<Spool | undefined>;
    /**
     * Get stake accounts data for all stake pools (spools).
     *
     * @param ownerAddress - The owner address.
     * @return All Stake accounts data.
     */
    getAllStakeAccounts(ownerAddress?: string): Promise<StakeAccounts>;
    /**
     * Get stake accounts data for specific stake pool (spool).
     *
     * @param stakeMarketCoinName - Specific support stake market coin name.
     * @param ownerAddress - The owner address.
     * @return Stake accounts data.
     */
    getStakeAccounts(stakeMarketCoinName: string, ownerAddress?: string): Promise<StakeAccount[]>;
    /**
     * Get stake pools (spools) data.
     *
     * @description
     * For backward compatible, it is recommended to use `getSpools` method
     * to get all spools data.
     *
     * @param stakeMarketCoinNames - Specific an array of support stake market coin name.
     * @return Stake pools data.
     */
    getStakePools(stakeMarketCoinNames?: string[]): Promise<{
        [x: string]: StakePool | undefined;
    }>;
    /**
     * Get stake pool (spool) data.
     *
     * @description
     * For backward compatible, it is recommended to use `getSpool` method
     * to get all spool data.
     *
     * @param stakeMarketCoinName - Specific support stake market coin name.
     * @return Stake pool data.
     */
    getStakePool(stakeMarketCoinName: string): Promise<StakePool | undefined>;
    /**
     * Get stake reward pools data.
     *
     * @description
     * For backward compatible, it is recommended to use `getSpools` method
     * to get all spools data.
     *
     * @param stakeMarketCoinNames - Specific an array of stake market coin name.
     * @return Stake reward pools data.
     */
    getStakeRewardPools(stakeMarketCoinNames?: string[]): Promise<{
        [x: string]: StakeRewardPool | undefined;
    }>;
    /**
     * Get stake reward pool data.
     *
     * @description
     * For backward compatible, it is recommended to use `getSpool` method
     * to get spool data.
     *
     * @param marketCoinName - Specific support stake market coin name.
     * @return Stake reward pool data.
     */
    getStakeRewardPool(stakeMarketCoinName: string): Promise<StakeRewardPool | undefined>;
    /**
     * Get borrow incentive pools data.
     *
     * @param coinNames - Specific an array of support borrow incentive coin name.
     * @param indexer - Whether to use indexer.
     * @return Borrow incentive pools data.
     */
    getBorrowIncentivePools(coinNames?: string[], args?: {
        coinPrices?: CoinPrices;
        indexer?: boolean;
        marketPools?: MarketPools;
    }): Promise<{
        [x: string]: BorrowIncentivePool | undefined;
    }>;
    /**
     * Get borrow incentive accounts data.
     *
     * @param coinNames - Specific support borrow incentive coin name.
     * @param ownerAddress - The owner address.
     * @return Borrow incentive accounts data.
     */
    getBorrowIncentiveAccounts(obligationId: string | SuiObjectRef, coinNames?: string[]): Promise<{
        [x: string]: ParsedBorrowIncentiveAccountData | undefined;
    }>;
    /**
     * Get user lending and spool infomation for specific pools.
     *
     * @param poolCoinNames - Specific an array of support pool coin name.
     * @param ownerAddress - The owner address.
     * @param indexer - Whether to use indexer.
     * @return All lending and spool infomation.
     */
    getLendings(poolCoinNames?: string[], ownerAddress?: string, args?: {
        indexer?: boolean;
        marketPools?: MarketPools;
        coinPrices?: CoinPrices;
    }): Promise<{
        [x: string]: Lending | undefined;
    }>;
    /**
     * Get user lending and spool information for specific pool.
     *
     * @param poolCoinName - Specific support pool coin name.
     * @param ownerAddress - The owner address.
     * @param indexer - Whether to use indexer.
     * @return Lending pool data.
     */
    getLending(poolCoinName: string, ownerAddress?: string, args?: {
        indexer?: boolean;
    }): Promise<Lending>;
    /**
     * Get user all obligation accounts information from ownerAddress.
     *
     * @description
     * All collateral and borrowing information in all obligation accounts owned by the user.
     *
     * @param ownerAddress - The owner address.
     * @param args - Additional arguments.
     * @return All obligation accounts information.
     */
    getObligationAccounts(ownerAddress?: string, args?: {
        indexer?: boolean;
        market?: {
            collaterals: MarketCollaterals;
            pools: MarketPools;
        };
        coinPrices?: CoinPrices;
    }): Promise<{
        [x: string]: ObligationAccount | undefined;
    }>;
    /**
     * Get user all obligation accounts information from obligationIds.
     *
     * @description
     * All collateral and borrowing information in all obligation accounts.
     *
     * @param obligationIds - Obligation IDs.
     * @param args - Additional arguments.
     * @return All obligation accounts information.
     */
    getObligationAccountsByIds(obligationIds: string[], args?: {
        market?: {
            collaterals: MarketCollaterals;
            pools: MarketPools;
        };
        coinPrices?: CoinPrices;
        indexer?: boolean;
    }): Promise<ObligationAccount[]>;
    /**
     * Get obligation account by id
     *
     * @description
     * All collateral and borrowing information in obligation account.
     *
     * @param obligationId - Obligation ID.
     * @param args - Additional arguments.
     * @return All obligation accounts information.
     */
    getObligationAccountById(obligationId: string, args?: {
        market?: {
            collaterals: MarketCollaterals;
            pools: MarketPools;
        };
        coinPrices?: CoinPrices;
        indexer?: boolean;
    }): Promise<ObligationAccount>;
    /**
     * Get obligation account information for specific id.
     *
     * @description
     * borrowing and obligation information for specific pool.
     *
     * @param obligationId - The obligation id.
     * @param ownerAddress - The owner address.
     * @param args - Additional arguments.
     * @return Borrowing and collateral information.
     */
    getObligationAccount(obligationId: string, ownerAddress?: string, args?: {
        indexer?: boolean;
    }): Promise<ObligationAccount | undefined>;
    /**
     * Get total value locked.
     *
     * @param indexer - Whether to use indexer.
     * @description
     * Include total supplied value and total borrowed value.
     *
     * @return Total value locked.
     */
    getTvl(args?: {
        indexer?: boolean;
    }): Promise<TotalValueLocked>;
    /**
     * Get veSca data.
     * @param veScaKey
     * @returns veSca
     */
    getVeSca(veScaKey: string | SuiObjectData): Promise<Vesca | undefined>;
    /**
     * Get all veSca from walletAdddress
     * @param walletAddress
     * @returns array of veSca
     */
    getVeScas({ walletAddress, excludeEmpty, }?: {
        walletAddress?: string;
        excludeEmpty?: boolean;
    }): Promise<Vesca[]>;
    /**
     * Get total vesca treasury with movecall
     * @returns Promise<string | undefined>
     */
    getVeScaTreasuryInfo(): Promise<VeScaTreasuryInfo | null>;
    /**
     * Return binded referrer veScaKeyId of referee walletAddress if exist
     * @param walletAddress
     * @returns veScaKeyId
     */
    getVeScaKeyIdFromReferralBindings(walletAddress?: string): Promise<string | null>;
    /**
     * Get binded obligationId from a veScaKey if it exists.
     * @param veScaKey
     * @returns obligationId
     */
    getBindedObligationId(veScaKey: string): Promise<string | null>;
    /**
     * Get binded veSCA key from a obligationId if it exists.
     * @param obligationId
     * @returns veScaKey
     */
    getBindedVeScaKey(obligationId: string): Promise<string | null>;
    /**
     * Get user's veSCA loyalty program informations
     * @param veScaKey
     * @returns Loyalty program information
     */
    getLoyaltyProgramInfos(veScaKey?: string | SuiObjectData): Promise<LoyaltyProgramInfo | null>;
    /**
     * Get user's veSCA rewards informations from loyalty program
     * @param veScaKey
     * @returns Loyalty program information
     */
    getVeScaLoyaltyProgramInfos(veScaKey?: string | SuiObjectData): Promise<VeScaLoyaltyProgramInfo | null>;
    /**
     * Get total supply of sCoin
     * @param sCoinName - Supported sCoin name
     * @returns Total Supply
     */
    getSCoinTotalSupply(sCoinName: string): Promise<number>;
    /**
     * Get all sCoin amounts.
     *
     * @param sCoinNames - Specific an array of support sCoin name.
     * @param ownerAddress - The owner address.
     * @return All market sCoin amounts.
     */
    getSCoinAmounts(sCoinNames?: string[], ownerAddress?: string): Promise<OptionalKeys<Record<string, number>>>;
    /**
     * Get sCoin amount.
     *
     * @param coinNames - Specific support sCoin name.
     * @param ownerAddress - The owner address.
     * @return sCoin amount.
     */
    getSCoinAmount(sCoinName: string | string, ownerAddress?: string): Promise<number>;
    /**
     * Get swap rate from sCoin A to sCoin B
     * @param assetCoinNames
     * @returns
     */
    getSCoinSwapRate(fromSCoin: string, toSCoin: string): Promise<number>;
    getFlashLoanFees(assetCoinNames?: string[]): Promise<Record<string, number>>;
    /**
     * Get supply limit of lending pool
     */
    getPoolSupplyLimit(poolName: string): Promise<string | null>;
    /**
     * Get borrow limit of borrow pool
     */
    getPoolBorrowLimit(poolName: string): Promise<string | null>;
    /**
     * Get list of isolated assets
     */
    getIsolatedAssets(useOnChainQuery?: boolean): Promise<string[]>;
    /**
     * Check if asset is an isolated asset
     */
    isIsolatedAsset(assetCoinName: string): Promise<boolean>;
    /**
     * Get pool coin price from indexer
     * @param coinName
     * @returns price data
     */
    getCoinPriceByIndexer(poolName: string): Promise<number>;
    /**
     * Get all supported pool price from indexer
     * @returns prices data
     */
    getCoinPricesByIndexer(): Promise<Record<string, number>>;
    /**
     * Get all coin prices, including sCoin
     * @returns prices data
     */
    getAllCoinPrices(args?: {
        marketPools?: MarketPools;
        coinPrices?: CoinPrices;
        indexer?: boolean;
    }): Promise<{
        [x: string]: number | undefined;
    }>;
    /**
     * Query all address (lending pool, collateral pool, borrow dynamics, interest models, etc.) of all pool
     * @returns
     */
    getPoolAddresses(apiAddressId?: string | undefined): Promise<OptionalKeys<Record<string, PoolAddress>>>;
    /**
     * Get user portfolio
     */
    getUserPortfolio(args?: {
        walletAddress?: string;
        indexer?: boolean;
    }): Promise<{
        totalLockedScaValue: number;
        lendings: {
            suppliedCoin: number;
            suppliedValue: number;
            stakedCoin: number;
            coinName: string;
            symbol: string;
            coinType: string;
            coinPrice: number;
            coinDecimals: number;
            supplyApr: number;
            supplyApy: number;
            incentiveApr: number;
        }[];
        borrowings: {
            obligationId: string;
            totalDebtsInUsd: number;
            totalCollateralInUsd: number;
            riskLevel: number;
            availableCollateralInUsd: number;
            totalUnhealthyCollateralInUsd: number;
            collaterals: {
                coinName: string;
                symbol: string;
                coinDecimals: number;
                coinType: string;
                coinPrice: number;
                depositedCoin: number;
                depositedValueInUsd: number;
            }[];
            borrowedPools: {
                coinName: string;
                symbol: string;
                coinDecimals: number;
                coinType: string;
                coinPrice: number;
                borrowedCoin: number;
                borrowedValueInUsd: number;
                borrowApr: number | undefined;
                borrowApy: number | undefined;
                incentiveInfos: {
                    coinName: string;
                    symbol: string;
                    coinType: string;
                    incentiveApr: number;
                }[];
            }[];
        }[];
        pendingRewards: {
            lendings: any;
            borrowIncentives: any;
        };
        veScas: {
            veScaKey: string;
            coinPrice: number;
            lockedScaInCoin: number;
            lockedScaInUsd: number;
            currentVeScaBalance: number;
            remainingLockPeriodInDays: number;
            unlockAt: number;
        }[];
        totalDebtValue: number;
        totalCollateralValue: number;
        totalSupplyValue: number;
    }>;
    /**
     * Get both primary and secondary price update policy objects
     * @returns price update policies
     */
    getPriceUpdatePolicies(): Promise<{
        primary: _mysten_sui_dist_cjs_client.SuiObjectResponse | null;
        secondary: _mysten_sui_dist_cjs_client.SuiObjectResponse | null;
    }>;
    /**
     * Return the supported primary and secondary oracles for all supported pool assets
     * @returns
     */
    getAssetOracles(): Promise<Record<string, xOracleRules>>;
    /**
     * Get switchboard on-demand aggregator object id based on coinType
     * @param coinType
     * @returns
     */
    getSwitchboardOnDemandAggregatorObjectIds(coinName: string[]): Promise<string[]>;
}

type ScallopBuilderParams = {
    query?: ScallopQuery;
    usePythPullModel?: boolean;
    sponsoredFeeds?: string[];
    useOnChainXOracleList?: boolean;
} & ScallopQueryParams;
/**
 * @description
 * It provides methods for operating the transaction block, making it more convenient to organize transaction combinations.
 *
 * @example
 * ```typescript
 * const scallopBuilder = new ScallopBuilder(<parameters>);
 * await scallopBuilder.init();
 * const txBlock = scallopBuilder.<builder functions>();
 * ```
 */
declare class ScallopBuilder implements ScallopBuilderInterface {
    readonly query: ScallopQuery;
    readonly usePythPullModel: boolean;
    readonly useOnChainXOracleList: boolean;
    readonly sponsoredFeeds: string[];
    constructor(params: ScallopBuilderParams);
    get utils(): ScallopUtils;
    get constants(): ScallopConstants;
    get walletAddress(): string;
    get scallopSuiKit(): ScallopSuiKit;
    get suiKit(): _scallop_io_sui_kit.SuiKit;
    get address(): ScallopConstants;
    /**
     * Request the scallop API to initialize data.
     *
     * @param force - Whether to force initialization.
     */
    init(force?: boolean): Promise<void>;
    /**
     * Create a scallop txBlock instance that enhances transaction block.
     *
     * @param txBlock - Scallop txBlock, txBlock created by SuiKit, or original transaction block.
     * @return Scallop txBlock.
     */
    createTxBlock(txBlock?: ScallopTxBlock | SuiTxBlock | Transaction$1): ScallopTxBlock;
    /**
     * Specifying the sender's amount of coins to get coins args from transaction result.
     *
     * @param txBlock - Scallop txBlock or txBlock created by SuiKit .
     * @param assetCoinName - Specific support asset coin name.
     * @param amount - Amount of coins to be selected.
     * @param sender - Sender address.
     * @param isSponsored - Whether the transaction is a sponsored transaction.
     * @return Take coin and left coin.
     */
    selectCoin(txBlock: ScallopTxBlock | SuiTxBlock, assetCoinName: string, amount: number, sender?: string, isSponsored?: boolean): Promise<{
        takeCoin: {
            $kind: "NestedResult";
            NestedResult: [number, number];
        };
        leftCoin?: undefined;
    } | {
        takeCoin: TransactionObjectArgument;
        leftCoin: TransactionObjectArgument;
    }>;
    /**
     * Specifying the sender's amount of market coins to get coins args from transaction result.
     *
     * @param txBlock - Scallop txBlock or txBlock created by SuiKit .
     * @param marketCoinName - Specific support market coin name.
     * @param amount - Amount of coins to be selected.
     * @param sender - Sender address.
     * @return Take coin and left coin.
     */
    selectMarketCoin(txBlock: ScallopTxBlock | SuiTxBlock, marketCoinName: string, amount: number, sender?: string): Promise<{
        takeCoin: TransactionObjectArgument;
        leftCoin: TransactionObjectArgument;
        totalAmount: number;
    }>;
    /**
     * Specifying the sender's amount of sCoins to get coins args from transaction result.
     *
     * @param txBlock - Scallop txBlock or txBlock created by SuiKit .
     * @param marketCoinName - Specific support sCoin name.
     * @param amount - Amount of coins to be selected.
     * @param sender - Sender address.
     * @return Take coin and left coin.
     */
    selectSCoin(txBlock: ScallopTxBlock | SuiTxBlock, sCoinName: string, amount: number, sender?: string): Promise<{
        takeCoin: TransactionObjectArgument;
        leftCoin: TransactionObjectArgument;
        totalAmount: number;
    }>;
    /**
     * Select sCoin or market coin automatically. Prioritize sCoin first
     */
    selectSCoinOrMarketCoin(txBlock: ScallopTxBlock | SuiTxBlock, sCoinName: string, amount: number, sender?: string): Promise<{
        sCoin: TransactionObjectArgument | undefined;
        marketCoin: TransactionObjectArgument | undefined;
    }>;
    /**
     * Execute Scallop txBlock using the `signAndSendTxn` methods in suikit.
     *
     * @param txBlock - Scallop txBlock, txBlock created by SuiKit, or original transaction block.
     */
    signAndSendTxBlock(txBlock: ScallopTxBlock | SuiTxBlock | Transaction$1): Promise<SuiTransactionBlockResponse>;
    moveCall(txb: ScallopTxBlock | SuiTxBlock, target: string, args?: (SuiTxArg | SuiVecTxArg | SuiObjectArg | SuiAmountsArg)[], typeArgs?: string[]): _scallop_io_sui_kit.TransactionResult;
}

interface ScallopBaseInterface {
    scallopSuiKit: ScallopSuiKit;
    constants: ScallopConstants;
    walletAddress: string;
    init: () => Promise<void>;
}
interface ScallopUtilsInterface extends ScallopBaseInterface {
    address: ScallopAddress;
}
interface ScallopQueryInterface extends ScallopUtilsInterface {
    utils: ScallopUtils;
}
interface ScallopBuilderInterface extends ScallopQueryInterface {
    query: ScallopQuery;
}
interface ScallopClientInterface extends ScallopBaseInterface {
    builder: ScallopBuilder;
}

type ScallopUtilsParams = {
    pythEndpoints?: string[];
    scallopSuiKit?: ScallopSuiKit;
    scallopConstants?: ScallopConstants;
} & ScallopSuiKitParams & ScallopConstantsParams;
declare class ScallopUtils implements ScallopUtilsInterface {
    pythEndpoints: string[];
    readonly scallopSuiKit: ScallopSuiKit;
    readonly constants: ScallopConstants;
    readonly timeout: number;
    constructor(params?: ScallopUtilsParams);
    get walletAddress(): string;
    get suiKit(): _scallop_io_sui_kit.SuiKit;
    get queryClient(): _tanstack_query_core.QueryClient;
    get address(): ScallopConstants;
    isSuiBridgeAsset(coinName: any): boolean;
    isWormholeAsset(coinName: any): boolean;
    isMarketCoin(coinName: string): boolean;
    init({ force }?: {
        force?: boolean;
    }): Promise<void>;
    /**
     * Convert market coin name to coin name.
     *
     * @param marketCoinName - Specific support market coin name.
     * @return Coin Name.
     */
    parseCoinName<T extends string>(marketCoinName: string): T;
    /**
     * Convert coin name to symbol.
     *
     * @param coinName - Specific support coin name.
     * @return Symbol string.
     */
    parseSymbol(coinName: string): string;
    /**
     * Convert coin name to coin type.
     *
     * @description
     * The Coin type of wormhole is fixed `coin:Coin`. Here using package id
     * to determine and return the type.
     *
     * @param coinPackageId - Package id of coin.
     * @param coinName - Specific support coin name.
     * @return Coin type.
     */
    parseCoinType(coinName: string, useOldMarketCoin?: boolean): string;
    /**
     * Convert coin name to sCoin name.
     *
     * @param coinName - Specific support coin name.
     * @return sCoin name.
     */
    parseSCoinName<T extends string>(coinName: string): T | undefined;
    /**
     * Convert sCoin name to market coin name.
     * This function will parse new sCoin name `scallop_...` to its old market coin name which is shorter
     * e.g: `scallop_sui -> ssui
     * if no `scallop_...` is encountered, return coinName
     * @return sCoin name
     */
    parseSCoinTypeNameToMarketCoinName(coinName: string): string;
    /**
     * Convert sCoin name into sCoin type
     * @param sCoinName
     * @returns sCoin type
     */
    parseSCoinType(sCoinName: string): string;
    /**
     * Convert sCoinType into sCoin name
     * @param sCoinType
     * @returns sCoin name
     */
    parseSCoinNameFromType(sCoinType: string): string | undefined;
    /**
     * Convert sCoin name into its underlying coin type
     * @param sCoinName
     * @returns coin type
     */
    parseUnderlyingSCoinType(sCoinName: string): string;
    /**
     * Get sCoin treasury id from sCoin name
     * @param sCoinName
     * @returns sCoin treasury id
     */
    getSCoinTreasury(sCoinName: string): any;
    /**
     * Convert coin name to market coin type.
     *
     * @param coinPackageId - Package id of coin.
     * @param coinName - Specific support coin name.
     * @return Market coin type.
     */
    parseMarketCoinType(coinName: string): string;
    /**
     * Convert coin name to market coin name.
     *
     * @param coinName - Specific support coin name.
     * @return Market coin name.
     */
    parseMarketCoinName<T extends string>(coinName: string): T;
    /**
     * Get reward type of spool.
     *
     * @param stakeMarketCoinName - Support stake market coin.
     * @return Spool reward coin name.
     */
    getSpoolRewardCoinName: () => string;
    /**
     * Get coin decimal.
     *
     * return Coin decimal.
     */
    getCoinDecimal(coinName: string): number;
    /**
     * Get coin wrapped type.
     *
     * return Coin wrapped type.
     */
    getCoinWrappedType(assetCoinName: string): CoinWrappedType;
    /**
     * Convert coin type to coin name.
     *
     * @description
     * The coin name cannot be obtained directly from the wormhole type. Here
     * the package id is used to determine and return a specific name.
     *
     * @param coinType - Specific support coin type.
     * @return Coin Name.
     */
    parseCoinNameFromType(coinType: string): string;
    /**
     * Select coin id  that add up to the given amount as transaction arguments.
     *
     * @param ownerAddress - The address of the owner.
     * @param amount - The amount that including coin decimals.
     * @param coinType - The coin type, default is 0x2::SUI::SUI.
     * @return The selected transaction coin arguments.
     */
    selectCoins(amount: number, coinType?: string, ownerAddress?: string): Promise<{
        objectId: string;
        digest: string;
        version: string;
        balance: string;
    }[]>;
    /**
     * Merge coins with type `coinType` to dest
     * @param txBlock
     * @param dest
     * @param coinType
     * @param sender
     */
    mergeSimilarCoins(txBlock: SuiTxBlock | Transaction, dest: SuiObjectArg, coinType: string, sender?: string): Promise<void>;
    /**
     * Get all asset coin names in the obligation record by obligation id.
     *
     * @description
     * This can often be used to determine which assets in an obligation require
     * price updates before interacting with specific instructions of the Scallop contract.
     *
     * @param obligationId - The obligation id.
     * @return Asset coin Names.
     */
    getObligationCoinNames(obligationId: SuiObjectArg): Promise<string[] | undefined>;
    private parseDataFromPythPriceFeed;
    getPythPrice(assetCoinName: string, priceFeedObject?: SuiObjectData | null): Promise<number>;
    getPythPrices(assetCoinNames: string[]): Promise<Record<string, number>>;
    /**
     * Get asset coin price.
     *
     * @description
     * The strategy for obtaining the price is to get it through API first,
     * and then on-chain data if API cannot be retrieved.
     * Currently, we only support obtaining from pyth protocol, other
     * oracles will be supported in the future.
     *
     * @param assetCoinNames - Specific an array of support asset coin name.
     * @return  Asset coin price.
     */
    getCoinPrices(coinNames?: string[]): Promise<OptionalKeys<Record<string, number>>>;
    /**
     * Convert apr to apy.
     *
     * @param apr The annual percentage rate (APR).
     * @param compoundFrequency How often interest is compounded per year. Default is daily (365 times a year).
     * @return The equivalent annual percentage yield (APY) for the given APR and compounding frequency.
     */
    parseAprToApy(apr: number, compoundFrequency?: number): number;
    /**
     * Convert apy to apr.
     *
     * @param apr The equivalent annual percentage yield (APY).
     * @param compoundFrequency How often interest is compounded per year. Default is daily (365 times a year).
     * @return The equivalent annual percentage rate (APR) for the given APY and compounding frequency.
     */
    parseApyToApr(apy: number, compoundFrequency?: number): number;
    /**
     * Give extend lock period to get unlock at in seconds timestamp.
     *
     * @description
     * - When the user without remaining unlock period, If the extended unlock day is not specified,
     *   the unlock period will be increased by one day by default.
     * - When the given extended day plus the user's remaining unlock period exceeds the maximum
     *    unlock period, the maximum unlock period is used as unlock period.
     *
     * @param extendLockPeriodInDay The extend lock period in day.
     * @param unlockAtInSecondTimestamp The unlock timestamp from veSca object.
     * @return New unlock at in seconds timestamp.
     */
    getUnlockAt(extendLockPeriodInDay?: number, unlockAtInMillisTimestamp?: number): number;
    /**
     * Get detailed contract address and price id information for supported pool in Scallop
     * @returns Supported pool informations
     */
    getSupportedPoolAddresses(): PoolAddress[];
}

type ScallopClientParams = {
    networkType?: NetworkType;
    builder?: ScallopBuilder;
} & ScallopBuilderParams;
type ScallopClientFnReturnType<T extends boolean> = T extends true ? SuiTransactionBlockResponse : Transaction$1;
type ScallopClientVeScaReturnType<T extends boolean> = T extends true ? SuiTransactionBlockResponse : {
    tx: Transaction$1;
    scaCoin: TransactionResult;
};
/**
 * @description
 * It provides contract interaction operations for general users.
 *
 * @example
 * ```typescript
 * const scallopClient  = new ScallopClient(<parameters>);
 * await scallopClient.init();
 * scallopClient.<client functions>();
 * await scallopClient.<client async functions>();
 * ```
 */
declare class ScallopClient implements ScallopClientInterface {
    readonly builder: ScallopBuilder;
    networkType: NetworkType;
    constructor(params: ScallopClientParams);
    get query(): ScallopQuery;
    get utils(): ScallopUtils;
    get constants(): ScallopConstants;
    get walletAddress(): string;
    get scallopSuiKit(): ScallopSuiKit;
    get address(): ScallopConstants;
    /**
     * Request the scallop API to initialize data.
     *
     * @param force - Whether to force initialization.
     */
    init(force?: boolean): Promise<void>;
    /**
     * Query market data.
     *
     * @description
     * This method might be @deprecated in the future, please use the {@link ScallopQuery} query instance instead.
     *
     * @return Market data.
     */
    queryMarket(): Promise<Market>;
    /**
     * Get obligations data.
     *
     * @description
     * This method might be @deprecated in the future, please use the {@link ScallopQuery} query instance instead.
     *
     * @param ownerAddress - The owner address.
     * @return Obligations data.
     */
    getObligations(ownerAddress?: string): Promise<Obligation[]>;
    /**
     * Query obligation data.
     *
     * @description
     * This method might be @deprecated in the future, please use the {@link ScallopQuery} query instance instead.
     *
     * @param obligationId - The obligation id.
     * @return Obligation data.
     */
    queryObligation(obligationId: string): Promise<ObligationQueryInterface | undefined>;
    /**
     * Query all stake accounts data.
     *
     * @description
     * This method might be @deprecated in the future, please use the {@link ScallopQuery} query instance instead.
     *
     * @param ownerAddress - The owner address.
     * @return All stake accounts data.
     */
    getAllStakeAccounts(ownerAddress?: string): Promise<StakeAccounts>;
    /**
     * Query stake account data.
     *
     * @description
     * This method might be @deprecated in the future, please use the {@link ScallopQuery} query instance instead.
     *
     * @param stakeMarketCoinName - Support stake market coin.
     * @param ownerAddress - The owner address.
     * @return Stake accounts data.
     */
    getStakeAccounts(stakeMarketCoinName: string, ownerAddress?: string): Promise<StakeAccount[]>;
    /**
     * Query stake pool data.
     *
     * @description
     * This method might be @deprecated in the future, please use the {@link ScallopQuery} query instance instead.
     *
     * @param stakeMarketCoinName - Support stake market coin.
     * @return Stake pool data.
     */
    getStakePool(stakeMarketCoinName: string): Promise<StakePool | undefined>;
    /**
     * Query reward pool data.
     *
     * @description
     * This method might be @deprecated in the future, please use the {@link ScallopQuery} query instance instead.
     *
     * @param stakeMarketCoinName - Support stake market coin.
     * @return Reward pool data.
     */
    getStakeRewardPool(stakeMarketCoinName: string): Promise<StakeRewardPool | undefined>;
    /**
     * Open obligation.
     *
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @return Transaction block response or transaction block.
     */
    openObligation(): Promise<SuiTransactionBlockResponse>;
    openObligation<S extends boolean>(sign?: S): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Deposit collateral into the specific pool.
     *
     * @param collateralCoinName - Types of collateral coin.
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param obligationId - The obligation object.
     * @param walletAddress - The wallet address of the owner.
     * @param isSponsoredTx - Whether the transaction is sponsored.
     * @return Transaction block response or transaction block.
     */
    depositCollateral(collateralCoinName: string, amount: number): Promise<SuiTransactionBlockResponse>;
    depositCollateral<S extends boolean>(collateralCoinName: string, amount: number, sign?: S, obligationId?: string, walletAddress?: string, isSponsoredTx?: boolean): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Withdraw collateral from the specific pool.
     *
     * @param collateralCoinName - Types of collateral coin.
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param obligationId - The obligation object.
     * @param obligationKey - The obligation key object to verifying obligation authority.
     * @param walletAddress - The wallet address of the owner.
     * @param isSponsoredTx - Whether the transaction is sponsored.
     * @return Transaction block response or transaction block.
     */
    withdrawCollateral<S extends boolean>(collateralCoinName: string, amount: number, sign: S | undefined, obligationId: string, obligationKey: string, walletAddress?: string, isSponsoredTx?: boolean): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Deposit asset into the specific pool.
     *
     * @param poolCoinName - Types of pool coin.
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block.
     */
    deposit(poolCoinName: string, amount: number): Promise<SuiTransactionBlockResponse>;
    deposit<S extends boolean>(poolCoinName: string, amount: number, sign?: S, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Deposit asset into the specific pool and Stake market coin into the corresponding spool.
     *
     * @param stakeCoinName - Types of stake coin.
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param stakeAccountId - The stake account object.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block.
     */
    depositAndStake(stakeCoinName: string, amount: number): Promise<SuiTransactionBlockResponse>;
    depositAndStake<S extends boolean>(stakeCoinName: string, amount: number, sign?: S, stakeAccountId?: string, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Withdraw asset from the specific pool, must return market coin.
     *
     * @param poolCoinName - Specific support pool coin name.
     * @param amount - The amount of coins would withdraw.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block.
     */
    withdraw(poolCoinName: string, amount: number): Promise<SuiTransactionBlockResponse>;
    withdraw<S extends boolean>(poolCoinName: string, amount: number, sign?: S, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Borrow asset from the specific pool.
     *
     * @param poolCoinName - Specific support pool coin name.
     * @param amount - The amount of coins would borrow.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param obligationId - The obligation object.
     * @param obligationKey - The obligation key object to verifying obligation authority.
     * @param walletAddress - The wallet address of the owner.
     * @param isSponsoredTx - Whether the transaction is sponsored.
     * @return Transaction block response or transaction block.
     */
    borrow<S extends boolean>(poolCoinName: string, amount: number, sign: S | undefined, obligationId: string, obligationKey: string, walletAddress?: string, isSponsoredTx?: boolean): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Repay asset into the specific pool.
     *
     * @param poolCoinName - Specific support pool coin name.
     * @param amount - The amount of coins would repay.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param obligationId - The obligation object.
     * @param walletAddress - The wallet address of the owner.
     * @param isSponsoredTx - Whether the transaction is sponsored.
     * @return Transaction block response or transaction block.
     */
    repay<S extends boolean>(poolCoinName: string, amount: number, sign: S | undefined, obligationId: string, obligationKey: string, walletAddress?: string, isSponsoredTx?: boolean): Promise<ScallopClientFnReturnType<S>>;
    /**
     * FlashLoan asset from the specific pool.
     *
     * @param poolCoinName - Specific support pool coin name..
     * @param amount - The amount of coins would repay.
     * @param callback - The callback function to build transaction block and return coin argument.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @return Transaction block response or transaction block.
     */
    flashLoan(poolCoinName: string, amount: number, callback: (txBlock: ScallopTxBlock, coin: TransactionObjectArgument | string) => SuiObjectArg): Promise<SuiTransactionBlockResponse>;
    flashLoan<S extends boolean>(poolCoinName: string, amount: number, callback: (txBlock: ScallopTxBlock, coin: TransactionObjectArgument | string) => SuiObjectArg, sign?: S, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Create stake account.
     *
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block.
     */
    createStakeAccount(marketCoinName: string): Promise<SuiTransactionBlockResponse>;
    createStakeAccount<S extends boolean>(marketCoinName: string, sign?: S, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Stake market coin into the specific spool.
     *
     * @param marketCoinName - Types of market coin.
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param stakeAccountId - The stake account object.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block.
     */
    stake(stakeMarketCoinName: string, amount: number): Promise<SuiTransactionBlockResponse>;
    stake<S extends boolean>(stakeMarketCoinName: string, amount: number, sign?: S, stakeAccountId?: string, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Unstake market coin from the specific spool.
     *
     * @param stakeMarketCoinName - Types of mak coin.
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param accountId - The stake account object.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block.
     */
    unstake(stakeMarketCoinName: string, amount: number): Promise<SuiTransactionBlockResponse>;
    unstake<S extends boolean>(stakeMarketCoinName: string, amount: number, sign?: S, stakeAccountId?: string, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Unstake market coin from the specific spool and withdraw asset from the corresponding pool.
     *
     * @param marketCoinName - Types of mak coin.
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param accountId - The stake account object.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block.
     */
    unstakeAndWithdraw(stakeMarketCoinName: string, amount: number): Promise<SuiTransactionBlockResponse>;
    unstakeAndWithdraw<S extends boolean>(stakeMarketCoinName: string, amount: number, sign?: S, stakeAccountId?: string, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Claim reward coin from the specific spool.
     *
     * @param stakeMarketCoinName - Types of mak coin.
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param accountId - The stake account object.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block.
     */
    claim(stakeMarketCoinName: string): Promise<SuiTransactionBlockResponse>;
    claim<S extends boolean>(stakeMarketCoinName: string, sign?: S, stakeAccountId?: string, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * stake obligaion.
     *
     * @param obligationId - The obligation account object.
     * @param obligationKeyId - The obligation key account object.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block
     */
    stakeObligation<S extends boolean>(obligationId: string, obligationKeyId: string, sign?: S, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * unstake obligaion.
     *
     * @param obligationId - The obligation account object.
     * @param obligationKeyId - The obligation key account object.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block
     */
    unstakeObligation<S extends boolean>(obligationId: string, obligationKeyId: string, sign?: S, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Claim borrow incentive reward.
     *
     * @param poolName
     * @param amount - The amount of coins would deposit.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @param accountId - The stake account object.
     * @param walletAddress - The wallet address of the owner.
     * @return Transaction block response or transaction block
     */
    claimBorrowIncentive<S extends boolean>(obligationId: string, obligationKeyId: string, sign?: S, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Function to migrate all market coin in user wallet into sCoin
     * @returns Transaction response
     */
    migrateAllMarketCoin<S extends boolean>(includeStakePool?: boolean, sign?: S, walletAddress?: string): Promise<ScallopClientFnReturnType<S>>;
    /**
     * Claim unlocked SCA from all veSCA accounts.
     */
    claimAllUnlockedSca(): Promise<SuiTransactionBlockResponse>;
    claimAllUnlockedSca<S extends boolean>(sign?: S, walletAddress?: string): Promise<ScallopClientVeScaReturnType<S>>;
    /**
     * Mint and get test coin.
     *
     * @remarks
     * Only be used on the test network.
     *
     * @param assetCoinName - Specific asset coin name.
     * @param amount - The amount of coins minted and received.
     * @param receiveAddress - The wallet address that receives the coins.
     * @param sign - Decide to directly sign the transaction or return the transaction block.
     * @return Transaction block response or transaction block.
     */
    mintTestCoin(assetCoinName: Exclude<string, 'sui'>, amount: number): Promise<SuiTransactionBlockResponse>;
    mintTestCoin<S extends boolean>(assetCoinName: Exclude<string, 'sui'>, amount: number, sign?: S, receiveAddress?: string): Promise<ScallopClientFnReturnType<S>>;
}

/**
 * @argument params - The parameters for the Scallop instance.
 * @argument cacheOptions - The cache options for the QueryClient.
 *
 * @description
 * The main instance that controls interaction with the Scallop contract.
 *
 * @example
 * ```typescript
 * const sdk = new Scallop(<parameters>);
 * const scallopAddress = await sdk.getScallopAddress();
 * const scallopBuilder = await sdk.createScallopBuilder();
 * const scallopClient = await sdk.createScallopClient();
 * const scallopIndexer= await sdk.createScallopIndexer();
 * const scallopUtils= await sdk.createScallopUtils();
 * ```
 */
type ScallopParams = {
    client?: ScallopClient;
} & ScallopClientParams;
declare class Scallop {
    readonly client: ScallopClient;
    constructor(params: ScallopParams);
    init(force?: boolean): Promise<void>;
    /**
     * Create a scallop client instance that already has initial data.
     *
     * @return Scallop Client.
     */
    createScallopClient(): Promise<ScallopClient>;
    /**
     * Create a scallop builder instance that already has initial data.
     *
     * @return Scallop Builder.
     */
    createScallopBuilder(): Promise<ScallopBuilder>;
    /**
     * Create a scallop query instance.
     *
     * @return Scallop Query.
     */
    createScallopQuery(): Promise<ScallopQuery>;
    /**
     * Create a scallop utils instance.
     *
     * @return Scallop Utils.
     */
    createScallopUtils(): Promise<ScallopUtils>;
    /**
     * Create a scallop indexer instance.
     *
     * @return Scallop Indexer.
     */
    createScallopIndexer(): Promise<ScallopIndexer>;
    /**
     * Get a scallop constants instance that already has initial data.
     * @returns Scallop Constants
     */
    getScallopConstants(): Promise<ScallopConstants>;
}

type CoreIds = {
    protocolPkg: string;
    market: string;
    version: string;
    coinDecimalsRegistry: string;
    xOracle: string;
};
type NestedResult = Extract<Argument, {
    $kind: 'NestedResult';
}>;
type Obligation$1 = NestedResult;
type ObligationKey = NestedResult;
type ObligationHotPotato = NestedResult;
type CoreNormalMethods = {
    openObligation: () => [Obligation$1, ObligationKey, ObligationHotPotato];
    returnObligation: (obligation: SuiObjectArg, obligationHotPotato: SuiObjectArg) => void;
    openObligationEntry: () => void;
    addCollateral: (obligation: SuiObjectArg, coin: SuiObjectArg, collateralCoinName: string) => void;
    takeCollateral: (obligation: SuiObjectArg, obligationKey: SuiObjectArg, amount: number, collateralCoinName: string) => TransactionResult;
    deposit: (coin: SuiObjectArg, poolCoinName: string) => TransactionResult;
    depositEntry: (coin: SuiObjectArg, poolCoinName: string) => TransactionResult;
    withdraw: (marketCoin: SuiObjectArg, poolCoinName: string) => TransactionResult;
    withdrawEntry: (marketCoin: SuiObjectArg, poolCoinName: string) => TransactionResult;
    borrow: (obligation: SuiObjectArg, obligationKey: SuiObjectArg, amount: number, poolCoinName: string) => TransactionResult;
    borrowWithReferral: (obligation: SuiObjectArg, obligationKey: SuiObjectArg, borrowReferral: SuiObjectArg, amount: number | SuiTxArg, poolCoinName: string) => TransactionResult;
    borrowEntry: (obligation: SuiObjectArg, obligationKey: SuiObjectArg, amount: number, poolCoinName: string) => TransactionResult;
    repay: (obligation: SuiObjectArg, coin: SuiObjectArg, poolCoinName: string) => void;
    borrowFlashLoan: (amount: number | SuiTxArg, poolCoinName: string) => TransactionResult;
    repayFlashLoan: (coin: SuiObjectArg, loan: SuiObjectArg, poolCoinName: string) => void;
};
type CoreQuickMethods = {
    addCollateralQuick: (amount: number, collateralCoinName: string, obligationId?: SuiObjectArg, isSponsoredTx?: boolean) => Promise<void>;
    takeCollateralQuick: (amount: number, collateralCoinName: string, obligationId?: SuiObjectArg, obligationKey?: SuiObjectArg, updateOracleOptions?: {
        usePythPullModel?: boolean;
        useOnChainXOracleList?: boolean;
        sponsoredFeeds?: string[];
        isSponsoredTx?: boolean;
    }) => Promise<TransactionResult>;
    borrowQuick: (amount: number, poolCoinName: string, obligationId?: SuiObjectArg, obligationKey?: SuiObjectArg, updateOracleOptions?: {
        usePythPullModel?: boolean;
        useOnChainXOracleList?: boolean;
        sponsoredFeeds?: string[];
        isSponsoredTx?: boolean;
    }) => Promise<TransactionResult>;
    borrowWithReferralQuick: (amount: number, poolCoinName: string, borrowReferral: SuiObjectArg, obligationId?: SuiObjectArg, obligationKey?: SuiObjectArg, updateOracleOptions?: {
        usePythPullModel?: boolean;
        useOnChainXOracleList?: boolean;
        sponsoredFeeds?: string[];
        isSponsoredTx?: boolean;
    }) => Promise<TransactionResult>;
    depositQuick: (amount: number, poolCoinName: string, returnSCoin?: boolean, isSponsoredTx?: boolean) => Promise<TransactionResult>;
    withdrawQuick: (amount: number, poolCoinName: string) => Promise<TransactionResult>;
    repayQuick: (amount: number, poolCoinName: string, obligationId?: SuiObjectArg, isSponsoredTx?: boolean) => Promise<void>;
    updateAssetPricesQuick: (assetCoinNames?: string[], updateOracleOptions?: {
        usePythPullModel?: boolean;
        useOnChainXOracleList?: boolean;
        sponsoredFeeds?: string[];
        isSponsoredTx?: boolean;
    }) => Promise<void>;
};
type SuiTxBlockWithCoreNormalMethods = SuiTxBlock & SuiTxBlockWithSpool & CoreNormalMethods;
type CoreTxBlock = SuiTxBlockWithCoreNormalMethods & CoreQuickMethods;
type GenerateCoreNormalMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlock;
}) => CoreNormalMethods;
type GenerateCoreQuickMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlockWithCoreNormalMethods;
}) => CoreQuickMethods;

type SpoolIds = {
    spoolPkg: string;
};
type SpoolNormalMethods = {
    createStakeAccount: (stakeMarketCoinName: string) => TransactionResult;
    stake: (stakeAccount: SuiAddressArg, coin: SuiObjectArg, stakeMarketCoinName: string) => void;
    unstake: (stakeAccount: SuiAddressArg, amount: number, stakeMarketCoinName: string) => TransactionResult;
    claim: (stakeAccount: SuiAddressArg, stakeMarketCoinName: string) => TransactionResult;
};
type SpoolQuickMethods = {
    stakeQuick(amountOrMarketCoin: SuiObjectArg | number, stakeMarketCoinName: string, stakeAccountId?: SuiAddressArg): Promise<void>;
    unstakeQuick(amount: number, stakeMarketCoinName: string, stakeAccountId?: SuiAddressArg, returnSCoin?: boolean): Promise<TransactionResult | undefined>;
    claimQuick(stakeMarketCoinName: string, stakeAccountId?: SuiAddressArg): Promise<TransactionResult[]>;
};
type SuiTxBlockWithSpoolNormalMethods = SuiTxBlock & SuiTxBlockWithSCoin & SpoolNormalMethods;
type SpoolTxBlock = SuiTxBlockWithSpoolNormalMethods & SpoolQuickMethods;
type GenerateSpoolNormalMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlock;
}) => SpoolNormalMethods;
type GenerateSpoolQuickMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlockWithSpoolNormalMethods;
}) => SpoolQuickMethods;

type BorrowIncentiveIds = {
    borrowIncentivePkg: string;
    query: string;
    config: string;
    incentivePools: string;
    incentiveAccounts: string;
    obligationAccessStore: string;
};
type BorrowIncentiveNormalMethods = {
    stakeObligation: (obligation: SuiObjectArg, obligationKey: SuiObjectArg) => void;
    stakeObligationWithVesca: (obligation: SuiObjectArg, obligationKey: SuiObjectArg, veScaKey: SuiObjectArg) => void;
    unstakeObligation: (obligation: SuiObjectArg, obligationKey: SuiObjectArg) => void;
    claimBorrowIncentive: (obligation: SuiObjectArg, obligationKey: SuiObjectArg, rewardType: string) => TransactionResult;
    deactivateBoost: (obligation: SuiObjectArg, veScaKey: SuiObjectArg) => void;
};
type BorrowIncentiveQuickMethods = {
    stakeObligationQuick(obligation?: string, obligationKey?: string): Promise<void>;
    stakeObligationWithVeScaQuick(obligation?: string, obligationKey?: string, veScaKey?: string): Promise<void>;
    unstakeObligationQuick(obligation?: string, obligationKey?: string): Promise<void>;
    claimBorrowIncentiveQuick(rewardType: string, obligation?: string, obligationKey?: string): Promise<TransactionResult>;
};
type SuiTxBlockWithBorrowIncentiveNormalMethods = SuiTxBlock & BorrowIncentiveNormalMethods;
type BorrowIncentiveTxBlock = SuiTxBlockWithBorrowIncentiveNormalMethods & BorrowIncentiveQuickMethods;
type GenerateBorrowIncentiveNormalMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlock;
}) => BorrowIncentiveNormalMethods;
type GenerateBorrowIncentiveQuickMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlockWithBorrowIncentiveNormalMethods;
}) => BorrowIncentiveQuickMethods;

type VeScaNormalMethods = {
    lockSca: (scaCoin: SuiObjectArg, unlockAtInSecondTimestamp: number) => TransactionResult;
    extendLockPeriod: (veScaKey: SuiObjectArg, newUnlockAtInSecondTimestamp: number) => void;
    extendLockAmount: (veScaKey: SuiObjectArg, scaCoin: SuiObjectArg) => void;
    renewExpiredVeSca: (veScaKey: SuiObjectArg, scaCoin: SuiObjectArg, newUnlockAtInSecondTimestamp: number) => void;
    redeemSca: (veScaKey: SuiObjectArg) => TransactionResult;
    mintEmptyVeSca: () => TransactionResult;
    splitVeSca: (veScaKey: SuiObjectArg, splitAmount: string) => TransactionResult;
    mergeVeSca: (targetVeScaKey: SuiObjectArg, sourceVeScaKey: SuiObjectArg) => void;
};
type QuickMethodReturnType<T extends boolean> = T extends true ? void : TransactionResult;
type VeScaQuickMethods = {
    /**
     * Quick methods to automate
     * lock initial SCA, extend lock period, lock more SCA, renew expired VeSCA, and redeem SCA
     *
     * **Flow:**
     * - If only `amountOrCoin` is provided, it will lock the amount of existing not expired veSCA
     * - If only `lockPeriodInDays` is provided, it will extend the lock period of existing not expired veSCA
     *
     * **Note:**
     * - If one or both flow above is used on a expired veSCA, it will claim the unlocked SCA
     *   and renew the veSCA first, and then flow continues
     * - If users has no veSCA yet, they need to provide both `amountOrCoin` and `lockPeriodInDays` for initial lock
     * @param amountOrCoin
     * @param lockPeriodInDays
     * @param autoCheck
     */
    lockScaQuick(params: {
        amountOrCoin?: SuiObjectArg | number;
        lockPeriodInDays?: number;
        autoCheck?: boolean;
        veScaKey?: SuiObjectData$1 | string;
    }): Promise<void>;
    extendLockPeriodQuick: (params: {
        lockPeriodInDays: number;
        autoCheck?: boolean;
        veScaKey?: SuiObjectData$1 | string;
    }) => Promise<void>;
    extendLockAmountQuick: (params: {
        scaAmount: number;
        autoCheck?: boolean;
        veScaKey?: SuiObjectData$1 | string;
    }) => Promise<void>;
    renewExpiredVeScaQuick: (params: {
        scaAmount: number;
        lockPeriodInDays: number;
        autoCheck?: boolean;
        veScaKey?: SuiObjectData$1 | string;
    }) => Promise<void>;
    redeemScaQuick: <T extends boolean>(params: {
        veScaKey?: SuiObjectData$1 | string;
        transferSca?: T;
    }) => Promise<QuickMethodReturnType<T> | undefined>;
    splitVeScaQuick: <T extends boolean>(params: {
        splitAmount: string;
        veScaKey: string;
        transferVeScaKey?: T;
    }) => Promise<QuickMethodReturnType<T> | undefined>;
    mergeVeScaQuick: (params: {
        targetVeScaKey: string;
        sourceVeScaKey: string;
    }) => Promise<void>;
};
type SuiTxBlockWithVeScaNormalMethods = SuiTxBlock & VeScaNormalMethods;
type VeScaTxBlock = SuiTxBlockWithVeScaNormalMethods & VeScaQuickMethods;
type GenerateVeScaNormalMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlock;
}) => VeScaNormalMethods;
type GenerateVeScaQuickMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlockWithVeScaNormalMethods;
}) => VeScaQuickMethods;

type ReferralNormalMethods = {
    bindToReferral: (veScaKeyId: string) => void;
    claimReferralTicket: (poolCoinName: string) => TransactionResult$1;
    burnReferralTicket: (ticket: SuiObjectArg, poolCoinName: string) => void;
    claimReferralRevenue: (veScaKey: SuiObjectArg, poolCoinName: string) => TransactionResult$1;
};
type ReferralQuickMethods = {
    claimReferralRevenueQuick: (veScaKey: SuiObjectArg, coinNames: string[]) => Promise<void>;
};
type SuiTxBlockWithReferralNormalMethods = SuiTxBlock & ReferralNormalMethods;
type ReferralTxBlock = SuiTxBlockWithReferralNormalMethods & ReferralQuickMethods;

type LoyaltyProgramNormalMethods = {
    claimLoyaltyRevenue: (veScaKey: SuiObjectArg) => TransactionResult$1;
    claimVeScaLoyaltyReward: (veScaKey: SuiObjectArg) => TransactionResult$1;
};
type LoyaltyProgramQuickMethods = {
    claimLoyaltyRevenueQuick: (veScaKey?: SuiObjectArg) => Promise<void>;
    claimVeScaLoyaltyRewardQuick: (veScaKey?: SuiObjectArg) => Promise<void>;
};
type SuiTxBlockWithLoyaltyProgramNormalMethods = SuiTxBlock & LoyaltyProgramNormalMethods;
type LoyaltyProgramTxBlock = SuiTxBlockWithLoyaltyProgramNormalMethods & LoyaltyProgramQuickMethods;
type GenerateLoyaltyProgramNormalMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlock;
}) => LoyaltyProgramNormalMethods;
type GenerateLoyaltyProgramQuickMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlockWithLoyaltyProgramNormalMethods;
}) => LoyaltyProgramQuickMethods;

type sCoinPkgIds = {
    pkgId: string;
};
type sCoinNormalMethods = {
    /**
     * Lock marketCoin and return sCoin
     * @param marketCoinName
     * @param marketCoin
     * @returns
     */
    mintSCoin: (marketCoinName: string, marketCoin: SuiObjectArg) => TransactionResult$1;
    /**
     * Burn sCoin and return marketCoin
     * @param sCoinName
     * @param sCoin
     * @returns
     */
    burnSCoin: (sCoinName: string, sCoin: SuiObjectArg) => TransactionResult$1;
};
type sCoinQuickMethods = {
    mintSCoinQuick: (marketCoinName: string, amount: number) => Promise<TransactionResult$1>;
    burnSCoinQuick: (sCoinName: string, amount: number) => Promise<TransactionResult$1>;
};
type SuiTxBlockWithSCoinNormalMethods = SuiTxBlock & BaseScallopTxBlock & sCoinNormalMethods;
type SCoinTxBlock = SuiTxBlockWithSCoinNormalMethods & sCoinQuickMethods;
type GenerateSCoinNormalMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlock;
}) => sCoinNormalMethods;
type GenerateSCoinQuickMethod = (params: {
    builder: ScallopBuilder;
    txBlock: SuiTxBlockWithSCoinNormalMethods;
}) => sCoinQuickMethods;

type BaseScallopTxBlock = ReferralTxBlock & LoyaltyProgramTxBlock & BorrowIncentiveTxBlock & VeScaTxBlock;
type SuiTxBlockWithSCoin = BaseScallopTxBlock & SCoinTxBlock;
type SuiTxBlockWithSpool = SuiTxBlockWithSCoin & SpoolTxBlock;
type ScallopTxBlock = SuiTxBlockWithSpool & CoreTxBlock;

type PoolAddress = {
    coinName: string;
    symbol: string;
    coinType: string;
    coinMetadataId: string;
    decimals: number;
    isIsolated: boolean;
    pythFeed?: string;
    pythFeedObjectId?: string;
    lendingPoolAddress?: string;
    borrowDynamic?: string;
    interestModel?: string;
    borrowFeeKey?: string;
    flashloanFeeObject?: string;
    coinGeckoId?: string;
    collateralPoolAddress?: string;
    riskModel?: string;
    supplyLimitKey?: string;
    borrowLimitKey?: string;
    sCoinType?: string;
    sCoinName?: string;
    sCoinSymbol?: string;
    sCoinMetadataId?: string;
    sCoinTreasury?: string;
    isolatedAssetKey: string;
    spool?: string;
    spoolReward?: string;
    spoolName?: string;
};
type Whitelist = {
    lending: Set<string>;
    borrowing: Set<string>;
    collateral: Set<string>;
    packages: Set<string>;
    spool: Set<string>;
    scoin: Set<string>;
    suiBridge: Set<string>;
    wormhole: Set<string>;
    oracles: Set<string>;
    borrowIncentiveRewards: Set<string>;
    rewardsAsPoint: Set<string>;
    pythEndpoints: Set<string>;
    deprecated: Set<string>;
    emerging: Set<string>;
};
type CoinWrappedType = {
    from: string;
    type: string;
} | undefined;

type Coins = {
    [K in string]: K;
};
type AssetCoins = {
    [K in string]: K;
};
type MarketCoins = {
    [K in string]: K;
};
type SCoins = {
    [K in string]: K;
};
type StakeMarketCoins = {
    [K in string]: K;
};
type StakeRewardCoins = {
    [key in string]: string;
};
type SuiBridgeCoins = {
    [K in string]: K;
};
type BorrowIncentiveRewardCoins = {
    [key in string]: string[];
};
type AssetCoinIds = {
    [key in string]: string;
};
type SCoinIds = {
    [key in string]: string;
};
type SCoinTreasuryCaps = {
    [key in string]: string;
};
type SCoinConverterTreasury = {
    [key in string]: string;
};
type PickFromUnion<T, K extends string> = K extends T ? K : never;
type WormholeCoinIds = {
    [key in PickFromUnion<string, 'weth' | 'wbtc' | 'wusdc' | 'wusdt' | 'wapt' | 'wsol'>]: string;
};
type VoloCoinIds = {
    [key in PickFromUnion<string, 'vsui'>]: string;
};
type SuiBridgedCoinPackageIds = {
    [key in string]: string;
};

declare const _SUPPORT_ORACLES: readonly ["supra", "switchboard", "pyth"];
type SupportOracleType = (typeof _SUPPORT_ORACLES)[number];
type xOracleRules = {
    primary: SupportOracleType[];
    secondary: SupportOracleType[];
};
type xOracleRuleType = keyof xOracleRules;
type xOracleListType = {
    [key in string]: xOracleRules;
};

interface BorrowIncentiveAccountKey {
    id: string;
    onwerId: string;
}
type OptionalKeys$4<T> = {
    [K in keyof T]?: T[K];
};
type BorrowIncentivePools = OptionalKeys$4<Record<string, BorrowIncentivePool>>;
type BorrowIncentivePoolPoints = {
    symbol: string;
    coinName: string;
    coinType: string;
    coinDecimal: number;
    coinPrice: number;
} & Required<Pick<ParsedBorrowIncentivePoolPointData, 'points' | 'distributedPoint' | 'weightedAmount'>> & CalculatedBorrowIncentivePoolPointData;
type BorrowIncentivePool = {
    coinName: string;
    symbol: string;
    coinType: string;
    coinDecimal: number;
    coinPrice: number;
    stakedAmount: number;
    stakedCoin: number;
    stakedValue: number;
    points: OptionalKeys$4<Record<string, BorrowIncentivePoolPoints>>;
};
type OriginBorrowIncentivePoolPointData = {
    point_type: {
        name: string;
    };
    distributed_point_per_period: string;
    point_distribution_time: string;
    distributed_point: string;
    points: string;
    index: string;
    base_weight: string;
    weighted_amount: string;
    last_update: string;
    created_at: string;
};
type OriginBorrowIncentivePoolData = {
    pool_type: {
        name: string;
    };
    points: OriginBorrowIncentivePoolPointData[];
    min_stakes: string;
    max_stakes: string;
    stakes: string;
    created_at: string;
};
type ParsedBorrowIncentivePoolPointData = {
    pointType: string;
    distributedPointPerPeriod: number;
    period: number;
    distributedPoint: number;
    points: number;
    index: number;
    baseWeight: number;
    weightedAmount: number;
    lastUpdate: number;
    createdAt: number;
};
type ParsedBorrowIncentivePoolData = {
    poolType: string;
    poolPoints: OptionalKeys$4<Record<string, ParsedBorrowIncentivePoolPointData>>;
    minStakes: number;
    maxStakes: number;
    staked: number;
};
type CalculatedBorrowIncentivePoolPointData = {
    baseWeight: number;
    weightedStakedAmount: number;
    weightedStakedCoin: number;
    weightedStakedValue: number;
    distributedPointPerSec: number;
    accumulatedPoints: number;
    currentPointIndex: number;
    currentTotalDistributedPoint: number;
    rewardApr: number;
    rewardPerSec: number;
};
type BorrowIncentiveAccounts = OptionalKeys$4<Record<string, ParsedBorrowIncentiveAccountData>>;
type OriginBorrowIncentiveAccountPoolData = {
    point_type: {
        name: string;
    };
    weighted_amount: string;
    points: string;
    total_points: string;
    index: string;
};
type OriginBorrowIncentiveAccountData = {
    points_list: OriginBorrowIncentiveAccountPoolData[];
    pool_type: {
        name: string;
    };
    debt_amount: string;
};
type ParsedBorrowIncentiveAccountPoolData = {
    pointType: string;
    weightedAmount: number;
    points: number;
    totalPoints: number;
    index: number;
};
type ParsedBorrowIncentiveAccountData = {
    pointList: OptionalKeys$4<Record<string, ParsedBorrowIncentiveAccountPoolData>>;
    poolType: string;
    debtAmount: number;
};
/**
 * The query interface for `incentive_pools_query::incentive_pools_data` inspectTxn.
 */
interface BorrowIncentivePoolsQueryInterface {
    incentive_pools: OriginBorrowIncentivePoolData[];
}
/**
 * The query interface for `incentive_account_query::incentive_account_data` inspectTxn.
 */
interface BorrowIncentiveAccountsQueryInterface {
    pool_records: OriginBorrowIncentiveAccountData[];
}

type OptionalKeys$3<T> = {
    [K in keyof T]?: T[K];
};
type MarketPools = OptionalKeys$3<Record<string, MarketPool>>;
type MarketCollaterals = OptionalKeys$3<Record<string, MarketCollateral>>;
type CoinAmounts = OptionalKeys$3<Record<string, number>>;
type MarketCoinAmounts = OptionalKeys$3<Record<string, number>>;
type SCoinAmounts = OptionalKeys$3<Record<string, number>>;
type BalanceSheet = {
    cash: string;
    debt: string;
    market_coin_supply: string;
    revenue: string;
};
type BorrowDynamic = {
    borrow_index: string;
    interest_rate: {
        fields: {
            value: string;
        };
    };
    interest_rate_scale: string;
    last_updated: string;
};
type BorrowFee = {
    value: string;
};
type InterestModel = {
    base_borrow_rate_per_sec: {
        fields: {
            value: string;
        };
    };
    borrow_rate_on_high_kink: {
        fields: {
            value: string;
        };
    };
    borrow_rate_on_mid_kink: {
        fields: {
            value: string;
        };
    };
    borrow_weight: {
        fields: {
            value: string;
        };
    };
    borrow_fee_rate: {
        fields: {
            value: string;
        };
    };
    high_kink: {
        fields: {
            value: string;
        };
    };
    interest_rate_scale: string;
    max_borrow_rate: {
        fields: {
            value: string;
        };
    };
    mid_kink: {
        fields: {
            value: string;
        };
    };
    min_borrow_amount: string;
    revenue_factor: {
        fields: {
            value: string;
        };
    };
    type: {
        fields: {
            name: string;
        };
    };
};
type RiskModel = {
    collateral_factor: {
        fields: {
            value: string;
        };
    };
    liquidation_discount: {
        fields: {
            value: string;
        };
    };
    liquidation_factor: {
        fields: {
            value: string;
        };
    };
    liquidation_penalty: {
        fields: {
            value: string;
        };
    };
    liquidation_revenue_factor: {
        fields: {
            value: string;
        };
    };
    max_collateral_amount: string;
    type: {
        fields: {
            name: string;
        };
    };
};
type CollateralStat = {
    amount: string;
};
type MarketPool = {
    coinName: string;
    symbol: string;
    coinType: string;
    marketCoinType: string;
    sCoinType: string;
    coinWrappedType: CoinWrappedType;
    coinDecimal: number;
    coinPrice: number;
    maxSupplyCoin: number;
    maxBorrowCoin: number;
    isIsolated: boolean;
} & Required<Pick<ParsedMarketPoolData, 'highKink' | 'midKink' | 'reserveFactor' | 'borrowWeight' | 'borrowFee' | 'marketCoinSupplyAmount' | 'minBorrowAmount'>> & CalculatedMarketPoolData;
type MarketCollateral = {
    coinName: string;
    symbol: string;
    coinType: string;
    marketCoinType: string;
    coinWrappedType: CoinWrappedType;
    coinDecimal: number;
    coinPrice: number;
    isIsolated: boolean;
} & Required<Pick<ParsedMarketCollateralData, 'collateralFactor' | 'liquidationFactor' | 'liquidationDiscount' | 'liquidationPenalty' | 'liquidationReserveFactor'>> & CalculatedMarketCollateralData;
type OriginMarketPoolData = {
    type: {
        name: string;
    };
    maxBorrowRate: {
        value: string;
    };
    interestRate: {
        value: string;
    };
    interestRateScale: string;
    borrowIndex: string;
    lastUpdated: string;
    cash: string;
    debt: string;
    marketCoinSupply: string;
    reserve: string;
    reserveFactor: {
        value: string;
    };
    borrowWeight: {
        value: string;
    };
    borrowFeeRate: {
        value: string;
    };
    baseBorrowRatePerSec: {
        value: string;
    };
    borrowRateOnHighKink: {
        value: string;
    };
    borrowRateOnMidKink: {
        value: string;
    };
    highKink: {
        value: string;
    };
    midKink: {
        value: string;
    };
    minBorrowAmount: string;
    isIsolated: boolean;
    supplyLimit: string;
    borrowLimit: string;
};
type ParsedMarketPoolData = {
    coinType: string;
    maxBorrowRate: number;
    borrowRate: number;
    borrowRateScale: number;
    borrowIndex: number;
    lastUpdated: number;
    cashAmount: number;
    debtAmount: number;
    marketCoinSupplyAmount: number;
    reserveAmount: number;
    reserveFactor: number;
    borrowWeight: number;
    borrowFee: number;
    baseBorrowRate: number;
    borrowRateOnHighKink: number;
    borrowRateOnMidKink: number;
    highKink: number;
    midKink: number;
    minBorrowAmount: number;
    isIsolated: boolean;
    supplyLimit: number;
    borrowLimit: number;
};
type CalculatedMarketPoolData = {
    baseBorrowApr: number;
    baseBorrowApy: number;
    borrowAprOnHighKink: number;
    borrowApyOnHighKink: number;
    borrowAprOnMidKink: number;
    borrowApyOnMidKink: number;
    coinDecimal: number;
    conversionRate: number;
    maxBorrowApr: number;
    maxBorrowApy: number;
    borrowApr: number;
    borrowApy: number;
    borrowIndex: number;
    growthInterest: number;
    supplyAmount: number;
    supplyCoin: number;
    borrowAmount: number;
    borrowCoin: number;
    reserveAmount: number;
    reserveCoin: number;
    utilizationRate: number;
    supplyApr: number;
    supplyApy: number;
    isIsolated: boolean;
    maxSupplyCoin: number;
    maxBorrowCoin: number;
};
type OriginMarketCollateralData = {
    type: {
        name: string;
    };
    isIsolated: boolean;
    collateralFactor: {
        value: string;
    };
    liquidationFactor: {
        value: string;
    };
    liquidationDiscount: {
        value: string;
    };
    liquidationPenalty: {
        value: string;
    };
    liquidationReserveFactor: {
        value: string;
    };
    maxCollateralAmount: string;
    totalCollateralAmount: string;
};
type ParsedMarketCollateralData = {
    coinType: string;
    collateralFactor: number;
    liquidationFactor: number;
    liquidationDiscount: number;
    liquidationPenalty: number;
    liquidationReserveFactor: number;
    maxCollateralAmount: number;
    totalCollateralAmount: number;
    isIsolated: boolean;
};
type CalculatedMarketCollateralData = {
    coinDecimal: number;
    isIsolated: boolean;
    maxDepositAmount: number;
    maxDepositCoin: number;
    depositAmount: number;
    depositCoin: number;
};
type Market = {
    pools: MarketPools;
    collaterals: MarketCollaterals;
    data?: MarketQueryInterface;
};
type Obligation = {
    id: string;
    keyId: string;
    locked: boolean;
};
/**
 * The query interface for `market_query::market_data` inspectTxn.
 */
interface MarketQueryInterface {
    collaterals: {
        collateralFactor: {
            value: string;
        };
        liquidationDiscount: {
            value: string;
        };
        liquidationFactor: {
            value: string;
        };
        liquidationPanelty: {
            value: string;
        };
        liquidationReserveFactor: {
            value: string;
        };
        maxCollateralAmount: string;
        totalCollateralAmount: string;
        type: {
            name: string;
        };
    }[];
    pools: {
        baseBorrowRatePerSec: {
            value: string;
        };
        borrowRateOnHighKink: {
            value: string;
        };
        borrowRateOnMidKink: {
            value: string;
        };
        maxBorrowRate: {
            value: string;
        };
        highKink: {
            value: string;
        };
        midKink: {
            value: string;
        };
        interestRate: {
            value: string;
        };
        interestRateScale: string;
        borrowIndex: string;
        lastUpdated: string;
        cash: string;
        debt: string;
        marketCoinSupply: string;
        minBorrowAmount: string;
        reserve: string;
        reserveFactor: {
            value: string;
        };
        borrowWeight: {
            value: string;
        };
        borrowFeeRate: {
            value: string;
        };
        type: {
            name: string;
        };
    }[];
}
/**
 * The query interface for `obligation_query::obligation_data` inspectTxn.
 */
interface ObligationQueryInterface {
    collaterals: {
        type: {
            name: string;
        };
        amount: string;
    }[];
    debts: {
        type: {
            name: string;
        };
        amount: string;
        borrowIndex: string;
    }[];
}

type LoyaltyProgramInfo = {
    pendingReward: number;
    totalPoolReward: number;
    isClaimEnabled: boolean;
};
type VeScaLoyaltyProgramInfo = {
    pendingVeScaReward: number;
    pendingScaReward: number;
    totalPoolReward: number;
    isClaimEnabled: boolean;
};

type OptionalKeys$2<T> = {
    [K in keyof T]?: T[K];
};
type Spools = OptionalKeys$2<Record<string, Spool>>;
type Spool = {
    marketCoinName: string;
    symbol: string;
    coinType: string;
    marketCoinType: string;
    rewardCoinType: string;
    sCoinType: string;
    coinDecimal: number;
    rewardCoinDecimal: number;
    coinPrice: number;
    marketCoinPrice: number;
    rewardCoinPrice: number;
} & Required<Pick<ParsedSpoolData, 'maxPoint' | 'distributedPoint' | 'maxStake'>> & CalculatedSpoolData & SpoolRewardPool;
type OriginSpoolData = {
    stakeType: {
        fields: {
            name: string;
        };
    };
    maxDistributedPoint: string;
    distributedPoint: string;
    distributedPointPerPeriod: string;
    pointDistributionTime: string;
    maxStake: string;
    stakes: string;
    index: string;
    createdAt: string;
    lastUpdate: string;
};
type SpoolData = {
    created_at: string;
    distributed_point: string;
    distributed_point_per_period: string;
    id: {
        id: string;
    };
    index: string;
    last_update: string;
    max_distributed_point: string;
    max_stakes: string;
    point_distribution_time: string;
    stake_type: {
        type: string;
        fields: {
            name: string;
        };
    };
    stakes: string;
};
type ParsedSpoolData = {
    stakeType: string;
    maxPoint: number;
    distributedPoint: number;
    pointPerPeriod: number;
    period: number;
    maxStake: number;
    staked: number;
    index: number;
    createdAt: number;
    lastUpdate: number;
};
type CalculatedSpoolData = {
    stakedAmount: number;
    stakedCoin: number;
    stakedValue: number;
    distributedPointPerSec: number;
    accumulatedPoints: number;
    currentPointIndex: number;
    currentTotalDistributedPoint: number;
    startDate: Date;
    endDate: Date;
};
type SpoolRewardPool = Required<Pick<ParsedSpoolRewardPoolData, 'exchangeRateNumerator' | 'exchangeRateDenominator'>> & CalculatedSpoolRewardPoolData;
type OriginSpoolRewardPoolData = {
    claimed_rewards: string;
    exchange_rate_denominator: string;
    exchange_rate_numerator: string;
    rewards: string;
    spool_id: string;
};
type ParsedSpoolRewardPoolData = {
    claimedRewards: number;
    exchangeRateDenominator: number;
    exchangeRateNumerator: number;
    rewards: number;
    spoolId: string;
};
type CalculatedSpoolRewardPoolData = {
    rewardApr: number;
    totalRewardAmount: number;
    totalRewardCoin: number;
    totalRewardValue: number;
    remaindRewardAmount: number;
    remaindRewardCoin: number;
    remaindRewardValue: number;
    claimedRewardAmount: number;
    claimedRewardCoin: number;
    claimedRewardValue: number;
    rewardPerSec: number;
};
type StakePools = OptionalKeys$2<Record<string, StakePool>>;
type StakeRewardPools = OptionalKeys$2<Record<string, StakeRewardPool>>;
type StakeAccounts = Record<string, StakeAccount[]>;
interface StakeAccount {
    id: string;
    type: string;
    stakePoolId: string;
    stakeType: string;
    staked: number;
    index: number;
    points: number;
    totalPoints: number;
}
interface StakePool {
    id: string;
    type: string;
    maxPoint: number;
    distributedPoint: number;
    pointPerPeriod: number;
    period: number;
    maxStake: number;
    stakeType: string;
    totalStaked: number;
    index: number;
    createdAt: number;
    lastUpdate: number;
}
interface StakeRewardPool {
    id: string;
    type: string;
    stakePoolId: string;
    ratioDenominator: number;
    ratioNumerator: number;
    rewards: number;
    claimedRewards: number;
}

type OptionalKeys$1<T> = {
    [K in keyof T]?: T[K];
};
type Lendings = OptionalKeys$1<Record<string, Lending>>;
type ObligationAccounts = OptionalKeys$1<Record<string, ObligationAccount>>;
type Lending = Required<Pick<MarketPool, 'coinName' | 'symbol' | 'coinType' | 'marketCoinType' | 'sCoinType' | 'coinDecimal' | 'coinPrice' | 'conversionRate' | 'isIsolated'> & Pick<Spool, 'marketCoinPrice'>> & {
    supplyApr: number;
    supplyApy: number;
    rewardApr: number;
    suppliedAmount: number;
    suppliedCoin: number;
    suppliedValue: number;
    stakedMarketAmount: number;
    stakedMarketCoin: number;
    stakedAmount: number;
    stakedCoin: number;
    stakedValue: number;
    unstakedMarketAmount: number;
    unstakedMarketCoin: number;
    unstakedAmount: number;
    unstakedCoin: number;
    unstakedValue: number;
    availableSupplyAmount: number;
    availableSupplyCoin: number;
    availableWithdrawAmount: number;
    availableWithdrawCoin: number;
    availableStakeAmount: number;
    availableStakeCoin: number;
    availableUnstakeAmount: number;
    availableUnstakeCoin: number;
    availableClaimAmount: number;
    availableClaimCoin: number;
};
type ObligationAccount = {
    obligationId: string;
    totalDepositedValue: number;
    totalBorrowedValue: number;
    totalBalanceValue: number;
    totalBorrowCapacityValue: number;
    totalAvailableCollateralValue: number;
    totalBorrowedValueWithWeight: number;
    totalRequiredCollateralValue: number;
    totalUnhealthyCollateralValue: number;
    totalRiskLevel: number;
    totalDepositedPools: number;
    totalBorrowedPools: number;
    totalRewardedPools: number;
    collaterals: OptionalKeys$1<Record<string, ObligationCollateral>>;
    debts: OptionalKeys$1<Record<string, ObligationDebt>>;
    borrowIncentives: OptionalKeys$1<Record<string, ObligationBorrowIncentive>>;
};
type ObligationCollateral = {
    coinName: string;
    coinType: string;
    symbol: string;
    coinDecimal: number;
    coinPrice: number;
    depositedAmount: number;
    depositedCoin: number;
    depositedValue: number;
    borrowCapacityValue: number;
    requiredCollateralValue: number;
    availableDepositAmount: number;
    availableDepositCoin: number;
    availableWithdrawAmount: number;
    availableWithdrawCoin: number;
};
type ObligationDebt = {
    coinName: string;
    coinType: string;
    symbol: string;
    coinDecimal: number;
    coinPrice: number;
    borrowedAmount: number;
    borrowedCoin: number;
    borrowedValue: number;
    borrowedValueWithWeight: number;
    borrowIndex: number;
    requiredRepayAmount: number;
    requiredRepayCoin: number;
    availableBorrowAmount: number;
    availableBorrowCoin: number;
    availableRepayAmount: number;
    availableRepayCoin: number;
};
type ObligationBorrowIncentiveReward = {
    coinName: string;
    coinType: string;
    symbol: string;
    coinDecimal: number;
    coinPrice: number;
    weightedBorrowAmount: number;
    availableClaimCoin: number;
    availableClaimAmount: number;
    boostValue: number;
};
type ObligationBorrowIncentive = {
    coinName: string;
    coinType: string;
    symbol: string;
    coinDecimal: number;
    coinPrice: number;
    rewards: ObligationBorrowIncentiveReward[];
};
type TotalValueLocked = {
    supplyLendingValue: number;
    supplyCollateralValue: number;
    supplyValue: number;
    borrowValue: number;
    totalValue: number;
    supplyValueChangeRatio?: number;
    supplyLendingValueChangeRatio?: number;
    supplyCollateralValueChangeRatio?: number;
    borrowValueChangeRatio?: number;
    totalValueChangeRatio?: number;
};

type sCoinBalance = number;

type Vesca = {
    id: string;
    keyId: string;
    keyObject?: SuiObjectRef$1;
    object: SuiObjectRef$1;
    lockedScaAmount: string;
    lockedScaCoin: number;
    currentVeScaBalance: number;
    unlockAt: number;
};
type VeScaTreasuryFields = {
    total_ve_sca_amount: string;
    sca_balance: string;
    unlock_schedule: {
        fields: {
            locked_sca_amount: string;
        };
    };
};
type VeScaTreasuryInfo = {
    totalLockedSca: number;
    totalVeSca: number;
    averageLockingPeriod: number;
    averageLockingPeriodUnit: string;
};

interface AddressesInterface {
    id?: string;
    core: {
        version: string;
        versionCap: string;
        object: string;
        market: string;
        adminCap: string;
        coinDecimalsRegistry: string;
        obligationAccessStore: string;
        coins: Partial<Record<string, {
            id: string;
            treasury: string;
            metaData: string;
            coinType: string;
            symbol: string;
            decimals: number;
            oracle: {
                [K in SupportOracleType]: K extends (typeof _SUPPORT_ORACLES)[0] ? string : K extends (typeof _SUPPORT_ORACLES)[1] ? string : K extends (typeof _SUPPORT_ORACLES)[2] ? {
                    feed: string;
                    feedObject: string;
                } : never;
            };
        }>>;
        oracles: {
            [K in SupportOracleType]: K extends (typeof _SUPPORT_ORACLES)[0] ? {
                registry: string;
                registryCap: string;
                holder: string;
            } : K extends (typeof _SUPPORT_ORACLES)[1] ? {
                registry: string;
                registryCap: string;
                registryTableId: string;
                state: string;
            } : K extends (typeof _SUPPORT_ORACLES)[2] ? {
                registry: string;
                registryCap: string;
                state: string;
                wormhole: string;
                wormholeState: string;
            } : never;
        } & {
            xOracle: string;
            xOracleCap: string;
            primaryPriceUpdatePolicyObject: string;
            secondaryPriceUpdatePolicyObject: string;
            primaryPriceUpdatePolicyVecsetId: string;
            secondaryPriceUpdatePolicyVecsetId: string;
        };
        packages: Partial<Record<string, {
            id: string;
            object?: string;
            upgradeCap: string;
        }>>;
    };
    spool: {
        id: string;
        adminCap: string;
        object: string;
        config: string;
        pools: Partial<Record<string, {
            id: string;
            rewardPoolId: string;
        }>>;
    };
    borrowIncentive: {
        id: string;
        adminCap: string;
        object: string;
        query: string;
        config: string;
        incentivePools: string;
        incentiveAccounts: string;
    };
    vesca: {
        id: string;
        object: string;
        adminCap: string;
        tableId: string;
        table: string;
        treasury: string;
        config: string;
        subsTable: string;
        subsTableId: string;
        subsWhitelist: string;
    };
    referral: {
        id: string;
        version: string;
        object: string;
        adminCap: string;
        referralBindings: string;
        bindingTableId: string;
        referralRevenuePool: string;
        revenueTableId: string;
        referralTiers: string;
        tiersTableId: string;
        authorizedWitnessList: string;
    };
    loyaltyProgram: {
        id: string;
        adminCap?: string;
        object: string;
        rewardPool: string;
        userRewardTableId: string;
    };
    veScaLoyaltyProgram: {
        id: string;
        adminCap?: string;
        object: string;
        veScaRewardPool: string;
        veScaRewardTableId: string;
    };
    scoin: {
        id: string;
        coins: Partial<Record<string, {
            coinType: string;
            symbol: string;
            treasury: string;
            metaData: string;
        }>>;
    };
}
type AddressPathsProps<T> = T extends string ? [] : {
    [K in Extract<keyof T, string>]: [K, ...AddressPathsProps<T[K]>];
}[Extract<keyof T, string>];
type Join<T extends string[], D extends string> = T extends [] ? never : T extends [infer F] ? F : T extends [infer F, ...infer R] ? F extends string ? `${F}${D}${Join<Extract<R, string[]>, D>}` : never : string;
type AddressStringPath = Join<AddressPathsProps<AddressesInterface>, '.'>;

type OptionalKeys<T> = {
    [K in keyof T]?: T[K];
};
type CoinPrices = OptionalKeys<Record<string, number>>;

declare const TEST_ADDRESSES: AddressesInterface;
declare const WHITELIST: {
    lending: Set<string>;
    collateral: Set<string>;
    borrowing: Set<string>;
    packages: Set<string>;
    spool: Set<string>;
    scoin: Set<string>;
    suiBridge: Set<string>;
    wormhole: Set<string>;
    oracles: Set<string>;
    pythEndpoints: Set<string>;
    deprecated: Set<string>;
    borrowIncentiveRewards: Set<string>;
    rewardsAsPoint: Set<string>;
    emerging: Set<string>;
};
declare const POOL_ADDRESSES: {
    usdc: {
        coinName: string;
        symbol: string;
        lendingPoolAddress: string;
        collateralPoolAddress: string;
        borrowDynamic: string;
        interestModel: string;
        riskModel: string;
        borrowFeeKey: string;
        supplyLimitKey: string;
        borrowLimitKey: string;
        isolatedAssetKey: string;
        isIsolated: boolean;
        spool: string;
        spoolReward: string;
        sCoinType: string;
        sCoinTreasury: string;
        sCoinMetadataId: string;
        sCoinSymbol: string;
        sCoinName: string;
        coinMetadataId: string;
        coinType: string;
        spoolName: string;
        decimals: number;
        pythFeed: string;
        pythFeedObjectId: string;
        flashloanFeeObject: string;
    };
    sui: {
        coinName: string;
        symbol: string;
        lendingPoolAddress: string;
        collateralPoolAddress: string;
        borrowDynamic: string;
        interestModel: string;
        riskModel: string;
        borrowFeeKey: string;
        supplyLimitKey: string;
        borrowLimitKey: string;
        isolatedAssetKey: string;
        isIsolated: boolean;
        spool: string;
        spoolReward: string;
        sCoinType: string;
        sCoinTreasury: string;
        sCoinMetadataId: string;
        sCoinSymbol: string;
        sCoinName: string;
        coinMetadataId: string;
        coinType: string;
        spoolName: string;
        decimals: number;
        pythFeed: string;
        pythFeedObjectId: string;
        flashloanFeeObject: string;
    };
    sca: {
        coinName: string;
        symbol: string;
        lendingPoolAddress: string;
        collateralPoolAddress: string;
        borrowDynamic: string;
        interestModel: string;
        riskModel: string;
        borrowFeeKey: string;
        supplyLimitKey: string;
        borrowLimitKey: string;
        isolatedAssetKey: string;
        isIsolated: boolean;
        spool: string;
        spoolReward: string;
        sCoinType: string;
        sCoinTreasury: string;
        sCoinMetadataId: string;
        sCoinSymbol: string;
        sCoinName: string;
        coinMetadataId: string;
        coinType: string;
        spoolName: string;
        decimals: number;
        pythFeed: string;
        pythFeedObjectId: string;
        flashloanFeeObject: string;
    };
    fud: {
        coinName: string;
        symbol: string;
        lendingPoolAddress: string;
        collateralPoolAddress: string;
        borrowDynamic: string;
        interestModel: string;
        borrowFeeKey: string;
        supplyLimitKey: string;
        borrowLimitKey: string;
        isolatedAssetKey: string;
        isIsolated: boolean;
        spool: string;
        spoolReward: string;
        sCoinType: string;
        sCoinTreasury: string;
        sCoinMetadataId: string;
        sCoinSymbol: string;
        sCoinName: string;
        coinMetadataId: string;
        coinType: string;
        spoolName: string;
        decimals: number;
        pythFeed: string;
        pythFeedObjectId: string;
        flashloanFeeObject: string;
    };
    deep: {
        coinName: string;
        symbol: string;
        lendingPoolAddress: string;
        collateralPoolAddress: string;
        borrowDynamic: string;
        interestModel: string;
        borrowFeeKey: string;
        supplyLimitKey: string;
        borrowLimitKey: string;
        isolatedAssetKey: string;
        isIsolated: boolean;
        spool: string;
        spoolReward: string;
        sCoinType: string;
        sCoinTreasury: string;
        sCoinMetadataId: string;
        sCoinSymbol: string;
        sCoinName: string;
        coinMetadataId: string;
        coinType: string;
        spoolName: string;
        decimals: number;
        pythFeed: string;
        pythFeedObjectId: string;
        flashloanFeeObject: string;
    };
};

declare const UNLOCK_ROUND_DURATION: number;
declare const MAX_LOCK_ROUNDS: 1460;
declare const MAX_LOCK_DURATION: number;
declare const MIN_INITIAL_LOCK_AMOUNT: 10000000000;
declare const MIN_TOP_UP_AMOUNT: 1000000000;

declare const xOracleList: xOracleListType;

export { API_BASE_URL, type AddressStringPath, type AddressesInterface, type AssetCoinIds, type AssetCoins, type BalanceSheet, type BaseScallopTxBlock, type BorrowDynamic, type BorrowFee, type BorrowIncentiveAccountKey, type BorrowIncentiveAccounts, type BorrowIncentiveAccountsQueryInterface, type BorrowIncentiveIds, type BorrowIncentiveNormalMethods, type BorrowIncentivePool, type BorrowIncentivePoolPoints, type BorrowIncentivePools, type BorrowIncentivePoolsQueryInterface, type BorrowIncentiveQuickMethods, type BorrowIncentiveRewardCoins, type BorrowIncentiveTxBlock, type CalculatedBorrowIncentivePoolPointData, type CalculatedMarketCollateralData, type CalculatedMarketPoolData, type CalculatedSpoolData, type CalculatedSpoolRewardPoolData, type CoinAmounts, type CoinPrices, type CoinWrappedType, type Coins, type CollateralStat, type CoreIds, type CoreNormalMethods, type CoreQuickMethods, type CoreTxBlock, DEFAULT_CACHE_OPTIONS, type GenerateBorrowIncentiveNormalMethod, type GenerateBorrowIncentiveQuickMethod, type GenerateCoreNormalMethod, type GenerateCoreQuickMethod, type GenerateLoyaltyProgramNormalMethod, type GenerateLoyaltyProgramQuickMethod, type GenerateSCoinNormalMethod, type GenerateSCoinQuickMethod, type GenerateSpoolNormalMethod, type GenerateSpoolQuickMethod, type GenerateVeScaNormalMethod, type GenerateVeScaQuickMethod, IS_VE_SCA_TEST, type InterestModel, type Lending, type Lendings, type LoyaltyProgramInfo, type LoyaltyProgramNormalMethods, type LoyaltyProgramQuickMethods, type LoyaltyProgramTxBlock, MAX_LOCK_DURATION, MAX_LOCK_ROUNDS, MIN_INITIAL_LOCK_AMOUNT, MIN_TOP_UP_AMOUNT, type Market, type MarketCoinAmounts, type MarketCoins, type MarketCollateral, type MarketCollaterals, type MarketPool, type MarketPools, type MarketQueryInterface, type NestedResult, OLD_BORROW_INCENTIVE_PROTOCOL_ID, type Obligation, type ObligationAccount, type ObligationAccounts, type ObligationBorrowIncentive, type ObligationBorrowIncentiveReward, type ObligationCollateral, type ObligationDebt, type ObligationQueryInterface, type OptionalKeys, type OriginBorrowIncentiveAccountData, type OriginBorrowIncentiveAccountPoolData, type OriginBorrowIncentivePoolData, type OriginBorrowIncentivePoolPointData, type OriginMarketCollateralData, type OriginMarketPoolData, type OriginSpoolData, type OriginSpoolRewardPoolData, POOL_ADDRESSES, type ParsedBorrowIncentiveAccountData, type ParsedBorrowIncentiveAccountPoolData, type ParsedBorrowIncentivePoolData, type ParsedBorrowIncentivePoolPointData, type ParsedMarketCollateralData, type ParsedMarketPoolData, type ParsedSpoolData, type ParsedSpoolRewardPoolData, type PoolAddress, type QuickMethodReturnType, RPC_PROVIDERS, type RiskModel, SCA_COIN_TYPE, type SCoinAmounts, type SCoinConverterTreasury, type SCoinIds, type SCoinTreasuryCaps, type SCoinTxBlock, type SCoins, SDK_API_BASE_URL, Scallop, ScallopAddress, ScallopBuilder, ScallopClient, ScallopConstants, ScallopIndexer, ScallopQuery, ScallopSuiKit, type ScallopTxBlock, ScallopUtils, type Spool, type SpoolData, type SpoolIds, type SpoolNormalMethods, type SpoolQuickMethods, type SpoolRewardPool, type SpoolTxBlock, type Spools, type StakeAccount, type StakeAccounts, type StakeMarketCoins, type StakePool, type StakePools, type StakeRewardCoins, type StakeRewardPool, type StakeRewardPools, type SuiBridgeCoins, type SuiBridgedCoinPackageIds, type SuiTxBlockWithBorrowIncentiveNormalMethods, type SuiTxBlockWithCoreNormalMethods, type SuiTxBlockWithLoyaltyProgramNormalMethods, type SuiTxBlockWithSCoin, type SuiTxBlockWithSCoinNormalMethods, type SuiTxBlockWithSpool, type SuiTxBlockWithSpoolNormalMethods, type SuiTxBlockWithVeScaNormalMethods, type SupportOracleType, TEST_ADDRESSES, type TotalValueLocked, UNLOCK_ROUND_DURATION, USE_TEST_ADDRESS, type VeScaLoyaltyProgramInfo, type VeScaNormalMethods, type VeScaQuickMethods, type VeScaTreasuryFields, type VeScaTreasuryInfo, type VeScaTxBlock, type Vesca, type VoloCoinIds, WHITELIST, type Whitelist, type WormholeCoinIds, _SUPPORT_ORACLES, queryKeys, type sCoinBalance, type sCoinNormalMethods, type sCoinPkgIds, type sCoinQuickMethods, xOracleList, type xOracleListType, type xOracleRuleType, type xOracleRules };
