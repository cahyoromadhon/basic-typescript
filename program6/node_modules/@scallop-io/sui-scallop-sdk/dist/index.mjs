import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { normalizeStructTag as normalizeStructTag$1, SUI_CLOCK_OBJECT_ID } from '@mysten/sui/utils';
import { parseStructTag, normalizeStructTag, SuiTxBlock, SUI_TYPE_ARG, SuiKit, SUI_CLOCK_OBJECT_ID as SUI_CLOCK_OBJECT_ID$1, Transaction as Transaction$1 } from '@scallop-io/sui-kit';
import h from 'bignumber.js';
import { z } from 'zod';
import { bcs } from '@mysten/sui/bcs';
import mo from 'assert';
import { SuiPriceServiceConnection, SuiPythClient } from '@pythnetwork/pyth-sui-js';
import us from 'axios';
import { QueryClient } from '@tanstack/query-core';

var Tt={defaultOptions:{queries:{staleTime:5e3,gcTime:5e3}}};var At="https://sui.apis.scallop.io",Pt="https://sdk.api.scallop.io",ks=!1,Ts=!1,ge="0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6::sca::SCA",Ee="0xc63072e7f5f4983a2efaf5bdba1480d5e7d74d57948e1c7cc436f8e22cbeb410";var N={api:{getAddresses:t=>["api","getAddresses",t],getWhiteList:()=>["api","getWhiteList"],getPoolAddresses:()=>["api","getPoolAddresses"],getMarket:()=>["api","getMarket"],getSpools:()=>["api","getSpools"],getBorrowIncentivePool:()=>["api","getBorrowIncentivePools"],getTotalValueLocked:()=>["api","getTotalValueLocked"]},rpc:{getInspectTxn:t=>["rpc","getInspectTxn",t],getObject:t=>["rpc","getObject",t],getObjects:t=>["rpc","getObjects",t],getOwnedObjects:t=>["rpc","getOwnedObjects",{...t,filter:JSON.stringify(t?.filter??void 0)}],getDynamicFields:t=>["rpc","getDynamicFields",t],getDynamicFieldObject:t=>["rpc","getDynamicFieldObject",t],getTotalVeScaTreasuryAmount:t=>["rpc","getTotalVeScaTreasuryAmount",{...t,refreshArgs:t?.refreshArgs?JSON.stringify(t?.refreshArgs):void 0,vescaAmountArgs:t?.vescaAmountArgs?JSON.stringify(t?.vescaAmountArgs):void 0}],getAllCoinBalances:t=>["rpc","getAllCoinBalances",t],getNormalizedMoveFunction:t=>["rpc","getNormalizedMoveCall",t]},oracle:{getPythLatestPriceFeeds:()=>["oracle","getPythPriceIds"]}};var Ue=[getFullnodeUrl("mainnet"),"https://sui-mainnet.public.blastapi.io","https://sui-mainnet-ca-2.cosmostation.io","https://sui-mainnet-eu-4.cosmostation.io","https://sui-mainnet-endpoint.blockvision.org","https://sui-rpc.publicnode.com","https://sui-mainnet-rpc.allthatnode.com","https://mainnet.suiet.app","https://mainnet.sui.rpcpool.com","https://sui1mainnet-rpc.chainode.tech","https://fullnode.mainnet.apis.scallop.io","https://sui-mainnet-us-2.cosmostation.io"];var Rs={core:{version:"0xee15d07800e2ad4852505c57cd86afea774af02c17388f8bd907de75f915b4f4",versionCap:"0x590a4011cb649b3878f3ea14b3a78674642a9548d79b7e091ef679574b158a07",object:"0xb03fa00e2d9f17d78a9d48bd94d8852abec68c19d55e819096b1e062e69bfad1",market:"0xa7f41efe3b551c20ad6d6cea6ccd0fd68d2e2eaaacdca5e62d956209f6a51312",adminCap:"0x09689d018e71c337d9db6d67cbca06b74ed92196103624028ccc3ecea411777c",coinDecimalsRegistry:"0x200abe9bf19751cc566ae35aa58e2b7e4ff688fc1130f8d8909ea09bc137d668",obligationAccessStore:"0xb7d7e1464936fbdcdd4913308b40335e662401029635289bdb317c7dde9d6c68",coins:{usdc:{id:"0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7",metaData:"0x69b7a7c3c200439c1b5f3b19d7d495d5966d5f08de66c69276152f8db3992ec6",treasury:"",coinType:"0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",symbol:"USDC",decimals:6,oracle:{supra:"",switchboard:"",pyth:{feed:"eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",feedObject:"0x5dec622733a204ca27f5a90d8c2fad453cc6665186fd5dff13a83d0b6c9027ab"}}},sui:{id:"0x0000000000000000000000000000000000000000000000000000000000000002",metaData:"0x9258181f5ceac8dbffb7030890243caed69a9599d2886d957a9cb7656af3bdb3",treasury:"",coinType:"0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",symbol:"SUI",decimals:9,oracle:{supra:"",switchboard:"0xaebdb50e0a95c5aa20c60bde5f574dac90aef83b508d64146cf29b5f63c35d4f ",pyth:{feed:"23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744",feedObject:"0x801dbc2f0053d34734814b2d6df491ce7807a725fe9a01ad74a07e9c51396c37"}}},sca:{id:"0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6",metaData:"0x5d26a1e9a55c88147ac870bfa31b729d7f49f8804b8b3adfdf3582d301cca844",treasury:"",coinType:"0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6::sca::SCA",symbol:"SCA",decimals:9,oracle:{supra:"",switchboard:"",pyth:{feed:"7e17f0ac105abe9214deb9944c30264f5986bf292869c6bd8e8da3ccd92d79bc",feedObject:"0xf6de1d3279a269a597d813cbaca59aa906543ab9a8c64e84a4722f1a20863985"}}},deep:{id:"0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270",metaData:"0x6e60b051a08fa836f5a7acd7c464c8d9825bc29c44657fe170fe9b8e1e4770c0",treasury:"",coinType:"0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",symbol:"DEEP",decimals:6,oracle:{supra:"",switchboard:"",pyth:{feed:"29bdd5248234e33bd93d3b81100b5fa32eaa5997843847e2c2cb16d7c6d9f7ff",feedObject:"0x8c7f3a322b94cc69db2a2ac575cbd94bf5766113324c3a3eceac91e3e88a51ed"}}},fud:{id:"0x76cb819b01abed502bee8a702b4c2d547532c12f25001c9dea795a5e631c26f1",metaData:"0x01087411ef48aaac1eb6e24803213e3a60a03b147dac930e5e341f17a85e524e",treasury:"",coinType:"0x76cb819b01abed502bee8a702b4c2d547532c12f25001c9dea795a5e631c26f1::fud::FUD",symbol:"FUD",decimals:5,oracle:{supra:"",switchboard:"",pyth:{feed:"6a4090703da959247727f2b490eb21aea95c8684ecfac675f432008830890c75",feedObject:"0x4531c3ed0d22f21f5fce882905372006c9aafa30f01db03b789e95a6c50de7b2"}}}},oracles:{xOracle:"0x0c09daac413e834f2fe69601c41e836022fa9a185df6b56a80f6bcd8a3ecb8a2",xOracleCap:"0x1edeae568fde99e090dbdec4bcdbd33a15f53a1ce1f87aeef1a560dedf4b4a90",primaryPriceUpdatePolicyObject:"0xbcd908d0ee6d63d726e61676f3feeec3d19817f4849bbecf372dd3399f247f6b",secondaryPriceUpdatePolicyObject:"0x624a6f120777bb30e718b86e836c205ef4229448052377dc3d78272a6662b2c0",primaryPriceUpdatePolicyVecsetId:"0xfb1330aa028ed6a159b742c71b5a79b3b6824cf71efa40ea82b52486ad209264",secondaryPriceUpdatePolicyVecsetId:"0x4b827acc73f3f53f808dd73a7ee0a60ae61e84322176bece72b26467030b467c",supra:{registry:"",registryCap:"",holder:""},switchboard:{registry:"0x9b1b415f384af6af0ff31c22decdc88b3b83d0188cf63ef9c58fd122bca77219",registryTableId:"0x9f75c071b0db2e80da3f5c98686ffdedf3a633684290499501595277a5350b8c",state:"",registryCap:""},pyth:{registry:"0xdcf813893649521abd27816ba8d946b0cb7fc98d776cc9adcecba54688ccc109",registryCap:"0xe4995aaca4e70d4203790fbd22332107131e88b92b81bc976e6fc3a7d5005efd",state:"0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8",wormhole:"0x5306f64e312b581766351c07af79c72fcb1cd25147157fdc2f8ad76de9a3fb6a",wormholeState:"0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c"}},packages:{coinDecimalsRegistry:{id:"0xca5a5a62f01c79a104bf4d31669e29daa387f325c241de4edbe30986a9bc8b0d",upgradeCap:"0x34e76a945d29f195bc53ca704fa70877d1cf3a5d7bbfdda1b13e633fff13c0f6"},math:{id:"0xad013d5fde39e15eabda32b3dbdafd67dac32b798ce63237c27a8f73339b9b6f",upgradeCap:"0x3a329598231de02e6135c62284b66005b41cad1d9ab7ca2dc79c08293aba2ec6"},whitelist:{id:"0x1318fdc90319ec9c24df1456d960a447521b0a658316155895014a6e39b5482f",upgradeCap:"0xf5a22aea23db664f7b69855b6a546747f17c1ec4230319cfc17225e462b05761"},x:{id:"0x779b5c547976899f5474f3a5bc0db36ddf4697ad7e5a901db0415c2281d28162",upgradeCap:"0x3f203f6fff6a69d151e4f1cd931f22b68c489ef2759765662fc7baf673943c9e"},protocol:{id:"0xb03fa00e2d9f17d78a9d48bd94d8852abec68c19d55e819096b1e062e69bfad1",upgradeCap:"0x38527d154618d1fd5a644b90717fe07cf0e9f26b46b63e9568e611a3f86d5c1a"},protocolWhitelist:{id:"0x4c262d9343dac53ecb28f482a2a3f62c73d0ebac5b5f03d57383d56ff219acdf",upgradeCap:"0x4a5e88a75039b00988f633f811f58117f31b8627a46bf822aa114d9010049449"},query:{id:"0x3a0dbce719fc56a96bf8e8dd53cd57eb9c313642a88d99b86f51208762eba258",upgradeCap:"0x14220f035f4cfc2ce442c30703fb44d24f00846eb7077907a231a56051a1d9b2"},supra:{id:"",object:"",upgradeCap:""},pyth:{id:"0xe622909f9252d4ef1737c41ea430ef44203d8f5dc8e01e1b3950a31405bc54eb",object:"0xe622909f9252d4ef1737c41ea430ef44203d8f5dc8e01e1b3950a31405bc54eb",upgradeCap:"0xb1f167889643ff766df31745b6e93b92462d8165b0a4f1b095499e15180370f7"},switchboard:{id:"0x248f5cb31c12eed6ab8fd4c6176466b982be42ce87e6bf8ff896fb8097a1660d",object:"0x248f5cb31c12eed6ab8fd4c6176466b982be42ce87e6bf8ff896fb8097a1660d",upgradeCap:""},xOracle:{id:"0xe7511600c924f1d0ac4b3fa5de3ae26b8845545902b015dc5fc7894307365d7b",object:"0xe7511600c924f1d0ac4b3fa5de3ae26b8845545902b015dc5fc7894307365d7b",upgradeCap:"0x0f928a6b2e26b73330fecaf9b44acfc9800a4a9794d6415c2a3153bc70e3c1f0"},testCoin:{id:"",upgradeCap:""}}},spool:{id:"0x1742655fe5872dfa6456673f9e38612a4965e6979e6cd7696a7f1225f28bae21",adminCap:"0xdd8a047cbbf802bfcde5288b8ef1910965d789cc614da11d39af05fca0bd020a",object:"0xe87f1b2d498106a2c61421cec75b7b5c5e348512b0dc263949a0e7a3c256571a",pools:{ssui:{id:"0xb9617f83c06ebdeac0a8834782b1015e1cc7ea23739e30c132c4bfb95c37a579",rewardPoolId:"0xc3206071a8d43212efb6e3b5504f2321f8df97ab122b466c0bc7cfdf398dc13a"},susdc:{id:"0x0b5f5f413bd3799e4052c37311966c77f3a4545eb125d2e93e67a68478021918",rewardPoolId:"0x85ed6ed72ea97c35dbf0cdc7ed6fbc48d8ec15de9b17c74bf4512df8a6d7f166"}},config:""},borrowIncentive:{id:"0x045811c127a4063d78683ea61fa987b9252a798b0d3ae9e927e25adcbe5549e2",config:"0xe5fec608d3a30a1f75b24d2c67d227524075aa6f5ee22e5eccedacd9145b1d9d",object:"0x045811c127a4063d78683ea61fa987b9252a798b0d3ae9e927e25adcbe5549e2",incentivePools:"0xb06657692f7f4d9eb0d7b7d6ac24db30e6fdaed64b09dee49664b496f687de46",incentiveAccounts:"0x0bf8168d983c18edcc6b2c2b2e85d2bdac84764babfecf1b567f98801fbf4942",query:"0xdbc22fe051d384691634cd3b9fe473b09723084a1e4c128728c42e2de3b2228f",adminCap:"0xc486afa253646f4d381e81d7f1df8aa4723b845a6bb356f69bad635ffefffe2c"},vesca:{id:"0x0c7f5568dbd69488437ee95f2d9a028724e1de12432965ff8acca7c67310ba46",object:"0x0c7f5568dbd69488437ee95f2d9a028724e1de12432965ff8acca7c67310ba46",adminCap:"0x4d105b16467acca81d18c132cdd1a3cee159920a86c1ef4bdbf2e8d7878500c5",tableId:"0x5477d43c9f75faea312c0f02dd48b4e03d9cbf2b1a5436ddffb5edefbea18ff2",table:"0x06f763060ea5da3d639fb56df70674490a8354511cfe61584062aafd83b1940d",treasury:"0x934919cc31fa89b67578039bb10d5518fa23c50bc8f78500f1d1a718407a0a71",config:"0x38d3f7a1fa5071226535d4d8bfca8ccab3d24871402df1be669d7d5e9e3e9cb4",subsTable:"0x4756b716670ff62760b22bebed73c6eb2c2cb118674a2eea3a56ebea9e27ae76",subsTableId:"0x924b56d383b45445984a80002185b670aa2e72cd7df496d345f45f9407a12c07",subsWhitelist:"0xfc72adae643da4f2fe080adc1e2cca981eadcb518facb02324eeaab169752ffb"},referral:{id:"0x1bf5a8ce77050d8052549d743e16b469f15aa6b81b752b78b6ebb65179665f5a",object:"0x5658d4bf5ddcba27e4337b4262108b3ad1716643cac8c2054ac341538adc72ec",adminCap:"0xc5dc06b9074291259f2cac460c940012c781c4430e42125c541cc43101c3bcbd",referralBindings:"0xcf184487782bed962bf678001efe775d31fb94b9992333a57594cf15d79d5ced",bindingTableId:"0x41a50e258c0a266ce84e0e1a618dbf70b878cc943909e613089a50afcceb2bc0",referralRevenuePool:"0xc24e3e5e37032f29a3dd91a9a1f057af8821b7e6c148e9683900ac8b6d30f0c6",revenueTableId:"0x669dfb0f47fccbbe2ae8a0bfce2672a994ef3f1c7049621405cce2f91733bdc1",referralTiers:"0x144350f3db9b46d11b140084cd54e6de0b9c3b8d265ce8059b51d0ef58ea464b",tiersTableId:"0xad5e36fce7358a3ef94a56eb89ee7f1968100c1a9d967c1731154083e1dda1fb",authorizedWitnessList:"0xf21b0ed043c9bb70842c0129159f4943dbcc3c9ef2f2f808af65f8be25cfd20e",version:"0x3545849eb97723e676a476ec9d4fe5f2eb0eb2c6b78972851114fd4c7ed4639f"},loyaltyProgram:{id:"0xab7c4e6d53ef862a1115d0c381fd33e05f9c206b79f322a54990b1e8c2fe3446",object:"0xab7c4e6d53ef862a1115d0c381fd33e05f9c206b79f322a54990b1e8c2fe3446",rewardPool:"0x215e1022037052407e69a5c5938f888078013c924cae97132492719ac2c53ec6",userRewardTableId:"0x574a11f8a0fbaa05b8f559cb65634e8eb20f26b1ec29e7d58de9167f3cedd0f7"},veScaLoyaltyProgram:{id:"0x51bd8c455caedad9d7fd47f9ee75876668c4d6bbede95af39c0aebde46043f00",object:"0x51bd8c455caedad9d7fd47f9ee75876668c4d6bbede95af39c0aebde46043f00",adminCap:"0xb2d52e0ebb260cb42699be6a9804e12d6fa17b79ef1e43f9996df5ca71bac0ae",veScaRewardPool:"0x4fe34992bf2261c3c6c14b2dbf9606ce65a505c45ff778ac129ce7dea9b0cadf",veScaRewardTableId:"0x85d3e557d9bbed617b9cbc09982a0c9a6f6f4fc9ecce49b59124206c409c4774"},scoin:{id:"0x826a4934bee9487e558eed603cf42f30cdc4321d6f31083930791b95f903b9f9",coins:{ssui:{coinType:"0x88618204de2dfdc2597681a8441ee726b0dc13494c41e319c3264eb7b35fea90::scallop_sui::SCALLOP_SUI",metaData:"",symbol:"sSUI",treasury:"0x03f1d94a40bd9f5d556bacb5c5245732b185572f6a29b36ad8b555d9a8a24f09"},ssca:{coinType:"0x9f64a180373a6b66595025ae16a4ab701f0af1dd5c7ce1ac91dc112e52c2a3f8::scallop_sca::SCALLOP_SCA",metaData:"",symbol:"sSCA",treasury:"0x1b05d2cd8b20dba19da073a54195fc52d2f438ea19dea0713bae7a7dab308199"},susdc:{coinType:"0x55ed015f9f006c0c96ad36ebe3b3570d088e8498f52defea48e5634c110e485c::scallop_usdc::SCALLOP_USDC",treasury:"0x6ef82ef94472dcb8c2cdeac8df38874024c08570ca165986ba56d1e38fe0c0a3",symbol:"sUSDC",metaData:"0x763a21eba338e00bc684aaad80491c89eea5f247b59c47df45b17610c9ad58f2"},sdeep:{coinType:"0x34f0a2e793e1f79ceac72cfe3bb95f65541da449418289ccd12922d16140c882::scallop_deep::SCALLOP_DEEP",metaData:"",symbol:"sDEEP",treasury:"0x71d41465cf2d16fa0206126526bebdf65c8871d1fcfbd0c2237db2306afd67ba"},sfud:{coinType:"0x3b23c05f917052255a0b16a534dbd4446911aa4a30bd3497cdf5b736551e7ef8::scallop_fud::SCALLOP_FUD",metaData:"",symbol:"sFUD",treasury:"0x858c492d51425b922c040c1a389e185b3b00d565e7d72ead1a81dc733104660d"}}}},Is={lending:new Set(["usdc","sui","sca","fud","deep"]),collateral:new Set(["usdc","sui","sca","deep"]),borrowing:new Set(["usdc","sui","sca","fud","deep"]),packages:new Set(["coinDecimalsRegistry","math","whitelist","x","protocol","protocolWhitelist","query","supra","pyth","switchboard","xOracle","testCoin"]),spool:new Set(["susdc","ssui"]),scoin:new Set(["susdc","ssui","ssca","sdeep","sfud"]),suiBridge:new Set(["sbeth","sbusdt","sbwbtc"]),wormhole:new Set(["wusdc","wusdt","weth","wbtc","wapt","wsol"]),oracles:new Set(["pyth","supra","switchboard"]),pythEndpoints:new Set(["https://hermes.pyth.network"]),deprecated:new Set(["wapt","wusdc","wusdt","weth","wbtc"]),borrowIncentiveRewards:new Set(["mpoints"]),rewardsAsPoint:new Set(["mpoints"]),emerging:new Set(["wal","deep","sca","cetus"])},vs={usdc:{coinName:"usdc",symbol:"USDC",lendingPoolAddress:"0x13319d295914b390b22484373f20f822bca10314c34c227ae6e28df3d9aa8e01",collateralPoolAddress:"0x2fdcf63682577f6bfdd4296500067543ba9877d5d5e41ebd9e51b97ab071ce69",borrowDynamic:"0x7fd0660f0102789ad039542165c6cbc2d90ba3c1d9dbd4ac4ae8804d80817542",interestModel:"0xd4e7b06a79f63706523167f055296db641b0f8ddd6734c05e205f2de0fcefdd0",riskModel:"0x19e5993350186f192ffeb2cba0650b04c291390e149c8ac9b324ecf394daaa1a",borrowFeeKey:"",supplyLimitKey:"0x4be9ae54ac4d320f4f9c14cae78cb85c8e0e67791dd9bdba6d2db20614a28a24",borrowLimitKey:"0x6b01093cba95b835181f00e3a2c31ed8dfc8d64fe3db0fb80933a09f66e1ccf1",isolatedAssetKey:"",isIsolated:!1,spool:"0x0b5f5f413bd3799e4052c37311966c77f3a4545eb125d2e93e67a68478021918",spoolReward:"0x85ed6ed72ea97c35dbf0cdc7ed6fbc48d8ec15de9b17c74bf4512df8a6d7f166",sCoinType:"0x55ed015f9f006c0c96ad36ebe3b3570d088e8498f52defea48e5634c110e485c::scallop_usdc::SCALLOP_USDC",sCoinTreasury:"0x6ef82ef94472dcb8c2cdeac8df38874024c08570ca165986ba56d1e38fe0c0a3",sCoinMetadataId:"0x763a21eba338e00bc684aaad80491c89eea5f247b59c47df45b17610c9ad58f2",sCoinSymbol:"sUSDC",sCoinName:"susdc",coinMetadataId:"0x69b7a7c3c200439c1b5f3b19d7d495d5966d5f08de66c69276152f8db3992ec6",coinType:"0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",spoolName:"susdc",decimals:6,pythFeed:"eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",pythFeedObjectId:"0x5dec622733a204ca27f5a90d8c2fad453cc6665186fd5dff13a83d0b6c9027ab",flashloanFeeObject:"0x289c770f54b26a4175d57cc6061e3d05f96e52d352cb7c0a51e2e3bacb2aee30"},sui:{coinName:"sui",symbol:"SUI",lendingPoolAddress:"0xeb86ad67543c1ac2c4cbaf178d38a45ab27c2e69d60f0f8badd83f563f012c3c",collateralPoolAddress:"0xcba7bb07d4d3ce01d81e71d9def680aa8b417347bfd7834aee8fc3b85b61c9a1",borrowDynamic:"0xd47c2fd3dbb95ed06e5da92f6b99611ba94a36efa6a13d9b33b02519761cc84e",interestModel:"0x4742bb49aa49ab4e5d9dfa119cddc027d1b7811ac42ca1ce794818d4a4da68e7",riskModel:"0x6dc356e829cfca2d79f0d68a79b5ddd5296ad0c955a38e2fc397485e2b629367",borrowFeeKey:"",supplyLimitKey:"0x0602418e66fb7a73fa997077bd66f248ad5b090d43344a14b9f1db598ecc1d47",borrowLimitKey:"0x2b33a7efdcf6a6df24f4d8a356dd52f58d75bc023c3f171d99502d4d008b53f0",isolatedAssetKey:"",isIsolated:!1,spool:"0xb9617f83c06ebdeac0a8834782b1015e1cc7ea23739e30c132c4bfb95c37a579",spoolReward:"0xc3206071a8d43212efb6e3b5504f2321f8df97ab122b466c0bc7cfdf398dc13a",sCoinType:"0x88618204de2dfdc2597681a8441ee726b0dc13494c41e319c3264eb7b35fea90::scallop_sui::SCALLOP_SUI",sCoinTreasury:"0x03f1d94a40bd9f5d556bacb5c5245732b185572f6a29b36ad8b555d9a8a24f09",sCoinMetadataId:"",sCoinSymbol:"sSUI",sCoinName:"ssui",coinMetadataId:"0x9258181f5ceac8dbffb7030890243caed69a9599d2886d957a9cb7656af3bdb3",coinType:"0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",spoolName:"ssui",decimals:9,pythFeed:"23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744",pythFeedObjectId:"0x801dbc2f0053d34734814b2d6df491ce7807a725fe9a01ad74a07e9c51396c37",flashloanFeeObject:"0x27614284a8f0a699ffd35aae8f2572c937ec76771cb21b0d7930ec4491a76ed4"},sca:{coinName:"sca",symbol:"SCA",lendingPoolAddress:"0xd08ef85bc753616ce0f1e3ac01bbc8bd1ee53e03b1e82aaa9690db5cd285ef4c",collateralPoolAddress:"0x4f59b8ef2cdd195830890cf0c01e29c159e48a6a6c766c64fd4b26cfa9ee58c6",borrowDynamic:"0x7f6e11fbd32b5d0223f03bfda67a5b48c551a09cfff88edc187591f9a4b0ab10",interestModel:"0xcb10daf0fee6f416463444f5b47aac0f0197a889bc60be2c4f90916f6a8d2faa",riskModel:"0x043f21a35bd1e1060a7c579db46e10cfd039d0b75d6bfd758de97b60434ae708",borrowFeeKey:"",supplyLimitKey:"0x8dd938856b972a10ea27ecab2af7ed78e48fc5f6ccedaf2b2119959f747dc2e3",borrowLimitKey:"0x04c7de61c5b42972f9bf6a8b1848e5fea2d037ee8deba81741ecd4a70aa80d30",isolatedAssetKey:"",isIsolated:!1,spool:"",spoolReward:"",sCoinType:"0x9f64a180373a6b66595025ae16a4ab701f0af1dd5c7ce1ac91dc112e52c2a3f8::scallop_sca::SCALLOP_SCA",sCoinTreasury:"0x1b05d2cd8b20dba19da073a54195fc52d2f438ea19dea0713bae7a7dab308199",sCoinMetadataId:"",sCoinSymbol:"sSCA",sCoinName:"ssca",coinMetadataId:"0x5d26a1e9a55c88147ac870bfa31b729d7f49f8804b8b3adfdf3582d301cca844",coinType:"0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6::sca::SCA",spoolName:"ssca",decimals:9,pythFeed:"7e17f0ac105abe9214deb9944c30264f5986bf292869c6bd8e8da3ccd92d79bc",pythFeedObjectId:"0xf6de1d3279a269a597d813cbaca59aa906543ab9a8c64e84a4722f1a20863985",flashloanFeeObject:"0xe04e46471754b6f48d81c549ecfec09de02733715a63bec02364c6ac7c4dd2dc"},fud:{coinName:"fud",symbol:"FUD",lendingPoolAddress:"0xc8a078d15ee7bbff49a14835f36951833d2d55c91ffd2972251dadbff8045ca8",collateralPoolAddress:"",borrowDynamic:"0x345a2fa0fe5d5d704fd8ad609a9b7529f22e3cda738ad26756ad2a85e5d43777",interestModel:"0xc84a22d8bca58e5f05673d1de2a7406b1b7bc9dcd15fd848ba6555c7ecab9d83",borrowFeeKey:"",supplyLimitKey:"0xf98419aecc37a3c5de716f8ec590f8991a5be34da72ce1a2da09531ff45adf7d",borrowLimitKey:"0x3d928a001c453c50004baa54e14b0a0e1b0907d9c613dfd76064fd7ed4e8beb8",isolatedAssetKey:"",isIsolated:!1,spool:"",spoolReward:"",sCoinType:"0x3b23c05f917052255a0b16a534dbd4446911aa4a30bd3497cdf5b736551e7ef8::scallop_fud::SCALLOP_FUD",sCoinTreasury:"0x858c492d51425b922c040c1a389e185b3b00d565e7d72ead1a81dc733104660d",sCoinMetadataId:"",sCoinSymbol:"sFUD",sCoinName:"sfud",coinMetadataId:"0x01087411ef48aaac1eb6e24803213e3a60a03b147dac930e5e341f17a85e524e",coinType:"0x76cb819b01abed502bee8a702b4c2d547532c12f25001c9dea795a5e631c26f1::fud::FUD",spoolName:"sfud",decimals:5,pythFeed:"6a4090703da959247727f2b490eb21aea95c8684ecfac675f432008830890c75",pythFeedObjectId:"0x4531c3ed0d22f21f5fce882905372006c9aafa30f01db03b789e95a6c50de7b2",flashloanFeeObject:"0x1ddda368a5f37d7b8c53879cb333ccfd520fc4a3e2fc98b9b5fdacd1a5945d5a"},deep:{coinName:"deep",symbol:"DEEP",lendingPoolAddress:"0xfb8e4f68c9b14034da7f1f4703013dda69ebbb4578f835825bcf92ab89c3b5ae",collateralPoolAddress:"",borrowDynamic:"0xbf983b12a8707b174c0b037096ba2fbf1b30e6efb9cce14fc35207de0a696f79",interestModel:"0xb7f04cd3aaaefe671a79f9aed8646ae085a7e6812c1604044977c9355e0769c8",borrowFeeKey:"",supplyLimitKey:"0x599528fdfdc253e90dfd0acf4f4a166b391e2aac1ca6528abbff63225b548fee",borrowLimitKey:"0xf4217e8ef9d9c32e8992092e910a77535a8124c19b8a762a673f227f5f765a4e",isolatedAssetKey:"",isIsolated:!1,spool:"",spoolReward:"",sCoinType:"0x34f0a2e793e1f79ceac72cfe3bb95f65541da449418289ccd12922d16140c882::scallop_deep::SCALLOP_DEEP",sCoinTreasury:"0x71d41465cf2d16fa0206126526bebdf65c8871d1fcfbd0c2237db2306afd67ba",sCoinMetadataId:"",sCoinSymbol:"sDEEP",sCoinName:"sdeep",coinMetadataId:"0x6e60b051a08fa836f5a7acd7c464c8d9825bc29c44657fe170fe9b8e1e4770c0",coinType:"0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",spoolName:"sdeep",decimals:6,pythFeed:"29bdd5248234e33bd93d3b81100b5fa32eaa5997843847e2c2cb16d7c6d9f7ff",pythFeedObjectId:"0x8c7f3a322b94cc69db2a2ac575cbd94bf5766113324c3a3eceac91e3e88a51ed",flashloanFeeObject:"0xd54dfb677e9e011e2451375a7a2e318b4f2225c2a0b369bde0afcef8cbb1a863"}};var Z=86400,re=1460,$=126144e3,qe=1e10,Qe=1e9;var xt={usdc:{primary:["pyth"],secondary:[]},sbeth:{primary:["pyth"],secondary:[]},sbusdt:{primary:["pyth"],secondary:[]},sbwbtc:{primary:["pyth"],secondary:[]},weth:{primary:["pyth"],secondary:[]},wbtc:{primary:["pyth"],secondary:[]},wusdc:{primary:["pyth"],secondary:[]},wusdt:{primary:["pyth"],secondary:[]},sui:{primary:["pyth"],secondary:[]},wapt:{primary:["pyth"],secondary:[]},wsol:{primary:["pyth"],secondary:[]},cetus:{primary:["pyth"],secondary:[]},afsui:{primary:["pyth"],secondary:[]},hasui:{primary:["pyth"],secondary:[]},vsui:{primary:["pyth"],secondary:[]},sca:{primary:["pyth"],secondary:[]},fud:{primary:["pyth"],secondary:[]},deep:{primary:["pyth"],secondary:[]},fdusd:{primary:["pyth"],secondary:[]},blub:{primary:["pyth"],secondary:[]},musd:{primary:["pyth"],secondary:[]},ns:{primary:["pyth"],secondary:[]},usdy:{primary:["pyth"],secondary:[]}};var R=t=>{let e=t.blockData.sender;if(!e)throw new Error("Sender is required");return e},ne=t=>{if(t===void 0)throw new Error("veSca not found")},$e=t=>{if(t<=new Date().getTime())throw new Error("veSca is expired, use renewExpiredVeScaQuick instead")},We=(t,e,a)=>{ne(a),$e(a);let o=Math.floor(a/1e3);if(t<1)throw new Error("Minimum lock period is 1 day");let s=Math.floor((e-o)/86400);if(t>s)throw new Error(`Cannot extend lock period by ${t} days, maximum lock period is ~4 years (${1460} days), remaining lock period is ${1460-s}`)},Ot=(t,e,a,o)=>{let s=o?Math.floor(o/1e3):void 0,r=!s,n=!r&&s*1e3<=new Date().getTime();if(r||n)if(t!==void 0&&e!==void 0){if(e<=0)throw new Error("Lock period must be greater than 0");if(typeof t=="number"&&t<1e10)throw new Error(`Minimum lock amount for ${n?"renewing expired veSca":"initial lock"} is 10 SCA`);if(e*86400>126144e3)throw new Error(`Maximum lock period is ~4 years (${1460} days)`)}else throw new Error(`SCA amount and lock period is required for ${n?"renewing expired veSca":"initial lock"}`);else {if(ne(o),$e(o),typeof t=="number"&&t<1e9)throw new Error("Minimum top up amount is 1 SCA");a&&e&&We(e,a,o);}},Rt=(t,e)=>{if(ne(e),$e(e),t<1e9)throw new Error("Minimum top up amount is 1 SCA");if(!!e&&e<=new Date().getTime())throw new Error("veSca is expired, use renewExpiredVeScaQuick instead")},It=(t,e,a)=>{if(!a||a>new Date().getTime())throw new Error("Renew method can only be used for expired veSca");if(t<1e10)throw new Error("Minimum lock amount for renewing expired vesca 10 SCA");if(e*86400>=126057600)throw new Error(`Maximum lock period is ~4 years (${1459} days)`)};var Ge=t=>({coinType:normalizeStructTag$1(t.type.name),maxBorrowRate:Number(t.maxBorrowRate.value)/2**32,borrowRate:Number(t.interestRate.value)/2**32,borrowRateScale:Number(t.interestRateScale),borrowIndex:Number(t.borrowIndex),lastUpdated:Number(t.lastUpdated),cashAmount:Number(t.cash),debtAmount:Number(t.debt),marketCoinSupplyAmount:Number(t.marketCoinSupply),reserveAmount:Number(t.reserve),reserveFactor:Number(t.reserveFactor.value)/2**32,borrowWeight:Number(t.borrowWeight.value)/2**32,borrowFee:Number(t.borrowFeeRate.value)/2**32,baseBorrowRate:Number(t.baseBorrowRatePerSec.value)/2**32,borrowRateOnHighKink:Number(t.borrowRateOnHighKink.value)/2**32,borrowRateOnMidKink:Number(t.borrowRateOnMidKink.value)/2**32,highKink:Number(t.highKink.value)/2**32,midKink:Number(t.midKink.value)/2**32,minBorrowAmount:Number(t.minBorrowAmount),isIsolated:t.isIsolated,supplyLimit:Number(t.supplyLimit),borrowLimit:Number(t.borrowLimit)}),ze=(t,e)=>{let a=t.parseCoinNameFromType(e.coinType),o=t.getCoinDecimal(a);if(o===void 0)throw new Error(`Coin decimal not found for ${a}`);let s=24*365*3600,r=e.baseBorrowRate*s/e.borrowRateScale,n=e.borrowRateOnHighKink*s/e.borrowRateScale,i=e.borrowRateOnMidKink*s/e.borrowRateScale,c=e.maxBorrowRate*s/e.borrowRateScale,d=e.borrowRate*s/e.borrowRateScale,l=Math.floor(new Date().getTime()/1e3)-e.lastUpdated,u=h(e.borrowIndex).multipliedBy(h(l).multipliedBy(e.borrowRate)).dividedBy(e.borrowRateScale),p=h(e.borrowIndex).plus(u),m=h(p).dividedBy(e.borrowIndex).minus(1),b=h(e.debtAmount).multipliedBy(m),y=b.plus(e.debtAmount),f=y.shiftedBy(-1*o),g=h(e.reserveAmount).plus(b.multipliedBy(e.reserveFactor)),w=g.shiftedBy(-1*o),k=h(y).plus(Math.max(e.cashAmount-g.toNumber(),0)),A=k.shiftedBy(-1*o),F=h(y).dividedBy(k);F=F.isFinite()?F:h(0);let C=h(d).multipliedBy(F).multipliedBy(1-e.reserveFactor);C=C.isFinite()?C:h(0);let I=k.dividedBy(e.marketCoinSupplyAmount);return I=I.isFinite()&&!I.isNaN()?I:h(1),{baseBorrowApr:r,baseBorrowApy:t.parseAprToApy(r),borrowAprOnHighKink:n,borrowApyOnHighKink:t.parseAprToApy(n),borrowAprOnMidKink:i,borrowApyOnMidKink:t.parseAprToApy(i),coinDecimal:o,maxBorrowApr:c,maxBorrowApy:t.parseAprToApy(c),borrowApr:Math.min(d,c),borrowApy:Math.min(t.parseAprToApy(d),t.parseAprToApy(c)),borrowIndex:p.toNumber(),growthInterest:m.toNumber(),supplyAmount:k.toNumber(),supplyCoin:A.toNumber(),borrowAmount:y.toNumber(),borrowCoin:f.toNumber(),reserveAmount:g.toNumber(),reserveCoin:w.toNumber(),utilizationRate:F.toNumber(),supplyApr:C.toNumber(),supplyApy:t.parseAprToApy(C.toNumber()),conversionRate:I.toNumber(),isIsolated:e.isIsolated,maxSupplyCoin:h(e.supplyLimit).shiftedBy(-o).toNumber(),maxBorrowCoin:h(e.borrowLimit).shiftedBy(-o).toNumber()}},he=t=>({coinType:normalizeStructTag$1(t.type.name),isIsolated:t.isIsolated,collateralFactor:Number(t.collateralFactor.value)/4294967296,liquidationFactor:Number(t.liquidationFactor.value)/4294967296,liquidationDiscount:Number(t.liquidationDiscount.value)/4294967296,liquidationPenalty:Number(t.liquidationPenalty.value)/4294967296,liquidationReserveFactor:Number(t.liquidationReserveFactor.value)/4294967296,maxCollateralAmount:Number(t.maxCollateralAmount),totalCollateralAmount:Number(t.totalCollateralAmount)}),we=(t,e)=>{let a=t.parseCoinNameFromType(e.coinType),o=t.getCoinDecimal(a);if(o===void 0)throw new Error(`Coin decimal not found for ${a}`);let s=h(e.maxCollateralAmount).shiftedBy(-1*o),r=h(e.totalCollateralAmount).shiftedBy(-1*o);return {coinDecimal:o,isIsolated:e.isIsolated,maxDepositAmount:e.maxCollateralAmount,maxDepositCoin:s.toNumber(),depositAmount:e.totalCollateralAmount,depositCoin:r.toNumber()}},vt=t=>({stakeType:normalizeStructTag$1(t.stakeType.fields.name),maxPoint:Number(t.maxDistributedPoint),distributedPoint:Number(t.distributedPoint),pointPerPeriod:Number(t.distributedPointPerPeriod),period:Number(t.pointDistributionTime),maxStake:Number(t.maxStake),staked:Number(t.stakes),index:Number(t.index),createdAt:Number(t.createdAt),lastUpdate:Number(t.lastUpdate)}),jt=(t,e,a)=>{let s=h(t.pointPerPeriod).dividedBy(t.period),r=h(t.pointPerPeriod).dividedBy(t.period),n=r.gt(0)?h(t.maxPoint).minus(t.distributedPoint).dividedBy(r):h(0),i=t.createdAt,c=n.plus(t.lastUpdate).integerValue().toNumber(),d=h(Math.floor(new Date().getTime()/1e3)-t.lastUpdate).dividedBy(t.period).toFixed(0),l=h(t.maxPoint).minus(t.distributedPoint),u=h.minimum(h(d).multipliedBy(t.pointPerPeriod),l),p=h(t.index).plus(u.dividedBy(t.staked).isFinite()?h(1e9).multipliedBy(u).dividedBy(t.staked):0),m=h(t.distributedPoint).plus(u),b=h(t.staked),y=b.shiftedBy(-1*a),f=y.multipliedBy(e);return {distributedPointPerSec:s.toNumber(),accumulatedPoints:u.toNumber(),currentPointIndex:p.toNumber(),currentTotalDistributedPoint:m.toNumber(),startDate:new Date(i*1e3),endDate:new Date(c*1e3),stakedAmount:b.toNumber(),stakedCoin:y.toNumber(),stakedValue:f.toNumber()}},Nt=t=>({claimedRewards:Number(t.claimed_rewards),exchangeRateDenominator:Number(t.exchange_rate_denominator),exchangeRateNumerator:Number(t.exchange_rate_numerator),rewards:Number(t.rewards),spoolId:String(t.spool_id)}),_t=(t,e,a,o,s)=>{let n=h(a.distributedPointPerSec).multipliedBy(e.exchangeRateNumerator).dividedBy(e.exchangeRateDenominator),i=h(t.maxPoint).multipliedBy(e.exchangeRateNumerator).dividedBy(e.exchangeRateDenominator),c=i.shiftedBy(-1*s),d=c.multipliedBy(o),l=h(e.rewards),u=l.shiftedBy(-1*s),p=u.multipliedBy(o),m=h(e.claimedRewards),b=m.shiftedBy(-1*s),y=b.multipliedBy(o),f=h(n).shiftedBy(-1*s).multipliedBy(31536e3).multipliedBy(o),g=f.dividedBy(a.stakedValue).isFinite()?f.dividedBy(a.stakedValue).toNumber():1/0;return (t.maxPoint<=t.distributedPoint||t.pointPerPeriod===0)&&(g=1/0),{rewardApr:g,totalRewardAmount:i.toNumber(),totalRewardCoin:c.toNumber(),totalRewardValue:d.toNumber(),remaindRewardAmount:l.toNumber(),remaindRewardCoin:u.toNumber(),remaindRewardValue:p.toNumber(),claimedRewardAmount:m.toNumber(),claimedRewardCoin:b.toNumber(),claimedRewardValue:y.toNumber(),rewardPerSec:n.toNumber()}},Qa=t=>({pointType:normalizeStructTag$1(t.point_type.name),distributedPointPerPeriod:Number(t.distributed_point_per_period),period:Number(t.point_distribution_time),distributedPoint:Number(t.distributed_point),points:Number(t.points),index:Number(t.index),baseWeight:Number(t.base_weight),weightedAmount:Number(t.weighted_amount),lastUpdate:Number(t.last_update),createdAt:Number(t.created_at)}),Bt=(t,e)=>({poolType:normalizeStructTag$1(e.pool_type.name),minStakes:Number(e.min_stakes),maxStakes:Number(e.max_stakes),staked:Number(e.stakes),poolPoints:e.points.reduce((a,o)=>{let s=Qa(o),r=t.parseCoinNameFromType(s.pointType);return a[r]=s,a},{})}),Mt=(t,e,a,o,s)=>{let n=h(t.distributedPointPerPeriod).dividedBy(t.period),i=h(Math.floor(new Date().getTime()/1e3)-t.lastUpdate).dividedBy(t.period).toFixed(0),c=h.minimum(h(i).multipliedBy(t.distributedPointPerPeriod),h(t.points)),d=h(t.index).plus(c.dividedBy(t.weightedAmount).isFinite()?h(1e9).multipliedBy(c).dividedBy(t.weightedAmount):0),l=h(t.distributedPoint).plus(c),u=h(t.baseWeight),p=h(t.weightedAmount),m=p.shiftedBy(-1*s),b=m.multipliedBy(o),y=365*24*60*60,f=h(n).shiftedBy(-1*a),g=h(f).multipliedBy(y).multipliedBy(e),w=h(1e12),k=g.multipliedBy(h(t.baseWeight).dividedBy(w)).dividedBy(b).isFinite()&&t.points>0?g.multipliedBy(h(t.baseWeight).dividedBy(w)).dividedBy(b).toNumber():1/0;return {distributedPointPerSec:n.toNumber(),accumulatedPoints:c.toNumber(),currentPointIndex:d.toNumber(),currentTotalDistributedPoint:l.toNumber(),baseWeight:u.toNumber(),weightedStakedAmount:p.toNumber(),weightedStakedCoin:m.toNumber(),weightedStakedValue:b.toNumber(),rewardApr:k,rewardPerSec:f.toNumber()}},$a=t=>({pointType:normalizeStructTag$1(t.point_type.name),weightedAmount:Number(t.weighted_amount),points:Number(t.points),totalPoints:Number(t.total_points),index:Number(t.index)}),Dt=(t,e)=>({poolType:normalizeStructTag$1(e.pool_type.name),debtAmount:Number(e.debt_amount),pointList:e.points_list.reduce((a,o)=>{let s=$a(o),r=t.parseCoinNameFromType(s.pointType);return a[r]=s,a},{})}),ie=(...t)=>h(t.reduce((e,a)=>new h(a).lt(e)?a:e));var Se=(t,e,a)=>{let o=Math.max(1,Math.floor(Math.log10(Math.abs(t))+1)),s=Math.max(Math.floor((o-1)/e),1)+1,r=Math.pow(10,-s);return r=a==="increase"?1-r:1+r,r};var Ft=t=>{let e=new Date(t*1e3),a=new Date(t*1e3);a.setUTCHours(0,0,0,0),e.getUTCHours()>=0&&a.setUTCDate(a.getUTCDate()+1);let o=new Date().getTime();return a.getTime()-o>126144e3*1e3&&a.setUTCDate(a.getUTCDate()-1),Math.floor(a.getTime()/1e3)};var ce=t=>(t.endsWith("/")&&(t=t.slice(0,-1)),t);async function Wa(t,e,...a){let o=a[a.length-1];if(typeof o=="object"&&o.indexer)try{return await t.apply(e,a)}catch(s){return console.warn(`Indexer requests failed: ${s.message}. Retrying without indexer..`),await t.apply(e,[...a.slice(0,-1),{...o,indexer:!1}])}return await t.apply(e,a)}function L(t){return (...e)=>Wa(t,this,...e)}var W=t=>{if(!(t&&t.content&&"fields"in t.content))throw new Error(`Failed to parse object ${t}`);let e=t.content.fields;if(typeof e=="object"&&"value"in e){let a=e.value;return typeof a=="object"&&"fields"in a?a.fields:a}else if(typeof e=="object")return e;return e};var Ha=async({address:t,scallopSuiKit:e})=>{let a=t.get("borrowIncentive.query"),o=t.get("borrowIncentive.incentivePools"),s=`${a}::incentive_pools_query::incentive_pools_data`,r=[o];return (await e.queryInspectTxn({queryTarget:s,args:r}))?.events[0].parsedJson},Kt=async(t,e=[...t.constants.whitelist.lending],a=!1,o,s)=>{let r={};o=o??(await t.getMarketPools(void 0,{coinPrices:s,indexer:a})).pools,s=s??await t.getAllCoinPrices({marketPools:o});let n=await Ha(t);for(let i of n?.incentive_pools??[]){let c={},d=Bt(t.utils,i),l=normalizeStructTag$1(i.pool_type.name),u=t.utils.parseCoinNameFromType(l),p=s?.[u]??0,m=t.utils.getCoinDecimal(u);if(!e.includes(u))continue;for(let[g,w]of Object.entries(d.poolPoints)){if(!w)continue;let k=w.pointType,A=t.utils.parseCoinNameFromType(k),F=t.utils.getCoinDecimal(A);if(F===void 0)throw new Error(`Coin decimal not found for ${A}`);let C=s?.[A]??0,I=t.utils.parseSymbol(A),_=t.utils.getCoinDecimal(A),D=Mt(w,C,F,p,m);c[g]={symbol:I,coinName:A,coinType:k,coinDecimal:_,coinPrice:C,points:w.points,distributedPoint:w.distributedPoint,weightedAmount:w.weightedAmount,...D};}let b=h(d.staked),y=b.shiftedBy(-1*m),f=y.multipliedBy(p);r[u]={coinName:u,symbol:t.utils.parseSymbol(u),coinType:l,coinDecimal:m,coinPrice:p,stakedAmount:b.toNumber(),stakedCoin:y.toNumber(),stakedValue:f.toNumber(),points:c};}return r},Lt=async({utils:t},e,a=[...t.constants.whitelist.lending])=>{let o=t.address.get("borrowIncentive.query"),s=t.address.get("borrowIncentive.incentiveAccounts"),r=`${o}::incentive_account_query::incentive_account_data`,n=[s,e],c=(await t.scallopSuiKit.queryInspectTxn({queryTarget:r,args:n}))?.events[0]?.parsedJson;return Object.values(c?.pool_records??[]).reduce((l,u)=>{let p=Dt(t,u),m=p.poolType,b=t.parseCoinNameFromType(m);return a&&a.includes(b)&&(l[b]=p),l},{})},Vt=async({address:t,scallopSuiKit:e},a)=>{let o=t.get("borrowIncentive.object"),s=t.get("borrowIncentive.incentivePools"),r=t.get("vesca.object"),n=await e.queryGetObject(s);if(n?.data?.content?.dataType!=="moveObject")return null;let c=n.data.content.fields.ve_sca_bind.fields.id.id,d=`${o}::typed_id::TypedID<${r}::ve_sca::VeScaKey>`,l=await e.queryGetDynamicFieldObject({parentId:c,name:{type:d,value:a}});return l?.data?.content?.dataType!=="moveObject"?null:l.data.content.fields.value.fields.id},Et=async({address:t,scallopSuiKit:e},a)=>{let o=t.get("borrowIncentive.object"),s=t.get("borrowIncentive.incentiveAccounts"),r=t.get("core.object"),n=await e.queryGetObject(s);if(n?.data?.content?.dataType!=="moveObject")return null;let i=n.data.content.fields.accounts.fields.id.id,c=await e.queryGetDynamicFieldObject({parentId:i,name:{type:`${o}::typed_id::TypedID<${r}::obligation::Obligation>`,value:a}});return c?.data?.content?.dataType!=="moveObject"?null:c.data.content.fields.value.fields.binded_ve_sca_key?.fields.id??null};var Xa=z.object({dataType:z.string(),type:z.string(),hasPublicTransfer:z.boolean(),fields:z.object({id:z.object({id:z.string()}),name:z.object({type:z.string()}),value:z.string()})}),Ya="0x6e641f0dca8aedab3101d047e96439178f16301bf0b57fe8745086ff1195eb3e::market_dynamic_keys::SupplyLimitKey",Ce=async(t,e)=>{try{let a=t.parseCoinType(e).slice(2),o=t.address.get("core.market");if(!o)return null;let s=await t.scallopSuiKit.queryGetDynamicFieldObject({parentId:o,name:{type:Ya,value:a}}),r=Xa.safeParse(s?.data?.content);return r.success?r.data.fields.value:"0"}catch(a){return console.error(`Error in getSupplyLimit for ${e}: ${a.message}`),"0"}};var Ja=z.object({dataType:z.string(),type:z.string(),hasPublicTransfer:z.boolean(),fields:z.object({id:z.object({id:z.string()}),name:z.object({type:z.string()}),value:z.boolean()})}),Ut="0xe7dbb371a9595631f7964b7ece42255ad0e738cc85fe6da26c7221b220f01af6::market_dynamic_keys::IsolatedAssetKey",qt=async(t,e=!1)=>{if(!e)return t.utils.getSupportedPoolAddresses().filter(a=>!!a.isolatedAssetKey).map(a=>a.coinName);try{let a=t.address.get("core.market"),o=[];if(!a)return o;let s=!1,r=null,n=i=>i.name.type===Ut;do{let i=await t.scallopSuiKit.queryGetDynamicFields({parentId:a,cursor:r,limit:10});if(!i)break;let c=i.data.filter(n).map(({name:d})=>`0x${d.value.type.name}`);o.push(...c),i&&i.hasNextPage&&i.nextCursor?(s=!0,r=i.nextCursor):s=!1;}while(s);return o}catch(a){return console.error(a),[]}},oe=async(t,e)=>{let a=t.constants.poolAddresses[e];if(a)return a.isIsolated;let o=t.address.get("core.market"),s=t.queryClient.getQueryData(["getDynamicFields",o]);if(s){let c=t.parseCoinType(e);return s.includes(c)}let r=t.parseCoinType(e).slice(2),n=await t.scallopSuiKit.queryGetDynamicFieldObject({parentId:o,name:{type:Ut,value:r}}),i=Ja.safeParse(n?.data?.content);return i.success?i.data.fields.value:!1};var Za=z.object({dataType:z.string(),type:z.string(),hasPublicTransfer:z.boolean(),fields:z.object({id:z.object({id:z.string()}),name:z.object({type:z.string()}),value:z.string()})}),eo="0xe7dbb371a9595631f7964b7ece42255ad0e738cc85fe6da26c7221b220f01af6::market_dynamic_keys::BorrowLimitKey",ke=async(t,e)=>{try{let a=t.parseCoinType(e).slice(2),o=t.address.get("core.market");if(!o)return null;let s=await t.scallopSuiKit.queryGetDynamicFieldObject({parentId:o,name:{type:eo,value:a}}),r=Za.safeParse(s?.data?.content);return r.success?r.data.fields.value:"0"}catch(a){return console.error(`Error in getBorrowLimit for ${e}: ${a.message}`),"0"}};var to="0x00481a93b819d744a7d79ecdc6c62c74f2f7cb4779316c4df640415817ac61bb",Qt=async({constants:t,scallopSuiKit:e},a,o)=>{let s=new Set(a),r=Object.fromEntries(Object.entries(t.coinTypeToCoinNameMap).filter(([d,l])=>s.has(l))),n=null,i=!1,c=[];do{let d=await e.queryGetDynamicFields({parentId:to,limit:10,cursor:n});if(!d)break;let{data:l,hasNextPage:u,nextCursor:p}=d,m=l.filter(b=>{let y=`0x${b.name.value.name}`;return !!r[y]}).map(b=>b.objectId)??[];c.push(...await e.queryGetObjects(m)),i=u,n=p;}while(i);return c.reduce((d,l)=>{if(l.content?.dataType==="moveObject"){let u=`0x${l.content.fields.name.fields.name}`,p=r[u];if(!p)return d;let b=+l.content.fields.value;d[p]=b/o;}return d},{})};var Gt=async({utils:t,indexer:e},a=!1,o)=>{o=o??await t.getCoinPrices()??{};let s={},r={};if(a){let p=await e.getMarket(),m=y=>{y.coinPrice=o[y.coinName]??y.coinPrice,y.coinWrappedType=t.getCoinWrappedType(y.coinName),s[y.coinName]=y;},b=y=>{y.coinPrice=o[y.coinName]??y.coinPrice,y.coinWrappedType=t.getCoinWrappedType(y.coinName),r[y.coinName]=y;};return Object.values(p.pools).filter(y=>!!y).forEach(m),Object.values(p.collaterals).filter(y=>!!y).forEach(b),{pools:s,collaterals:r}}let n=t.address.get("core.packages.query.id"),i=t.address.get("core.market"),c=`${n}::market_query::market_data`,d=[i],u=(await t.scallopSuiKit.queryInspectTxn({queryTarget:c,args:d}))?.events[0]?.parsedJson;for(let p of u?.pools??[]){let m=normalizeStructTag$1(p.type.name),b=t.parseCoinNameFromType(m),y=o[b]??0;if(!t.constants.whitelist.lending.has(b))continue;let f=Ge({type:p.type,maxBorrowRate:p.maxBorrowRate,interestRate:p.interestRate,interestRateScale:p.interestRateScale,borrowIndex:p.borrowIndex,lastUpdated:p.lastUpdated,cash:p.cash,debt:p.debt,marketCoinSupply:p.marketCoinSupply,reserve:p.reserve,reserveFactor:p.reserveFactor,borrowWeight:p.borrowWeight,borrowFeeRate:p.borrowFeeRate,baseBorrowRatePerSec:p.baseBorrowRatePerSec,borrowRateOnHighKink:p.borrowRateOnHighKink,borrowRateOnMidKink:p.borrowRateOnMidKink,highKink:p.highKink,midKink:p.midKink,minBorrowAmount:p.minBorrowAmount,isIsolated:await oe(t,b),supplyLimit:await Ce(t,b)??"0",borrowLimit:await ke(t,b)??"0"}),g=ze(t,f);s[b]={coinName:b,symbol:t.parseSymbol(b),coinType:m,marketCoinType:t.parseMarketCoinType(b),sCoinType:t.parseSCoinType(t.parseMarketCoinName(b))??"",coinWrappedType:t.getCoinWrappedType(b),coinPrice:y,highKink:f.highKink,midKink:f.midKink,reserveFactor:f.reserveFactor,borrowWeight:f.borrowWeight,borrowFee:f.borrowFee,marketCoinSupplyAmount:f.marketCoinSupplyAmount,minBorrowAmount:f.minBorrowAmount,...g};}for(let p of u?.collaterals??[]){let m=normalizeStructTag$1(p.type.name),b=t.parseCoinNameFromType(m),y=o[b]??0;if(!t.constants.whitelist.collateral.has(b))continue;let f=he({type:p.type,collateralFactor:p.collateralFactor,liquidationFactor:p.liquidationFactor,liquidationDiscount:p.liquidationDiscount,liquidationPenalty:p.liquidationPanelty,liquidationReserveFactor:p.liquidationReserveFactor,maxCollateralAmount:p.maxCollateralAmount,totalCollateralAmount:p.totalCollateralAmount,isIsolated:await oe(t,b)}),g=we(t,f);r[b]={coinName:b,symbol:t.parseSymbol(b),coinType:m,marketCoinType:t.parseMarketCoinType(b),coinWrappedType:t.getCoinWrappedType(b),coinPrice:y,collateralFactor:f.collateralFactor,liquidationFactor:f.liquidationFactor,liquidationDiscount:f.liquidationDiscount,liquidationPenalty:f.liquidationPenalty,liquidationReserveFactor:f.liquidationReserveFactor,...g};}return {pools:s,collaterals:r}},zt=async({utils:t,scallopSuiKit:e},a)=>{let o={balanceSheet:[],collateralStat:[],borrowDynamic:[],interestModel:[],riskModel:[],borrowFeeKey:[],supplyLimitKey:[],borrowLimitKey:[],isolatedAssetKey:[]},s=new Map;for(let d of a){let l=t.constants.poolAddresses[d],u={balanceSheet:l?.lendingPoolAddress,collateralStat:l?.collateralPoolAddress,borrowDynamic:l?.borrowDynamic,interestModel:l?.interestModel,riskModel:l?.riskModel,borrowFeeKey:l?.borrowFeeKey,supplyLimitKey:l?.supplyLimitKey,borrowLimitKey:l?.borrowLimitKey,isolatedAssetKey:l?.isolatedAssetKey};Object.entries(u).forEach(([p,m])=>{m&&o[p].push(m);}),s.set(d,u);}let r={showContent:!0},n=await Promise.all([e.queryGetObjects(o.balanceSheet,r),e.queryGetObjects(o.collateralStat,r),e.queryGetObjects(o.borrowDynamic,r),e.queryGetObjects(o.interestModel,r),e.queryGetObjects(o.riskModel,r),e.queryGetObjects(o.borrowFeeKey,r),e.queryGetObjects(o.supplyLimitKey,r),e.queryGetObjects(o.borrowLimitKey,r)]),i={balanceSheet:new Map,collateralStat:new Map,borrowDynamic:new Map,interestModel:new Map,riskModel:new Map,borrowFeeKey:new Map,supplyLimitKey:new Map,borrowLimitKey:new Map,isolatedAssetKey:new Map,isIsolated:new Map};n.forEach((d,l)=>{let u=Object.keys(i)[l];d.forEach(p=>{i[u].set(p.objectId,p);});});let c={};for(let[d,l]of s)c[d]={balanceSheet:l.balanceSheet?i.balanceSheet.get(l.balanceSheet):void 0,collateralStat:l.collateralStat?i.collateralStat.get(l.collateralStat):void 0,borrowDynamic:l.borrowDynamic?i.borrowDynamic.get(l.borrowDynamic):void 0,interestModel:l.interestModel?i.interestModel.get(l.interestModel):void 0,riskModel:l.riskModel?i.riskModel.get(l.riskModel):void 0,borrowFeeKey:l.borrowFeeKey?i.borrowFeeKey.get(l.borrowFeeKey):void 0,supplyLimitKey:l.supplyLimitKey?i.supplyLimitKey.get(l.supplyLimitKey):void 0,borrowLimitKey:l.borrowLimitKey?i.borrowLimitKey.get(l.borrowLimitKey):void 0,isolatedAssetKey:l.isolatedAssetKey?i.isolatedAssetKey.get(l.isolatedAssetKey):void 0,isIsolated:t.constants.poolAddresses[d]?.isIsolated};return c},Ht=async(t,e,a=!1,o)=>{o=o??await t.utils.getCoinPrices();let s={},r={};if(a){let i=await t.indexer.getMarket(),c=l=>{l.coinPrice=o[l.coinName]??l.coinPrice,l.coinWrappedType=t.utils.getCoinWrappedType(l.coinName),s[l.coinName]=l;},d=l=>{l.coinPrice=o[l.coinName]??l.coinPrice,l.coinWrappedType=t.utils.getCoinWrappedType(l.coinName),r[l.coinName]=l;};return Object.values(i.pools).filter(l=>!!l).forEach(c),Object.values(i.collaterals).filter(l=>!!l).forEach(d),{pools:s,collaterals:r}}let n=await zt(t,e);return await Promise.allSettled(e.map(async i=>{try{let c=await so(t,i,a,o?.[i]??0,n[i]);c?.marketPool&&(s[i]=c?.marketPool),c?.collateral&&(r[i]=c.collateral);}catch(c){console.error(c);}})),{pools:s,collaterals:r}},oo=({balanceSheet:t,borrowDynamic:e,collateralStat:a,interestModel:o,riskModel:s,borrowFeeKey:r,supplyLimitKey:n,borrowLimitKey:i,isIsolated:c})=>{if(!t||!e||!o)throw new Error("Missing required market objects");let d=W(t),l=W(o),u=W(e),p=r?W(r):{value:"0"},m=n?W(n):"0",b=i?W(i):"0",y=s?W(s):void 0,f=a?W(a):void 0,g=y&&f?{type:l.type.fields,isIsolated:c,collateralFactor:y.collateral_factor.fields,liquidationFactor:y.liquidation_factor.fields,liquidationPenalty:y.liquidation_penalty.fields,liquidationDiscount:y.liquidation_discount.fields,liquidationReserveFactor:y.liquidation_revenue_factor.fields,maxCollateralAmount:y.max_collateral_amount,totalCollateralAmount:f.amount}:void 0;return {type:l.type.fields,maxBorrowRate:l.max_borrow_rate.fields,interestRate:u.interest_rate.fields,interestRateScale:u.interest_rate_scale,borrowIndex:u.borrow_index,lastUpdated:u.last_updated,cash:d.cash,debt:d.debt,marketCoinSupply:d.market_coin_supply,reserve:d.revenue,reserveFactor:l.revenue_factor.fields,borrowWeight:l.borrow_weight.fields,borrowFeeRate:p,baseBorrowRatePerSec:l.base_borrow_rate_per_sec.fields,borrowRateOnHighKink:l.borrow_rate_on_high_kink.fields,borrowRateOnMidKink:l.borrow_rate_on_mid_kink.fields,highKink:l.high_kink.fields,midKink:l.mid_kink.fields,minBorrowAmount:l.min_borrow_amount,isIsolated:c,supplyLimit:m,borrowLimit:b,parsedOriginMarketCollateral:g}},so=async(t,e,a=!1,o,s)=>{if(o=o??(await t.utils.getCoinPrices())?.[e],a){let l=await t.indexer.getMarketPool(e);if(!l)return;l.coinPrice=o??l.coinPrice,l.coinWrappedType=t.utils.getCoinWrappedType(l.coinName);let u;return t.constants.whitelist.collateral.has(e)&&(u=await t.indexer.getMarketCollateral(e),u.coinPrice=o??u.coinPrice,u.coinWrappedType=t.utils.getCoinWrappedType(u.coinName)),{marketPool:l,collateral:u}}if(s??=(await zt(t,[e]))[e],!s)throw new Error(`Failed to fetch required market objects for ${e}`);let r=oo(s),n=Ge(r),i=ze(t.utils,n),c=r.parsedOriginMarketCollateral?he(r.parsedOriginMarketCollateral):void 0,d=()=>({coinName:e,symbol:t.utils.parseSymbol(e),marketCoinType:t.utils.parseMarketCoinType(e),coinType:t.utils.parseCoinType(e)});return {marketPool:{...d(),sCoinType:t.utils.parseSCoinType(t.utils.parseMarketCoinName(e))??"",coinWrappedType:t.utils.getCoinWrappedType(e),coinPrice:o??0,highKink:n.highKink,midKink:n.midKink,reserveFactor:n.reserveFactor,borrowWeight:n.borrowWeight,borrowFee:n.borrowFee,marketCoinSupplyAmount:n.marketCoinSupplyAmount,minBorrowAmount:n.minBorrowAmount,...i},collateral:c?{...d(),coinWrappedType:t.utils.getCoinWrappedType(e),coinPrice:o,collateralFactor:c.collateralFactor,liquidationFactor:c.liquidationFactor,liquidationDiscount:c.liquidationDiscount,liquidationPenalty:c.liquidationPenalty,liquidationReserveFactor:c.liquidationReserveFactor,...we(t.utils,c)}:void 0}},Xt=async({utils:t,indexer:e,scallopSuiKit:a},o=[...t.constants.whitelist.collateral],s=!1)=>{let r=t.address.get("core.market"),n=await t.getCoinPrices()??{},i={};if(s){let d=await e.getMarketCollaterals(),l=u=>{o.includes(u.coinName)&&(u.coinPrice=n[u.coinName]??u.coinPrice,u.coinWrappedType=t.getCoinWrappedType(u.coinName),i[u.coinName]=u);};return Object.values(d).filter(u=>!!u).forEach(l),i}let c=await a.queryGetObject(r);return await Promise.allSettled(o.map(async d=>{let l=await He({utils:t,indexer:e,scallopSuiKit:a},d,s,c?.data,n?.[d]);l&&(i[d]=l);})),i},He=async({utils:t,indexer:e,scallopSuiKit:a},o,s=!1,r,n)=>{if(n=n??(await t.getCoinPrices())?.[o],s){let A=await e.getMarketCollateral(o);return A.coinPrice=n??A.coinPrice,A.coinWrappedType=t.getCoinWrappedType(A.coinName),A}let i=t.address.get("core.market");if(r=r||(await a.queryGetObject(i))?.data,!(r&&r.content?.dataType==="moveObject"))throw new Error("Failed to fetch marketObject");let c=r.content.fields,d=t.parseCoinType(o),l=c.risk_models.fields.table.fields.id.id,u=await a.queryGetDynamicFieldObject({parentId:l,name:{type:"0x1::type_name::TypeName",value:{name:d.substring(2)}}}),p=u?.data;if(!(p&&p.content&&"fields"in p.content))throw new Error(`Failed to fetch riskModelDynamicFieldObject for ${u?.error?.code.toString()}: `);let m=p.content.fields.value.fields,b=c.collateral_stats.fields.table.fields.id.id,y=await a.queryGetDynamicFieldObject({parentId:b,name:{type:"0x1::type_name::TypeName",value:{name:d.substring(2)}}}),f=y?.data;if(!(f&&f.content&&"fields"in f.content))throw new Error(`Failed to fetch collateralStatDynamicFieldObject for ${o}: ${y?.error?.code.toString()}`);let g=f.content.fields.value.fields,w=he({type:m.type.fields,collateralFactor:m.collateral_factor.fields,liquidationFactor:m.liquidation_factor.fields,liquidationDiscount:m.liquidation_discount.fields,liquidationPenalty:m.liquidation_penalty.fields,liquidationReserveFactor:m.liquidation_revenue_factor.fields,maxCollateralAmount:m.max_collateral_amount,totalCollateralAmount:g.amount,isIsolated:await oe(t,o)}),k=we(t,w);return {coinName:o,symbol:t.parseSymbol(o),coinType:t.parseCoinType(o),marketCoinType:t.parseMarketCoinType(o),coinWrappedType:t.getCoinWrappedType(o),coinPrice:n??0,collateralFactor:w.collateralFactor,liquidationFactor:w.liquidationFactor,liquidationDiscount:w.liquidationDiscount,liquidationPenalty:w.liquidationPenalty,liquidationReserveFactor:w.liquidationReserveFactor,...k}},se=async({utils:t},e)=>{let a=e,o=t.constants.protocolObjectId,s=[],r=!1,n=null;do{let l=await t.scallopSuiKit.queryGetOwnedObjects({owner:a,filter:{StructType:`${o}::obligation::ObligationKey`},options:{showContent:!0},cursor:n,limit:10});if(!l)break;s.push(...l.data),l.hasNextPage&&l.nextCursor?(r=!0,n=l.nextCursor):r=!1;}while(r);let i=s.filter(l=>!!l.data),c=[],d=await t.scallopSuiKit.queryGetObjects(i.map(l=>l.data?.content).filter(l=>l?.dataType==="moveObject").map(l=>l.fields.ownership.fields.of));return await Promise.allSettled(i.map(async({data:l},u)=>{let p=l?.objectId,m=l?.content;if(p&&m&&"fields"in m){let b=m.fields,y=String(b.ownership.fields.of),f=await Xe(t,d[u]);c.push({id:y,keyId:p,locked:f});}})),c},Xe=async({scallopSuiKit:t},e)=>{let a=typeof e=="string"?(await t.queryGetObject(e))?.data:e,o=!1;return a&&a?.content?.dataType==="moveObject"&&"lock_key"in a.content.fields&&(o=!!a.content.fields.lock_key),o},Te=async({address:t,scallopSuiKit:e},a)=>{let o=t.get("core.packages.query.id"),s=t.get("core.version"),r=t.get("core.market"),n=`${o}::obligation_query::obligation_data`,i=[s,r,a,{objectId:SUI_CLOCK_OBJECT_ID,mutable:!1,initialSharedVersion:"1"}];return (await e.queryInspectTxn({queryTarget:n,args:i}))?.events[0]?.parsedJson},Yt=async({utils:t},e=[...t.constants.whitelist.lending],a)=>{let o=a??t.walletAddress,s={};return await Promise.allSettled(e.map(async r=>{let n=await Ye({utils:t},r,o);s[r]=n;})),s},Ye=async({utils:t},e,a)=>{let o=a??t.walletAddress,s=t.parseCoinType(e),r=await t.scallopSuiKit.queryGetCoinBalance({owner:o,coinType:s});return h(r?.totalBalance??"0").toNumber()},Jt=async({utils:t},e,a)=>{e=e||[...t.constants.whitelist.lending].map(r=>t.parseMarketCoinName(r));let o=a??t.walletAddress,s={};return await Promise.allSettled(e.map(async r=>{let n=await Je({utils:t},r,o);s[r]=n;})),s},Je=async({utils:t},e,a)=>{let o=a??t.walletAddress,s=t.parseMarketCoinType(e),r=await t.scallopSuiKit.queryGetCoinBalance({owner:o,coinType:s});return h(r?.totalBalance??"0").toNumber()},Zt=async({utils:t},e,a=1e4)=>{let o=[],s={},r=e.reduce((c,d)=>{let l=t.parseCoinType(d).slice(2);return c[l]=d,c},{}),n=e.map(c=>{let d=t.constants.poolAddresses[c]?.flashloanFeeObject;return d||(o.push(c),null)}).filter(c=>!!c),i=await t.scallopSuiKit.queryGetObjects(n);if(o.length>0){let c=await Qt(t,o,a);s={...s,...c};}return s={...s,...i.reduce((c,d)=>{if(d.content?.dataType==="moveObject"){let l=d.content.fields,u=d.content.fields.name.fields.name,p=+l.value;c[r[u]]=p/a;}return c},{})},s};var ro=z.object({balance:z.string(),enable_claim:z.boolean()}).transform(t=>({totalPoolReward:h(t.balance).shiftedBy(-9).toNumber(),isClaimEnabled:t.enable_claim})),no=z.object({value:z.string()}).transform(t=>h(t.value).shiftedBy(-9).toNumber()),ea=async(t,e)=>{let a=t.address.get("loyaltyProgram.rewardPool"),o=await t.scallopSuiKit.queryGetObject(a);if(o?.data?.content?.dataType!=="moveObject")return null;let s=o.data.content.fields,{isClaimEnabled:r,totalPoolReward:n}=ro.parse(s),i={pendingReward:0,totalPoolReward:n,isClaimEnabled:r};if(e=e??(await t.getVeScas())[0]?.keyObject,!e)return i;let c=t.address.get("loyaltyProgram.userRewardTableId"),d=await t.scallopSuiKit.queryGetDynamicFieldObject({parentId:c,name:{type:"0x2::object::ID",value:typeof e=="string"?e:e.objectId}});if(d?.data?.content?.dataType!=="moveObject")return i;let l=d.data.content.fields;return i.pendingReward=no.parse(l),i},io=z.object({reserve_ve_sca_key:z.nullable(z.object({fields:z.object({id:z.object({id:z.string()})}),type:z.string()})),enable_claim:z.boolean()}).transform(t=>({reserveVeScaKey:t.reserve_ve_sca_key?.fields.id.id,isClaimEnabled:t.enable_claim})),co=z.object({value:z.string()}).transform(t=>h(t.value).shiftedBy(-9).toNumber()),ta=async(t,e)=>{let a=t.address.get("veScaLoyaltyProgram.veScaRewardPool"),o=await t.scallopSuiKit.queryGetObject(a);if(o?.data?.content?.dataType!=="moveObject")return null;let s=o.data.content.fields,{isClaimEnabled:r,reserveVeScaKey:n}=io.parse(s),i={pendingVeScaReward:0,pendingScaReward:0,totalPoolReward:0,isClaimEnabled:r},c;if(n&&(c=await t.getVeSca(n),i.totalPoolReward=c?.currentVeScaBalance??0),e=e??(await t.getVeScas())[0]?.keyObject,!e)return i;let d=t.address.get("veScaLoyaltyProgram.veScaRewardTableId"),l=await t.scallopSuiKit.queryGetDynamicFieldObject({parentId:d,name:{type:"0x2::object::ID",value:typeof e=="string"?e:e.objectId}});if(l?.data?.content?.dataType!=="moveObject")return i;let u=l.data.content.fields;i.pendingScaReward=co.parse(u);let p=Math.max((c?.unlockAt??0)-Date.now(),0);return i.pendingVeScaReward=i.pendingScaReward*(Math.floor(p/1e3)/126144e3),i};var aa=async(t,e=[...t.constants.whitelist.lending],a,o,s,r=!1)=>{let n=e.map(m=>t.utils.parseMarketCoinName(m)),i=n.filter(m=>t.constants.whitelist.spool.has(m));s=s??await t.utils.getCoinPrices(),o=o??(await t.getMarketPools(e,{indexer:r,coinPrices:s})).pools;let c=await t.getSpools(i,{indexer:r,marketPools:o,coinPrices:s}),[d,l,u]=await Promise.all([t.getCoinAmounts(e,a),t.getMarketCoinAmounts(n,a),t.getAllStakeAccounts(a)]),p={};return await Promise.allSettled(e.map(async m=>{let b=i.find(f=>f===t.utils.parseMarketCoinName(m)),y=t.utils.parseMarketCoinName(m);p[m]=await et(t,m,a,r,o?.[m],b?c[b]:void 0,b?u[b]:[],d?.[m],l?.[y],s?.[m]??0);})),p},et=async(t,e,a,o=!1,s,r,n,i,c,d,l)=>{let u=t.utils.parseMarketCoinName(e);if(d=d??(await t.utils.getCoinPrices())?.[e]??0,s=s??await t.getMarketPool(e,{indexer:o,coinPrice:d}),!s)throw new Error(`Failed to fetch marketPool for ${e}`);r=r??t.constants.whitelist.spool.has(u)?await t.getSpool(u,{indexer:o,marketPool:s,coinPrices:{[e]:d}}):void 0,n=n||t.constants.whitelist.spool.has(u)?await t.getStakeAccounts(u,a):[],i=i||await t.getCoinAmount(e,a),c=c||await t.getMarketCoinAmount(u,a),l=l||await t.getSCoinAmount(u,a);let p=t.utils.getCoinDecimal(e),m=h(0),b=h(0),y=h(0),f=h(0),g=h(0),w=h(0),k=h(0),A=h(0),F=h(0);if(r)for(let E of n){let v=h(E.staked),j=v.shiftedBy(-1*r.coinDecimal),K=v.multipliedBy(s?.conversionRate??1),q=K.shiftedBy(-1*r.coinDecimal),M=q.multipliedBy(r.coinPrice);m=m.plus(v),b=b.plus(j),y=y.plus(K),f=f.plus(q),g=g.plus(M),w=w.plus(v),k=w.shiftedBy(-1*r.coinDecimal);let X=r.currentPointIndex?h(r.currentPointIndex-E.index).dividedBy(1e9):1;A=A.plus(v.multipliedBy(X).plus(E.points).multipliedBy(r.exchangeRateNumerator).dividedBy(r.exchangeRateDenominator)),F=A.shiftedBy(-1*r.rewardCoinDecimal);}let C=h(c).plus(h(l)).multipliedBy(s?.conversionRate??1),I=C.shiftedBy(-1*p),_=I.multipliedBy(d??0),D=h(d??0).multipliedBy(s?.conversionRate??1),ee=h(c).plus(h(l)),U=ee.shiftedBy(-1*p),T=h(i),P=T.shiftedBy(-1*p),x=ie(C,s?.supplyAmount??1/0).plus(y),O=ie(I,s?.supplyCoin??1/0).plus(f);return {coinName:e,symbol:t.utils.parseSymbol(e),coinType:t.utils.parseCoinType(e),marketCoinType:t.utils.parseMarketCoinType(e),sCoinType:s?.sCoinType??"",coinDecimal:p,coinPrice:d??0,conversionRate:s?.conversionRate??1,marketCoinPrice:D.toNumber(),supplyApr:s?.supplyApr??0,supplyApy:s?.supplyApy??0,rewardApr:r?.rewardApr??0,suppliedAmount:C.plus(y).toNumber(),suppliedCoin:I.plus(f).toNumber(),suppliedValue:_.plus(g).toNumber(),stakedMarketAmount:m.toNumber(),stakedMarketCoin:b.toNumber(),stakedAmount:y.toNumber(),stakedCoin:f.toNumber(),stakedValue:g.toNumber(),unstakedMarketAmount:ee.toNumber(),unstakedMarketCoin:U.toNumber(),unstakedAmount:C.toNumber(),unstakedCoin:I.toNumber(),unstakedValue:_.toNumber(),availableSupplyAmount:T.toNumber(),availableSupplyCoin:P.toNumber(),availableWithdrawAmount:x.toNumber(),availableWithdrawCoin:O.toNumber(),availableStakeAmount:ee.toNumber(),availableStakeCoin:U.toNumber(),availableUnstakeAmount:w.toNumber(),availableUnstakeCoin:k.toNumber(),availableClaimAmount:A.toNumber(),availableClaimCoin:F.toNumber(),isIsolated:s?s.isIsolated:!1}},oa=async(t,e,a,o,s=!1)=>{a=a??await t.getMarketPools(void 0,{indexer:s}),o=o??await t.getAllCoinPrices({marketPools:a.pools});let[r,n]=await Promise.all([t.getCoinAmounts(void 0,e),t.getObligations(e)]),i=await t.scallopSuiKit.queryGetObjects(n.map(d=>d.id)),c={};return await Promise.allSettled(n.map(async(d,l)=>{c[d.keyId]=await Ae(t,i[l]??d.id,e,s,a,o,r);})),c},sa=async(t,e,a,o,s=!1)=>{a=a??await t.getMarketPools(void 0,{indexer:s}),o=o??await t.getAllCoinPrices({marketPools:a.pools});let r=[];return await Promise.allSettled(e.map(async n=>{let i=await Ae(t,n,"",s,a,o,{});i&&r.push(i);})),r},Ae=async(t,e,a,o=!1,s,r,n)=>{s=s??await t.getMarketPools(void 0,{indexer:o}),r=r??await t.getAllCoinPrices({marketPools:s.pools}),n=n??await t.getCoinAmounts(Array.from(t.constants.whitelist.lending),a);let[i,c,d]=await Promise.all([t.queryObligation(e),t.getBorrowIncentivePools(void 0,{coinPrices:r,marketPools:s.pools}),t.getBorrowIncentiveAccounts(e)]),l={},u={},p={},m=0,b=h(0),y=h(0),f=h(0),g=0,w=0,k=h(0),A=h(0);for(let T of Array.from(t.constants.whitelist.collateral)){let P=i?.collaterals.find(v=>{let j=t.utils.parseCoinNameFromType(v.type.name);return T===j}),x=s.collaterals[T],O=t.utils.getCoinDecimal(T),B=r?.[T],E=n?.[T]??0;if(x&&B){let v=h(P?.amount??0),j=v.shiftedBy(-1*O),K=j.multipliedBy(B),q=K.multipliedBy(x.collateralFactor),M=K.multipliedBy(x.liquidationFactor),Q=h(E),X=Q.shiftedBy(-1*O);b=b.plus(K),y=y.plus(q),f=f.plus(M),v.isGreaterThan(0)&&m++,l[T]={coinName:T,coinType:t.utils.parseCoinType(T),symbol:t.utils.parseSymbol(T),coinDecimal:O,coinPrice:B,depositedAmount:v.toNumber(),depositedCoin:j.toNumber(),depositedValue:K.toNumber(),borrowCapacityValue:q.toNumber(),requiredCollateralValue:M.toNumber(),availableDepositAmount:Q.toNumber(),availableDepositCoin:X.toNumber(),availableWithdrawAmount:0,availableWithdrawCoin:0};}}let F=[...new Set([...Object.values(s.pools).filter(T=>!!T).map(T=>T.coinName)])];for(let T of F){let P=i?.debts.find(v=>{let j=t.utils.parseCoinNameFromType(v.type.name);return T===j}),x=s.pools[T],O=t.utils.getCoinDecimal(T),B=r?.[T],E=n?.[T]??0;if(x&&B){let v=P?.borrowIndex?x.borrowIndex/Number(P.borrowIndex)-1:0,j=h(P?.amount??0).multipliedBy(v+1),K=j.shiftedBy(-1*O),q=j,M=q.shiftedBy(-1*O),Q=h(E),X=Q.shiftedBy(-1*O),J=M.multipliedBy(B),ye=J.multipliedBy(x.borrowWeight);k=k.plus(J),A=A.plus(ye),j.isGreaterThan(0)&&g++,u[T]={coinName:T,coinType:t.utils.parseCoinType(T),symbol:t.utils.parseSymbol(T),coinDecimal:O,coinPrice:B,borrowedAmount:j.toNumber(),borrowedCoin:K.toNumber(),borrowedValue:J.toNumber(),borrowedValueWithWeight:ye.toNumber(),borrowIndex:Number(P?.borrowIndex??0),requiredRepayAmount:q.toNumber(),requiredRepayCoin:M.toNumber(),availableBorrowAmount:0,availableBorrowCoin:0,availableRepayAmount:Q.toNumber(),availableRepayCoin:X.toNumber()};}}for(let[T,P]of Object.entries(d)){if(!P)continue;let x=T,O=c[x];if(O){let B=[];Object.entries(P.pointList).forEach(([E,v])=>{let j=O.points[t.utils.parseSCoinTypeNameToMarketCoinName(E)];if(v&&j){let K=h(0),q=h(0),M=h(v.weightedAmount),X=j.currentPointIndex?Math.max(h(j.currentPointIndex-v.index).dividedBy(1e9).toNumber(),0):1;K=K.plus(M.multipliedBy(X).plus(v.points)),q=K.shiftedBy(-1*j.coinDecimal);let J=h(1e12),ye=h(v.weightedAmount).div(h(P.debtAmount).multipliedBy(j.baseWeight).dividedBy(J)).isFinite()?h(v.weightedAmount).div(h(P.debtAmount).multipliedBy(j.baseWeight).dividedBy(J)).toNumber():1;K.isGreaterThanOrEqualTo(0)&&B.push({coinName:j.coinName,coinType:j.coinType,symbol:j.symbol,coinDecimal:j.coinDecimal,coinPrice:j.coinPrice,weightedBorrowAmount:M.toNumber(),availableClaimAmount:K.toNumber(),availableClaimCoin:q.toNumber(),boostValue:ye});}}),Object.keys(O.points).some(E=>{let v=O.points[E]?.rewardApr;return v!==1/0&&typeof v=="number"&&v>0})&&P.debtAmount>0&&w++,p[x]={coinName:O.coinName,coinType:O.coinType,symbol:O.symbol,coinDecimal:O.coinDecimal,coinPrice:O.coinPrice,rewards:B};}}let C=f.isZero()?A.isGreaterThan(0)?h(100):h(0):A.dividedBy(f);C=C.isLessThan(1)?C:h(1);let I=b.minus(k).isGreaterThan(0)?b.minus(k):h(0),_=y.minus(A).isGreaterThan(0)?y.minus(A):h(0),D=A.isGreaterThan(0)?f:h(0),ee=A.minus(D).isGreaterThan(0)?A.minus(D):h(0),U={obligationId:typeof e=="string"?e:e.objectId,totalDepositedValue:b.toNumber(),totalBorrowedValue:k.toNumber(),totalBalanceValue:I.toNumber(),totalBorrowCapacityValue:y.toNumber(),totalAvailableCollateralValue:_.toNumber(),totalBorrowedValueWithWeight:A.toNumber(),totalRequiredCollateralValue:D.toNumber(),totalUnhealthyCollateralValue:ee.toNumber(),totalRiskLevel:C.toNumber(),totalDepositedPools:m,totalBorrowedPools:g,totalRewardedPools:w,collaterals:l,debts:u,borrowIncentives:p};for(let[T,P]of Object.entries(U.collaterals)){if(!P)continue;let x=s.collaterals[T];if(x){let O=h(U.totalAvailableCollateralValue).dividedBy(x.collateralFactor).dividedBy(x.coinPrice).shiftedBy(x.coinDecimal);O=U.totalBorrowedValueWithWeight===0?h(P.depositedAmount):ie(O.multipliedBy(Se(h(U.totalAvailableCollateralValue).dividedBy(x.collateralFactor).toNumber(),3,"increase")).toNumber(),P.depositedAmount,x.depositAmount),P.availableWithdrawAmount=O.toNumber(),P.availableWithdrawCoin=O.shiftedBy(-1*P.coinDecimal).toNumber();}}for(let[T,P]of Object.entries(U.debts)){if(!P)continue;let x=s.pools[T];if(x){let O=h(P.requiredRepayAmount).multipliedBy(Se(P.borrowedValue,3,"decrease")),B=h(U.totalAvailableCollateralValue).dividedBy(x.borrowWeight).shiftedBy(x.coinDecimal).dividedBy(x.coinPrice);B=U.totalAvailableCollateralValue!==0&&h(x.maxBorrowCoin).isGreaterThan(x.borrowCoin)?ie(B.multipliedBy(Se(B.shiftedBy(-1*x.coinDecimal).multipliedBy(x.coinPrice).toNumber(),3,"increase")).toNumber(),x.supplyAmount):h(0),P.availableBorrowAmount=B.toNumber(),P.availableBorrowCoin=B.shiftedBy(-1*P.coinDecimal).toNumber(),P.requiredRepayAmount=O.toNumber(),P.requiredRepayCoin=O.shiftedBy(-1*P.coinDecimal).toNumber();}}return U},ra=async(t,e=!1)=>{let a=await t.getMarketPools(void 0,{indexer:e}),o=h(0),s=h(0),r=h(0);if(e){let i=await t.indexer.getTotalValueLocked();return {supplyValue:i.supplyValue,supplyValueChangeRatio:i.supplyValueChangeRatio,borrowValue:i.borrowValue,borrowValueChangeRatio:i.borrowValueChangeRatio,totalValue:i.totalValue,totalValueChangeRatio:i.totalValueChangeRatio,supplyLendingValue:i.supplyLendingValue,supplyLendingValueChangeRatio:i.supplyLendingValueChangeRatio,supplyCollateralValue:i.supplyCollateralValue,supplyCollateralValueChangeRatio:i.supplyCollateralValueChangeRatio}}for(let i of Object.values(a.pools))i&&(o=o.plus(h(i.supplyCoin).multipliedBy(i.coinPrice)),r=r.plus(h(i.borrowCoin).multipliedBy(i.coinPrice)));for(let i of Object.values(a.collaterals))i&&(s=s.plus(h(i.depositCoin).multipliedBy(i.coinPrice)));return {supplyValue:o.plus(s).toNumber(),supplyLendingValue:o.toNumber(),supplyCollateralValue:s.toNumber(),borrowValue:r.toNumber(),totalValue:o.plus(s).minus(r).toNumber()}},na=async(t,e,a=!1)=>{let o=await t.getAllCoinPrices({indexer:a}),s=await t.getMarketPools(void 0,{indexer:a,coinPrices:o}),[r,n,i,c]=await Promise.all([t.getLendings(void 0,e,{indexer:a,marketPools:s.pools,coinPrices:o}),t.getObligationAccounts(e,{indexer:a,market:s,coinPrices:o}),t.getBorrowIncentivePools(void 0,{marketPools:s.pools,coinPrices:o}),t.getVeScas({walletAddress:e,excludeEmpty:!0})]),d=Object.values(r).filter(f=>!!f&&f.availableWithdrawCoin>0).map(f=>({suppliedCoin:f.availableWithdrawCoin,suppliedValue:f.suppliedValue,stakedCoin:f.availableUnstakeCoin,coinName:f.coinName,symbol:f.symbol,coinType:f.coinType,coinPrice:f.coinPrice,coinDecimals:f.coinDecimal,supplyApr:f.supplyApr,supplyApy:f.supplyApy,incentiveApr:isFinite(f.rewardApr)?f.rewardApr:0})),l=Object.values(n).filter(f=>!!f&&(f.totalBorrowedValueWithWeight>0||f.totalDepositedValue>0)).map(f=>({obligationId:f.obligationId,totalDebtsInUsd:f.totalBorrowedValueWithWeight,totalCollateralInUsd:f.totalDepositedValue,riskLevel:f.totalRiskLevel,availableCollateralInUsd:f.totalAvailableCollateralValue,totalUnhealthyCollateralInUsd:f.totalUnhealthyCollateralValue,collaterals:Object.values(f.collaterals).filter(g=>!!g&&g.depositedCoin>0).map(g=>({coinName:g.coinName,symbol:g.symbol,coinDecimals:g.coinDecimal,coinType:g.coinType,coinPrice:g.coinPrice,depositedCoin:g.depositedCoin,depositedValueInUsd:g.depositedValue})),borrowedPools:Object.values(f.debts).filter(g=>!!g&&g.borrowedCoin>0).map(g=>({coinName:g.coinName,symbol:g.symbol,coinDecimals:g.coinDecimal,coinType:g.coinType,coinPrice:g.coinPrice,borrowedCoin:g.borrowedCoin,borrowedValueInUsd:g.borrowedValueWithWeight,borrowApr:s.pools[g.coinName]?.borrowApr,borrowApy:s.pools[g.coinName]?.borrowApy,incentiveInfos:Object.values(i[g.coinName]?.points??{}).filter(w=>!!w&&isFinite(w.rewardApr)).map(w=>({coinName:w.coinName,symbol:w.symbol,coinType:w.coinType,incentiveApr:w.rewardApr}))}))})),u="sui",p="SUI",m=Object.values(r).reduce((f,g)=>{if(g){if(g.availableClaimCoin===0)return f;f[u]?f[u].pendingRewardInCoin+=g.availableClaimCoin:f[u]={symbol:p,coinType:normalizeStructTag(SUI_TYPE_ARG),coinPrice:o[u]??0,pendingRewardInCoin:g.availableClaimCoin};}return f},{}),b=Object.values(n).filter(f=>!!f).reduce((f,g)=>(Object.values(g.borrowIncentives).forEach(w=>{w?.rewards.forEach(k=>{if(k.availableClaimCoin===0)return f;f[k.coinName]?f[k.coinName].pendingRewardInCoin+=k.availableClaimCoin:f[k.coinName]={symbol:k.symbol,coinType:k.coinType,coinPrice:k.coinPrice,pendingRewardInCoin:k.availableClaimCoin};});}),f),{}),y=c.map(({keyId:f,lockedScaCoin:g,currentVeScaBalance:w,unlockAt:k})=>({veScaKey:f,coinPrice:o.sca??0,lockedScaInCoin:g,lockedScaInUsd:g*(o.sca??0),currentVeScaBalance:w,remainingLockPeriodInDays:k-Date.now()>0?(k-Date.now())/864e5:0,unlockAt:k}));return {totalSupplyValue:d.reduce((f,g)=>(f+=g.suppliedValue,f),0),...l.reduce((f,g)=>(f.totalDebtValue+=g.totalDebtsInUsd,f.totalCollateralValue+=g.totalCollateralInUsd,f),{totalDebtValue:0,totalCollateralValue:0}),totalLockedScaValue:y.reduce((f,g)=>(f+=g.lockedScaInUsd,f),0),lendings:d,borrowings:l,pendingRewards:{lendings:Object.entries(m).reduce((f,[g,w])=>(f.push({...w,coinName:"sui",pendingRewardInUsd:w.coinPrice*w.pendingRewardInCoin}),f),[]),borrowIncentives:Object.entries(b).reduce((f,[g,w])=>(f.push({coinName:g,...w,pendingRewardInUsd:w.coinPrice*w.pendingRewardInCoin}),f),[])},veScas:y}};var tt=async({address:t,scallopSuiKit:e},a,o)=>{let s=t.get(`core.coins.${a}.oracle.pyth.feedObject`);if(o=o||(await e.queryGetObject(s))?.data,o){let r=o;if(r.content&&"fields"in r.content){let n=r.content.fields,i=Number(n.price_info.fields.price_feed.fields.price.fields.expo.fields.magnitude),c=Number(n.price_info.fields.price_feed.fields.price.fields.expo.fields.negative),d=Number(n.price_info.fields.price_feed.fields.price.fields.price.fields.magnitude),l=Number(n.price_info.fields.price_feed.fields.price.fields.price.fields.negative);return d*10**((c?-1:1)*i)*(l?-1:1)}}return 0},ia=async({address:t,scallopSuiKit:e},a)=>{let o=a.reduce((n,i)=>{let c=t.get(`core.coins.${i}.oracle.pyth.feedObject`);return c&&(n[c]?n[c].push(i):n[c]=[i]),n},{}),r=(await e.queryGetObjects(Object.keys(o))).reduce((n,i)=>(o[i.objectId].forEach(c=>{n[c]=i;}),n),{});return (await Promise.all(Object.entries(r).map(async([n,i])=>({coinName:n,price:await tt({address:t,scallopSuiKit:e},n,i)})))).reduce((n,i)=>(n[i.coinName]=i.price,n),{})},ca=async(t,e,a,o=!1)=>{if(a=a??(o?await t.getCoinPricesByIndexer():await t.utils.getCoinPrices()),e=e??(await t.getMarketPools(void 0,{coinPrices:a,indexer:o})).pools,!e)throw new Error("Failed to fetch market pool for getAllCoinPrices");let s={};return t.constants.whitelist.scoin.forEach(r=>{let n=t.utils.parseCoinName(r);s[r]=h(a[n]??0).multipliedBy(e[n]?.conversionRate??1).toNumber();}),{...a,...s}};var la=async({address:t,scallopSuiKit:e},a)=>{let o=t.get("referral.bindingTableId"),s=await e.queryGetDynamicFieldObject({parentId:o,name:{type:"address",value:a}});return s?.data?.content?.dataType!=="moveObject"?null:s.data.content.fields.value};var da=async({utils:t},e)=>{let a=t.address.get("scoin.id"),o=[t.getSCoinTreasury(e)],s=[t.parseSCoinType(e),t.parseUnderlyingSCoinType(e)],r=`${a}::s_coin_converter::total_supply`,i=(await t.scallopSuiKit.queryInspectTxn({queryTarget:r,args:o,typeArgs:s}))?.results;if(i&&i[0]?.returnValues){let c=Uint8Array.from(i[0].returnValues[0][0]),d=i[0].returnValues[0][1];return mo(d==="u64","Result type is not u64"),h(bcs.u64().parse(c)).shiftedBy(t.getCoinDecimal(t.parseCoinName(e))).toNumber()}return 0},ua=async({utils:t},e=[...t.constants.whitelist.scoin],a)=>{let o=a||t.suiKit.currentAddress,s={};return await Promise.allSettled(e.map(async r=>{let n=await ot({utils:t},r,o);s[r]=n;})),s},ot=async({utils:t},e,a)=>{let o=a||t.suiKit.currentAddress,s=t.parseSCoinType(e),r=await t.scallopSuiKit.queryGetCoinBalance({owner:o,coinType:s});return h(r?.totalBalance??"0").toNumber()},bo=(t,e,a)=>{if(e===a)throw new Error("fromAsset and toAsset must be different");if(!t.constants.whitelist.scoin.has(e))throw new Error("fromAsset is not supported");if(!t.constants.whitelist.scoin.has(a))throw new Error("toAsset is not supported")},pa=async(t,e,a,o)=>{bo(t.utils,e,a);let s=t.utils.parseCoinName(e),r=t.utils.parseCoinName(a),n=await Promise.all([t.getMarketPool(s),t.getMarketPool(r)]);if(n.some(u=>!u))throw new Error("Failed to fetch the lendings data");if(n.some(u=>u?.conversionRate===0))throw new Error("Conversion rate cannot be zero");let i=n[0].conversionRate,c=1/n[1].conversionRate,l=await(async()=>{let u=await t.utils.getCoinPrices();if(!u[s]||!u[r])throw new Error("Failed to fetch the coin prices");if(u[r]===0)throw new Error("Price of toCoin cannot be zero");return u[s]/u[r]})();return h(i).multipliedBy(l).multipliedBy(c).toNumber()};var fa=async(t,e)=>{let a={spool:[],spoolReward:[],sCoinTreasury:[]},o=new Map;for(let l of e){let u=t.constants.poolAddresses[l],p={spool:u?.spool,spoolReward:u?.spoolReward,sCoinTreasury:u?.sCoinTreasury};Object.entries(p).forEach(([m,b])=>{b&&a[m].push(b);}),o.set(l,p);}let[s,r,n]=await Promise.all([t.scallopSuiKit.queryGetObjects(a.spool),t.scallopSuiKit.queryGetObjects(a.spoolReward),t.scallopSuiKit.queryGetObjects(a.sCoinTreasury)]),i=l=>new Map(l.map(u=>[u.objectId,u])),c={spool:i(s),spoolReward:i(r),sCoinTreasury:i(n)},d={};for(let[l,u]of o)d[l]={spool:u.spool?c.spool.get(u.spool):void 0,spoolReward:u.spoolReward?c.spoolReward.get(u.spoolReward):void 0,sCoinTreasury:u.sCoinTreasury?c.sCoinTreasury.get(u.sCoinTreasury):void 0};return d},yo=({spool:t,spoolReward:e})=>{if(!t||!e)throw new Error("spool or spoolReward is undefined");let a=W(t),o=W(e);return {stakeType:a.stake_type,maxDistributedPoint:a.max_distributed_point,distributedPoint:a.distributed_point,distributedPointPerPeriod:a.distributed_point_per_period,pointDistributionTime:a.point_distribution_time,maxStake:a.max_stakes,stakes:a.stakes,index:a.index,createdAt:a.created_at,lastUpdate:a.last_update,...o}},ma=async(t,e=[...t.constants.whitelist.spool],a=!1,o,s)=>{let r=e.map(c=>t.utils.parseCoinName(c));if(o=o??(await t.getMarketPools(r,{indexer:a})).pools,s=s??await t.getAllCoinPrices({marketPools:o})??{},!o)throw new Error(`Fail to fetch marketPools for ${r}`);let n={};if(a){let c=await t.indexer.getSpools(),d=l=>{if(!e.includes(l.marketCoinName))return;let u=t.utils.parseCoinName(l.marketCoinName),p=t.utils.getSpoolRewardCoinName();l.coinPrice=s[u]??l.coinPrice,l.marketCoinPrice=s[l.marketCoinName]??l.marketCoinPrice,l.rewardCoinPrice=s[p]??l.rewardCoinPrice,n[l.marketCoinName]=l;};return Object.values(c).filter(l=>!!l).forEach(d),n}let i=await fa(t,r);return await Promise.allSettled(e.map(async(c,d)=>{try{let l=r[d],u=await go(t,c,a,s,i[l]);u&&(n[c]=u);}catch(l){console.error(l);}})),n},go=async(t,e,a=!1,o,s)=>{let r=t.utils.parseCoinName(e);if(o=o||await t.getAllCoinPrices(),a){let f=await t.indexer.getSpool(e),g=t.utils.parseCoinName(e),w=t.utils.getSpoolRewardCoinName();return f.coinPrice=o?.[g]??f.coinPrice,f.marketCoinPrice=o?.[e]??f.marketCoinPrice,f.rewardCoinPrice=o?.[w]??f.rewardCoinPrice,f}s??=(await fa(t,[r]))[r];let n=t.utils.getSpoolRewardCoinName();o=o||await t.utils.getCoinPrices();let i=yo(s),c=vt(i),d=o?.[e]??0,l=t.utils.getCoinDecimal(e),u=jt(c,d,l),p=Nt(i),m=o?.[n]??0,b=t.utils.getCoinDecimal(n),y=_t(c,p,u,m,b);return {marketCoinName:e,symbol:t.utils.parseSymbol(e),coinType:t.utils.parseCoinType(r),marketCoinType:t.utils.parseMarketCoinType(r),rewardCoinType:t.utils.isMarketCoin(n)?t.utils.parseMarketCoinType(n):t.utils.parseCoinType(n),sCoinType:t.utils.parseSCoinType(e)??"",coinDecimal:t.utils.getCoinDecimal(r),rewardCoinDecimal:t.utils.getCoinDecimal(n),coinPrice:o?.[r]??0,marketCoinPrice:d,rewardCoinPrice:m,maxPoint:c.maxPoint,distributedPoint:c.distributedPoint,maxStake:c.maxStake,...u,exchangeRateNumerator:p.exchangeRateNumerator,exchangeRateDenominator:p.exchangeRateDenominator,...y}},de=async({utils:t},e)=>{let a=e||t.suiKit.currentAddress,o=t.address.get("spool.object"),s=`${o}::spool_account::SpoolAccount`,r=[],n=!1,i=null;do{let u=await t.scallopSuiKit.queryGetOwnedObjects({owner:a,filter:{StructType:s},options:{showContent:!0,showType:!0},cursor:i,limit:10});u&&(r.push(...u.data),u.hasNextPage&&u.nextCursor?(n=!0,i=u.nextCursor):n=!1);}while(n);let c=[...t.constants.whitelist.spool].reduce((u,p)=>(u[p]=[],u),{}),d=Object.keys(c).reduce((u,p)=>{let m=t.parseCoinName(p),b=t.parseMarketCoinType(m);return u[p]=`${o}::spool_account::SpoolAccount<${b}>`,u},{}),l=Object.entries(d).reduce((u,[p,m])=>(u[m]=p,u),{});for(let u of r.map(p=>p.data)){let p=u?.objectId,m=u?.type;if(p&&u?.content&&"fields"in u.content){let b=u.content.fields,y=String(b.spool_id),f=String(b.stake_type.fields.name),g=Number(b.stakes),w=Number(b.index),k=Number(b.points),A=Number(b.total_points),F={sweth:c.sweth,ssui:c.ssui,swusdc:c.swusdc,swusdt:c.swusdt,scetus:c.scetus,safsui:c.safsui,shasui:c.shasui,svsui:c.svsui,susdc:c.susdc},C=normalizeStructTag$1(m),I=F[l[C]];I&&I.push({id:p,type:C,stakePoolId:y,stakeType:normalizeStructTag$1(f),staked:g,index:w,points:k,totalPoints:A});}}return c},st=async({utils:t},e)=>{let a=t.address.get(`spool.pools.${e}.id`),o,s=await t.scallopSuiKit.queryGetObject(a);if(s?.data){let r=s.data,n=r.objectId,i=r.type;if(r.content&&"fields"in r.content){let c=r.content.fields,d=Number(c.max_distributed_point),l=Number(c.distributed_point),u=Number(c.distributed_point_per_period),p=Number(c.point_distribution_time),m=Number(c.max_stakes),b=String(c.stake_type.fields.name),y=Number(c.stakes),f=Number(c.index),g=Number(c.created_at),w=Number(c.last_update);o={id:n,type:normalizeStructTag$1(i),maxPoint:d,distributedPoint:l,pointPerPeriod:u,period:p,maxStake:m,stakeType:normalizeStructTag$1(b),totalStaked:y,index:f,createdAt:g,lastUpdate:w};}}return o},rt=async({utils:t},e)=>{let a=t.address.get(`spool.pools.${e}.rewardPoolId`),o,s=await t.scallopSuiKit.queryGetObject(a);if(s?.data){let r=s.data,n=r.objectId,i=r.type;if(r.content&&"fields"in r.content){let c=r.content.fields,d=String(c.spool_id),l=Number(c.exchange_rate_numerator),u=Number(c.exchange_rate_denominator),p=Number(c.rewards),m=Number(c.claimed_rewards);o={id:n,type:normalizeStructTag$1(i),stakePoolId:d,ratioNumerator:l,ratioDenominator:u,rewards:p,claimedRewards:m};}}return o};var ko=async(t,e)=>{let a=e||t.suiKit.currentAddress,s=`${t.address.get("vesca.object")}::ve_sca::VeScaKey`,r=[],n=!1,i=null;do{let d=await t.scallopSuiKit.queryGetOwnedObjects({owner:a,filter:{StructType:s},cursor:i,limit:10});d&&(r.push(...d.data),d&&d.hasNextPage&&d.nextCursor?(n=!0,i=d.nextCursor):n=!1);}while(n);return r.map(d=>d.data).filter(d=>!!d)},Oe=async({utils:t},e,a)=>{let o=await ko(t,e),s=Array(o.length).fill(null),r=o.map(async(i,c)=>{let d=await ae(t,i);d&&(s[c]=d);});await Promise.allSettled(r);let n=s.filter(Boolean).sort((i,c)=>c.currentVeScaBalance-i.currentVeScaBalance);return a?n.filter(i=>i.lockedScaAmount!=="0"):n},ba=z.object({objectId:z.string(),digest:z.string(),version:z.string()}),ae=async(t,e)=>{let a=t.address.get("vesca.tableId");if(!e)return;typeof e=="object"&&(e=ba.parse(e));let o,s=await t.scallopSuiKit.queryGetDynamicFieldObject({parentId:a,name:{type:"0x2::object::ID",value:typeof e=="string"?e:e.objectId}});if(!s)return;let r=s.data;if(r&&r.content&&r.content.dataType==="moveObject"&&"fields"in r.content){let n=r.content.fields.value.fields,i=Math.max(+n.unlock_at*1e3-Date.now(),0),c=String(n.locked_sca_amount),d=h(n.locked_sca_amount).shiftedBy(-9).toNumber(),l=d*(Math.floor(i/1e3)/126144e3);o={id:r.objectId,keyId:typeof e=="string"?e:e.objectId,keyObject:typeof e=="string"?void 0:e,object:ba.parse(s.data),lockedScaAmount:c,lockedScaCoin:d,currentVeScaBalance:l,unlockAt:h(n.unlock_at*1e3).toNumber()};}return o},To=async(t,e)=>{let a=t.address.get("vesca.id"),o=t.address.get("vesca.config");e=e??t.address.get("vesca.treasury");let s=new SuiTxBlock,r=s.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID$1,mutable:!1,initialSharedVersion:"1"}),n=`${a}::treasury::refresh`,i=[o,e,r],c=`${a}::treasury::total_ve_sca_amount`,d=[e,r],l=await Promise.all(i.map(async y=>typeof y=="string"?(await t.scallopSuiKit.queryGetObject(y))?.data:y)),u=await Promise.all(d.map(async y=>typeof y=="string"?(await t.scallopSuiKit.queryGetObject(y))?.data:y));s.moveCall(n,l),s.moveCall(c,u);let p=await s.txBlock.build({client:t.suiKit.client,onlyTransactionKind:!0}),b=(await t.scallopSuiKit.queryClient.fetchQuery({queryKey:N.rpc.getTotalVeScaTreasuryAmount({refreshArgs:i,vescaAmountArgs:d,node:t.scallopSuiKit.currentFullNode}),queryFn:async()=>await t.suiKit.inspectTxn(p)})).results;if(b&&b[1]?.returnValues){let y=Uint8Array.from(b[1].returnValues[0][0]),f=b[1].returnValues[0][1];return mo(f==="u64","Result type is not u64"),bcs.u64().parse(y)}return "0"},ya=async t=>{let e=t.address.get("vesca.treasury"),a=await t.scallopSuiKit.queryGetObject(e);if(!a||a.data?.content?.dataType!=="moveObject")return null;let o=a.data.content.fields,s=h(o.unlock_schedule.fields.locked_sca_amount).shiftedBy(-9).toNumber(),r=h(await To(t,a.data)??0).shiftedBy(-9).toNumber(),n=s>0?r/s*4:0;return {totalLockedSca:s,totalVeSca:r,averageLockingPeriod:n,averageLockingPeriodUnit:"year"}};var xo=[getFullnodeUrl("mainnet"),"https://sui-mainnet.public.blastapi.io","https://sui-mainnet-ca-2.cosmostation.io","https://sui-mainnet-eu-4.cosmostation.io","https://sui-mainnet-endpoint.blockvision.org","https://sui-rpc.publicnode.com","https://sui-mainnet-rpc.allthatnode.com","https://mainnet.suiet.app","https://mainnet.sui.rpcpool.com","https://sui1mainnet-rpc.chainode.tech","https://fullnode.mainnet.apis.scallop.io","https://sui-mainnet-us-2.cosmostation.io"],Re=async t=>{for(let e of xo)try{return await t(new SuiClient({url:e}))}catch(a){if(a.status!==429)throw a;await new Promise(o=>setTimeout(o,500));}throw new Error("Failed to fetch data")},Oo=async(t,e,a="0x00481a93b819d744a7d79ecdc6c62c74f2f7cb4779316c4df640415817ac61bb")=>{let o=null,s=!1,r={};do{let n=await t.getDynamicFields({parentId:a,limit:10,cursor:o});if(!n)break;let{data:i,hasNextPage:c,nextCursor:d}=n;i.forEach(l=>{let u=`0x${l.name.value.name}`;e.has(u)&&(r[u]=l.objectId);}),s=c,o=d;}while(s);return r},Y=async(t,e,a,o=!0)=>{let s=(await Re(async r=>await r.getDynamicFieldObject({parentId:t,name:{type:e,value:a}}))).data;return o?s?.objectId:s?.content},ga=async(t,e=[])=>{let a=new Set(e),o={},r=(await fetch(`https://sui.apis.scallop.io/addresses/${t}`).then(C=>C.json())).mainnet;if(!r)throw new Error("Failed to fetch addresses");let n=Object.keys(r.core.coins);if(n.length===0)throw new Error("Pools empty");let i=n.reduce((C,I)=>{if(a.size>0&&!a.has(I))return C;let _=r.core.coins[I];return _&&_.coinType&&C.push([I,_.coinType]),C},[]);if(i.length===0)throw new Error("No coinTypesPairs");let c=r.core.market,d=(await Re(async C=>await C.getObject({id:c,options:{showContent:!0}}))).data;if(!(d&&d.content?.dataType==="moveObject"))throw new Error("Failed to fetch marketObject");let l=d.content.fields,u=l.vault.fields.balance_sheets.fields.table.fields.id.id,p=l.collateral_stats.fields.table.fields.id.id,m=l.borrow_dynamics.fields.table.fields.id.id,b=l.interest_models.fields.table.fields.id.id,y=l.risk_models.fields.table.fields.id.id,f="0x1::type_name::TypeName",g="0xc38f849e81cfe46d4e4320f508ea7dda42934a329d5a6571bb4c3cb6ea63f5da::market_dynamic_keys::BorrowFeeKey",w="0x6e641f0dca8aedab3101d047e96439178f16301bf0b57fe8745086ff1195eb3e::market_dynamic_keys::SupplyLimitKey",k="0xe7dbb371a9595631f7964b7ece42255ad0e738cc85fe6da26c7221b220f01af6::market_dynamic_keys::BorrowLimitKey",A="0xe7dbb371a9595631f7964b7ece42255ad0e738cc85fe6da26c7221b220f01af6::market_dynamic_keys::IsolatedAssetKey",F=await Re(async C=>await Oo(C,new Set(i.map(([,I])=>I))));return await Promise.all(i.map(async([C,I])=>{let _=I.slice(2),D=await Promise.all([Y(u,f,{name:_},!0),Y(p,f,{name:_},!0),Y(m,f,{name:_},!0),Y(b,f,{name:_},!0),Y(y,f,{name:_},!0),Y(c,g,_,!0),Y(c,w,_,!0),Y(c,k,_,!0),Y(c,A,_,!1)]),{symbol:ee,metaData:U}=r.core.coins[C],T={spool:"",spoolReward:""},P=r.spool.pools[`s${C}`];if(P){let{id:M,rewardPoolId:Q}=P;T={spool:M,spoolReward:Q};}let x={sCoinType:"",sCoinTreasury:"",sCoinMetadataId:"",sCoinSymbol:""},O=`s${C}`,B=r.scoin.coins[O];if(B){let{coinType:M,treasury:Q,metaData:X,symbol:J}=B;x={sCoinType:M,sCoinTreasury:Q,sCoinMetadataId:X,sCoinSymbol:J};}let E={pythFeed:"",pythFeedObjectId:""};if(r.core.coins[C]?.oracle.pyth){let{feed:M,feedObject:Q}=r.core.coins[C].oracle.pyth;E={pythFeed:M,pythFeedObjectId:Q};}r.core.coins[C].oracle.pyth;let K=(await Re(async M=>await M.getCoinMetadata({coinType:I})))?.decimals??0,q=T?`s${C}`:void 0;o[C]={coinName:C,symbol:ee,lendingPoolAddress:D[0]??"",collateralPoolAddress:D[1]??"",borrowDynamic:D[2]??"",interestModel:D[3]??"",riskModel:D[4],borrowFeeKey:D[5]??"",supplyLimitKey:D[6]??"",borrowLimitKey:D[7]??"",isolatedAssetKey:D[8]?.fields?.id.id??"",isIsolated:D[8]?.fields?.value??!1,...T,...x,sCoinName:O,coinMetadataId:U,coinType:I,spoolName:q,decimals:K,...E,flashloanFeeObject:F[I]??""},await new Promise(M=>setTimeout(M,1e3));})),o};var ha=async(t,e,a=t.address.get("core.oracles.switchboard.registryTableId"))=>{let o=[],s=e.map((i,c)=>{let d=t.utils.address.get(`core.coins.${i}.oracle.switchboard`);return d||(o.push({idx:c,coinName:i}),null)});if(o.length===0)return s;let n=o.map(i=>i.coinName).map(i=>{let c=t.utils.parseCoinType(i);if(!c)throw new Error(`Invalid coin name: ${i}`);return c});return await Promise.all(n.map(async(i,c)=>{let d={type:"0x1::type_name::TypeName",value:{name:i.slice(2)}},l=await t.scallopSuiKit.queryGetDynamicFieldObject({parentId:a,name:d});if(!l?.data?.content||l.data.content.dataType!=="moveObject")throw new Error(`No on-demand aggregator found for ${i}`);let u=l.data.content;s[c]=u.fields.value;})),s};var wa=async({address:t,scallopSuiKit:e})=>{let a=`${t.get("core.packages.xOracle.object")}::price_update_policy::PriceUpdatePolicyRulesKey`,[o,s]=await Promise.all([e.queryGetDynamicFieldObject({parentId:t.get("core.oracles.primaryPriceUpdatePolicyObject"),name:{type:a,value:{dummy_field:!1}}}),e.queryGetDynamicFieldObject({parentId:t.get("core.oracles.secondaryPriceUpdatePolicyObject"),name:{type:a,value:{dummy_field:!1}}})]);return {primary:o,secondary:s}},nt=async(t,e)=>{if(e==="primary"&&!t.address.get("core.oracles.primaryPriceUpdatePolicyVecsetId"))return console.error("Primary price update policy vecset id is not set"),null;if(e==="secondary"&&!t.address.get("core.oracles.secondaryPriceUpdatePolicyVecsetId"))return console.error("Secondary price update policy vecset id is not set"),null;let a={[`${t.address.get("core.packages.pyth.object")}::rule::Rule`]:"pyth",[`${t.address.get("core.packages.supra.object")}::rule::Rule`]:"supra",[`${t.address.get("core.packages.switchboard.object")}::rule::Rule`]:"switchboard"},o={},s=null;do{let r=await t.scallopSuiKit.queryGetDynamicFields({parentId:e==="primary"?t.address.get("core.oracles.primaryPriceUpdatePolicyVecsetId"):t.address.get("core.oracles.secondaryPriceUpdatePolicyVecsetId"),cursor:s,limit:10});if(!r)break;let{data:n,hasNextPage:i,nextCursor:c}=r;s=c;let d=n.map(u=>u.objectId);if((await t.scallopSuiKit.queryGetObjects(d)).forEach(u=>{if(!u.content||u.content.dataType!=="moveObject")return;let p=u.content.fields,m=p.name.fields.name,b=t.parseCoinNameFromType(`0x${m}`);if(!b)throw new Error(`Invalid asset name: ${b}`);o[b]||(o[b]=[]),p.value.fields.contents.forEach(f=>{o[b].push(a[`0x${f.fields.name}`]);});}),!i)break}while(s);return o};var it=class extends SuiPythClient{constructor(a,o,s,r){super(a,o,s);this.params=r;}async updatePriceFeedsWithSponsoredBaseUpdateFee(a,o,s){if(!this.params)throw new Error("Please provide params");let{defaultPackageId:r,gasStationId:n}=this.params,i=await this.getPythPackageId(),c=await this.verifyVaasAndGetHotPotato(a,o,i),d=[];for(let u of s){let p=await this.getPriceFeedObjectId(u);if(!p)throw new Error(`Price feed object not found for ID: ${u}`);d.push(p);}let l=a.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID$1,mutable:!1,initialSharedVersion:"1"});for(let u=0;u<d.length;u++){let p=d[u];[c]=a.moveCall({target:`${r}::pyth_sponsor::update_single_price_feed_with_sponsor`,arguments:[a.object(this.pythStateId),c,a.object(p),a.object(n),l]});}a.moveCall({target:`${i}::hot_potato_vector::destroy`,arguments:[c],typeArguments:[`${i}::price_info::PriceInfo`]});}},Sa=async(t,e,a,o=!1)=>{let s=new it(t.suiKit.client,t.address.get("core.oracles.pyth.state"),t.address.get("core.oracles.pyth.wormholeState"),{defaultPackageId:"0xa6f9bec2f9748656b6af8aafb5d7bc1a0d5faf25ac9645fc7f447822cd509325",gasStationId:"0xa8b8dcc9880166edb57b53e05f8df7364d31b5d9b7d107fd27f0b69cf338b687"}),r=e.map(i=>t.address.get(`core.coins.${i}.oracle.pyth.feed`)),n=t.utils.pythEndpoints??[...t.constants.whitelist.pythEndpoints];for(let i of n)try{let d=await new SuiPriceServiceConnection(i).getPriceFeedsUpdateData(r);o?await s.updatePriceFeedsWithSponsoredBaseUpdateFee(a.txBlock,d,r):await s.updatePriceFeeds(a.txBlock,d,r);return}catch(c){console.warn(`Failed to update price feeds with endpoint ${i}: ${c}`);}};var ue=async(t,e,a=[...t.constants.whitelist.lending],o)=>{let s=o?.usePythPullModel??t.usePythPullModel,r=o?.useOnChainXOracleList??t.useOnChainXOracleList,n=new Set(o?.sponsoredFeeds??t.sponsoredFeeds),i=o?.isSponsoredTx??!1;n.forEach(m=>{if(!t.constants.whitelist.lending.has(m))throw new Error(`${m} is not valid feed`)});let c=r?await t.query.getAssetOracles():xt,d=new Set(Object.values(c).flatMap(({primary:m,secondary:b})=>[...m,...b])),l=(m,b)=>{let y=c[m];return y&&(y.primary.includes(b)||y.secondary.includes(b))},u=[...new Set(a)],p=u.filter(m=>l(m,"pyth"));if(d.has("pyth")){let m=[];for(let b of p){let y=!s&&!n.has(b);(s||y)&&m.push(b);}m.length>0&&await Sa(t,m,e,i);}for(let m of u)jo(t,e,m,c[m]);},jo=(t,e,a,o)=>{let s=t.utils.parseCoinType(a);No(e,o,t.address.get("core.packages.xOracle.id"),t.address.get("core.oracles.xOracle"),t.address.get("core.packages.pyth.id"),t.address.get("core.oracles.pyth.registry"),t.address.get("core.oracles.pyth.state"),t.address.get(`core.coins.${a}.oracle.pyth.feedObject`),t.address.get("core.packages.switchboard.id"),t.address.get("core.oracles.switchboard.registry"),t.address.get(`core.coins.${a}.oracle.switchboard`),t.address.get("core.packages.supra.id"),t.address.get("core.oracles.supra.registry"),t.address.get("core.oracles.supra.holder"),s);},No=(t,e,a,o,s,r,n,i,c,d,l,u,p,m,b)=>{let y=_o(t,a,o,b);return Object.entries(e).forEach(([f,g])=>{g.includes("pyth")&&Fo(f,t,s,y,n,i,r,b),g.includes("supra")&&Mo(f,t,u,y,m,p,b),g.includes("switchboard")&&Do(f,t,c,y,l,d,b);}),Bo(t,a,o,y,b),t},_o=(t,e,a,o)=>{let s=`${e}::x_oracle::price_update_request`,r=[o];return t.moveCall(s,[a],r)},Bo=(t,e,a,o,s)=>{let r=`${e}::x_oracle::confirm_price_update_request`,n=[s];return t.moveCall(r,[a,o,t.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID,mutable:!1,initialSharedVersion:"1"})],n),t},Mo=(t,e,a,o,s,r,n)=>{e.moveCall(`${a}::rule::set_price_as_${t}`,[o,s,r,e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID,initialSharedVersion:"1",mutable:!1})],[n]);},Do=(t,e,a,o,s,r,n)=>{e.moveCall(`${a}::rule::set_as_${t}_price`,[o,s,r,e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID,initialSharedVersion:"1",mutable:!1})],[n]);},Fo=(t,e,a,o,s,r,n,i)=>{e.moveCall(`${a}::rule::set_price_as_${t}`,[o,s,r,n,e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID,initialSharedVersion:"1",mutable:!1})],[i]);};var pe=async(...t)=>{let[e,a,o,s]=t;if(t.length===3&&o)return {obligationId:o};if(t.length===4&&o&&s)return {obligationId:o,obligationKey:s};let r=R(a),n=await se(e,r);if(n.length===0)throw new Error(`No obligation found for sender ${r}`);return {obligationId:n[0].id,obligationKey:n[0].keyId}},Vo=({builder:t,txBlock:e})=>{let a={protocolPkg:t.address.get("core.packages.protocol.id"),market:t.address.get("core.market"),version:t.address.get("core.version"),coinDecimalsRegistry:t.address.get("core.coinDecimalsRegistry"),xOracle:t.address.get("core.oracles.xOracle")},s=`${t.address.get("referral.id")}::scallop_referral_program::REFERRAL_WITNESS`,r=e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID,mutable:!1,initialSharedVersion:"1"});return {openObligation:()=>{let[n,i,c]=t.moveCall(e,`${a.protocolPkg}::open_obligation::open_obligation`,[a.version]);return [n,i,c]},returnObligation:(n,i)=>{t.moveCall(e,`${a.protocolPkg}::open_obligation::return_obligation`,[a.version,n,i]);},openObligationEntry:()=>{t.moveCall(e,`${a.protocolPkg}::open_obligation::open_obligation_entry`,[a.version]);},addCollateral:(n,i,c)=>{let d=t.utils.parseCoinType(c);t.moveCall(e,`${a.protocolPkg}::deposit_collateral::deposit_collateral`,[a.version,n,a.market,i],[d]);},takeCollateral:(n,i,c,d)=>{let l=t.utils.parseCoinType(d);return t.moveCall(e,`${a.protocolPkg}::withdraw_collateral::withdraw_collateral`,[a.version,n,i,a.market,a.coinDecimalsRegistry,e.pure.u64(c),a.xOracle,r],[l])},deposit:(n,i)=>{let c=t.utils.parseCoinType(i);return t.moveCall(e,`${a.protocolPkg}::mint::mint`,[a.version,a.market,n,r],[c])},depositEntry:(n,i)=>{let c=t.utils.parseCoinType(i);return t.moveCall(e,`${a.protocolPkg}::mint::mint_entry`,[a.version,a.market,n,r],[c])},withdraw:(n,i)=>{let c=t.utils.parseCoinType(i);return t.moveCall(e,`${a.protocolPkg}::redeem::redeem`,[a.version,a.market,n,r],[c])},withdrawEntry:(n,i)=>{let c=t.utils.parseCoinType(i);return t.moveCall(e,`${a.protocolPkg}::redeem::redeem_entry`,[a.version,a.market,n,r],[c])},borrow:(n,i,c,d)=>{let l=t.utils.parseCoinType(d);return t.moveCall(e,`${a.protocolPkg}::borrow::borrow`,[a.version,n,i,a.market,a.coinDecimalsRegistry,c,a.xOracle,r],[l])},borrowWithReferral:(n,i,c,d,l)=>{let u=t.utils.parseCoinType(l);return t.moveCall(e,`${a.protocolPkg}::borrow::borrow_with_referral`,[a.version,n,i,a.market,a.coinDecimalsRegistry,c,typeof d=="number"?e.pure.u64(d):d,a.xOracle,r],[u,s])},borrowEntry:(n,i,c,d)=>{let l=t.utils.parseCoinType(d);return t.moveCall(e,`${a.protocolPkg}::borrow::borrow_entry`,[a.version,n,i,a.market,a.coinDecimalsRegistry,e.pure.u64(c),a.xOracle,r],[l])},repay:(n,i,c)=>{let d=t.utils.parseCoinType(c);t.moveCall(e,`${a.protocolPkg}::repay::repay`,[a.version,n,a.market,i,r],[d]);},borrowFlashLoan:(n,i)=>{let c=t.utils.parseCoinType(i);return t.moveCall(e,`${a.protocolPkg}::flash_loan::borrow_flash_loan`,[a.version,a.market,n],[c])},repayFlashLoan:(n,i,c)=>{let d=t.utils.parseCoinType(c);t.moveCall(e,`${a.protocolPkg}::flash_loan::repay_flash_loan`,[a.version,a.market,n,i],[d]);}}},Eo=({builder:t,txBlock:e})=>({addCollateralQuick:async(a,o,s,r=!1)=>{let n=R(e),{obligationId:i}=await pe(t,e,s),{takeCoin:c,leftCoin:d}=await t.selectCoin(e,o,a,n,r);d&&e.transferObjects([d],n),e.addCollateral(i,c,o);},takeCollateralQuick:async(a,o,s,r,n)=>{let i=await pe(t,e,s,r),c=await t.utils.getObligationCoinNames(i.obligationId);return await ue(t,e,c,n),e.takeCollateral(i.obligationId,i.obligationKey,a,o)},depositQuick:async(a,o,s=!0,r=!1)=>{let n=R(e),{leftCoin:i,takeCoin:c}=await t.selectCoin(e,o,a,n,r);i&&e.transferObjects([i],n);let d=e.deposit(c,o);return s?e.mintSCoin(t.utils.parseMarketCoinName(o),d):d},withdrawQuick:async(a,o)=>{let s=R(e),r=t.utils.parseSCoinName(o);if(!r)throw new Error(`No sCoin for ${o}`);let{sCoin:n,marketCoin:i}=await t.selectSCoinOrMarketCoin(e,r,a,s);if(n){let c=e.burnSCoin(r,n);i?e.mergeCoins(i,[c]):i=c;}if(!i)throw new Error(`No market coin for ${o}`);return e.withdraw(i,o)},borrowQuick:async(a,o,s,r,n)=>{let i=await pe(t,e,s,r),d=[...await t.utils.getObligationCoinNames(i.obligationId)??[],o];return await ue(t,e,d,n),e.borrow(i.obligationId,i.obligationKey,a,o)},borrowWithReferralQuick:async(a,o,s,r,n,i)=>{let c=await pe(t,e,r,n),l=[...await t.utils.getObligationCoinNames(c.obligationId)??[],o];return await ue(t,e,l,i),e.borrowWithReferral(c.obligationId,c.obligationKey,s,a,o)},repayQuick:async(a,o,s,r=!1)=>{let n=R(e),i=await pe(t,e,s),{leftCoin:c,takeCoin:d}=await t.selectCoin(e,o,a,n,r);return c&&e.transferObjects([c],n),e.repay(i.obligationId,d,o)},updateAssetPricesQuick:async(a,o)=>await ue(t,e,a,o)}),ka=(t,e)=>{let a=e instanceof Transaction?new SuiTxBlock(e):e||new SuiTxBlock,o=Vo({builder:t,txBlock:a}),s=new Proxy(a,{get:(n,i)=>i in o?Reflect.get(o,i):Reflect.get(n,i)}),r=Eo({builder:t,txBlock:s});return new Proxy(s,{get:(n,i)=>i in r?Reflect.get(r,i):Reflect.get(n,i)})};var Aa=async(...t)=>{let[e,a,o,s]=t;if(t.length===4&&s)return [s];let r=R(a),n=await de(e,r);if(n[o].length===0)throw new Error(`No stake account id found for sender ${r}`);return n[o].map(i=>i.id)},Qo=async(...t)=>{let[e,a,o,s]=t,r=R(a),n=await de(e,r);if(n[o].length===0)throw new Error(`No stake account found for sender ${r}`);return s?n[o].filter(c=>c.id===s):n[o]},Pa=async(t,e,a,o,s,r,n=!1)=>{try{let{takeCoin:i,leftCoin:c,totalAmount:d}=n?await t.selectSCoin(e,o,s,r):await t.selectMarketCoin(e,o,s,r);if(n){let l=e.burnSCoin(o,i);e.stake(a,l,o);}else e.stake(a,i,o);return e.transferObjects([c],r),d}catch{return 0}},$o=({builder:t,txBlock:e})=>{let a={spoolPkg:t.address.get("spool.id")},o=e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID,mutable:!1,initialSharedVersion:"1"});return {createStakeAccount:s=>{let r=t.utils.parseMarketCoinType(s),n=t.address.get(`spool.pools.${s}.id`);return t.moveCall(e,`${a.spoolPkg}::user::new_spool_account`,[n,o],[r])},stake:(s,r,n)=>{let i=t.utils.parseMarketCoinType(n),c=t.address.get(`spool.pools.${n}.id`);t.moveCall(e,`${a.spoolPkg}::user::stake`,[c,s,r,o],[i]);},unstake:(s,r,n)=>{let i=t.utils.parseMarketCoinType(n),c=t.address.get(`spool.pools.${n}.id`);return t.moveCall(e,`${a.spoolPkg}::user::unstake`,[c,s,r,o],[i])},claim:(s,r)=>{let n=t.address.get(`spool.pools.${r}.id`),i=t.address.get(`spool.pools.${r}.rewardPoolId`),c=t.utils.parseMarketCoinType(r),d=t.utils.getSpoolRewardCoinName(),l=t.utils.parseCoinType(d);return t.moveCall(e,`${a.spoolPkg}::user::redeem_rewards`,[n,i,s,o],[c,l])}}},Wo=({builder:t,txBlock:e})=>({stakeQuick:async(a,o,s)=>{let r=R(e),n=await Aa(t,e,o,s);if(n.length===0)throw new Error(`No stakeAccountIds found for user ${r}`);if(typeof a=="number"){let i=await Pa(t,e,n[0],o,a,r);a-=i,a>0&&await Pa(t,e,n[0],o,a,r,!0);}else e.stake(n[0],a,o);},unstakeQuick:async(a,o,s,r=!0)=>{let n=await Qo(t,e,o,s),i=[];for(let c of n){if(c.staked===0)continue;let d=Math.min(a,c.staked),l=await e.unstake(c.id,d,o);if(r){let u=await e.mintSCoin(o,l);i.push(u);}else i.push(l);if(a-=d,a<=0)break}if(i.length>0){let c=i[0];return i.length>1&&e.mergeCoins(c,i.slice(1)),c}},claimQuick:async(a,o)=>{let s=await Aa(t,e,a,o),r=[];for(let n of s){let i=await e.claim(n,a);r.push(i);}return r}}),xa=(t,e)=>{let a=e instanceof Transaction?new SuiTxBlock(e):e||new SuiTxBlock,o=$o({builder:t,txBlock:a}),s=new Proxy(a,{get:(n,i)=>i in o?Reflect.get(o,i):Reflect.get(n,i)}),r=Wo({builder:t,txBlock:s});return new Proxy(s,{get:(n,i)=>i in r?Reflect.get(r,i):Reflect.get(n,i)})};var ve=async(...t)=>{let[e,a,o,s]=t;if(t.length===4&&o&&s&&typeof o=="string"){let c=await Xe(e,o);return {obligationId:o,obligationKey:s,obligationLocked:c}}let r=R(a),n=await se(e,r);if(n.length===0)throw new Error(`No obligation found for sender ${r}`);let i=n.find(c=>c.id===o||c.keyId===s);if(!i)throw new Error(`No obligation found for sender ${r} with id ${o} or key ${s}`);return {obligationId:i.id,obligationKey:i.keyId,obligationLocked:i.locked}},Ho=({builder:t,txBlock:e})=>{let a={borrowIncentivePkg:t.address.get("borrowIncentive.id"),query:t.address.get("borrowIncentive.query"),config:t.address.get("borrowIncentive.config"),incentivePools:t.address.get("borrowIncentive.incentivePools"),incentiveAccounts:t.address.get("borrowIncentive.incentiveAccounts"),obligationAccessStore:t.address.get("core.obligationAccessStore")},o={table:t.address.get("vesca.table"),treasury:t.address.get("vesca.treasury"),config:t.address.get("vesca.config")},s=e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID$1,mutable:!1,initialSharedVersion:"1"});return {stakeObligation:(r,n)=>{t.moveCall(e,`${a.borrowIncentivePkg}::user::stake`,[a.config,a.incentivePools,a.incentiveAccounts,n,r,a.obligationAccessStore,s]);},stakeObligationWithVesca:(r,n,i)=>{t.moveCall(e,`${a.borrowIncentivePkg}::user::stake_with_ve_sca_v2`,[a.config,a.incentivePools,a.incentiveAccounts,n,r,a.obligationAccessStore,o.config,o.treasury,o.table,i,t.address.get("vesca.subsTable"),t.address.get("vesca.subsWhitelist"),s],[]);},unstakeObligation:(r,n)=>{t.moveCall(e,`${a.borrowIncentivePkg}::user::unstake_v2`,[a.config,a.incentivePools,a.incentiveAccounts,n,r,t.address.get("vesca.subsTable"),t.address.get("vesca.subsWhitelist"),s]);},claimBorrowIncentive:(r,n,i)=>{let c=t.utils.parseCoinType(i);return t.moveCall(e,`${a.borrowIncentivePkg}::user::redeem_rewards`,[a.config,a.incentivePools,a.incentiveAccounts,n,r,s],[c])},deactivateBoost:(r,n)=>{t.moveCall(e,`${a.borrowIncentivePkg}::user::deactivate_boost_v2`,[a.config,a.incentivePools,a.incentiveAccounts,r,n,t.address.get("vesca.subsTable"),t.address.get("vesca.subsWhitelist"),s]);}}},Xo=({builder:t,txBlock:e})=>({stakeObligationQuick:async(a,o)=>{let{obligationId:s,obligationKey:r,obligationLocked:n}=await ve(t,e,a,o),i=!!e.txBlock.blockData.transactions.find(c=>c.kind==="MoveCall"&&(c.target===`${Ee}::user::unstake`||c.target===`${t.address.get("borrowIncentive.id")}::user::unstake_v2`||c.target===`${t.address.get("borrowIncentive.id")}::user::unstake`));(!n||i)&&e.stakeObligation(s,r);},stakeObligationWithVeScaQuick:async(a,o,s)=>{let{obligationId:r,obligationKey:n,obligationLocked:i}=await ve(t,e,a,o),c=!!e.txBlock.blockData.transactions.find(d=>d.kind==="MoveCall"&&(d.target===`${Ee}::user::unstake`||d.target===`${t.address.get("borrowIncentive.id")}::user::unstake_v2`||d.target===`${t.address.get("borrowIncentive.id")}::user::unstake`));if(!i||c){let l=await t.query.getBindedVeScaKey(r)??s;l?e.stakeObligationWithVesca(r,n,l):e.stakeObligation(r,n);}},unstakeObligationQuick:async(a,o)=>{let{obligationId:s,obligationKey:r,obligationLocked:n}=await ve(t,e,a,o);n&&e.unstakeObligation(s,r);},claimBorrowIncentiveQuick:async(a,o,s)=>{let{obligationId:r,obligationKey:n}=await ve(t,e,o,s);return e.claimBorrowIncentive(r,n,a)}}),Ra=(t,e)=>{let a=e instanceof Transaction?new SuiTxBlock(e):e||new SuiTxBlock,o=Ho({builder:t,txBlock:a}),s=new Proxy(a,{get:(n,i)=>i in o?Reflect.get(o,i):Reflect.get(n,i)}),r=Xo({builder:t,txBlock:s});return new Proxy(s,{get:(n,i)=>i in r?Reflect.get(r,i):Reflect.get(n,i)})};var fe=async(...t)=>{let[e,a,o]=t;if(t.length===3&&o&&typeof o<"u"){let n=await ae(e.utils,o);return n||void 0}let s=R(a),r=await Oe(e,s);if(r.length!==0)return o?r.find(({keyId:n})=>(typeof o=="string"?o:o.objectId)===n):r[0]},ct=async(...t)=>{let[e,a,o]=t;try{let s=await e.scallopSuiKit.queryGetDynamicFieldObject({parentId:o,name:{type:"0x2::object::ID",value:a}});if(!s?.data)return !1;let r=s.data.content.fields.value.fields.contents;return Array.isArray(r)&&r.length>0}catch(s){return console.error(s),!1}},Jo=({builder:t,txBlock:e})=>{let a={id:t.address.get("vesca.id"),table:t.address.get("vesca.table"),treasury:t.address.get("vesca.treasury"),config:t.address.get("vesca.config"),subsTable:t.address.get("vesca.subsTable")},o=e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID$1,mutable:!1,initialSharedVersion:"1"});return {lockSca:(s,r)=>t.moveCall(e,`${a.id}::ve_sca::mint_ve_sca_key`,[a.config,a.table,a.treasury,s,r,o],[]),extendLockPeriod:(s,r)=>{t.moveCall(e,`${a.id}::ve_sca::extend_lock_period`,[a.config,s,a.table,a.treasury,r,o],[]);},extendLockAmount:(s,r)=>{t.moveCall(e,`${a.id}::ve_sca::lock_more_sca`,[a.config,s,a.table,a.treasury,r,o],[]);},renewExpiredVeSca:(s,r,n)=>{t.moveCall(e,`${a.id}::ve_sca::renew_expired_ve_sca`,[a.config,s,a.table,a.treasury,r,n,o],[]);},redeemSca:s=>t.moveCall(e,`${a.id}::ve_sca::redeem`,[a.config,s,a.table,a.treasury,o],[]),mintEmptyVeSca:()=>t.moveCall(e,`${a.id}::ve_sca::mint_ve_sca_placeholder_key`,[a.config,a.table],[]),splitVeSca:(s,r)=>t.moveCall(e,`${a.id}::ve_sca::split`,[a.config,s,a.table,a.subsTable,e.pure.u64(r)]),mergeVeSca:(s,r)=>t.moveCall(e,`${a.id}::ve_sca::merge`,[a.config,s,r,a.table,a.subsTable,e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID$1,mutable:!1,initialSharedVersion:"1"})],[])}},Zo=({builder:t,txBlock:e})=>({lockScaQuick:async({amountOrCoin:a,lockPeriodInDays:o,autoCheck:s=!0,veScaKey:r})=>{let n=R(e),i=await fe(t,e,r),c,d=[];if(a!==void 0&&typeof a=="number"){let m=await t.utils.selectCoins(a,ge,n),[b,y]=e.takeAmountFromCoins(m,a);c=b,d.push(y);}else c=a;let l=t.utils.getUnlockAt(o,i?.unlockAt);s&&Ot(a,o,l,i?.unlockAt);let u=!i,p=!u&&i.unlockAt<=new Date().getTime();if(u||p){if(c)if(u){let m=e.lockSca(c,l);d.push(m);}else {if(i.lockedScaCoin!==0){let m=e.redeemSca(i.keyId);d.push(m);}e.renewExpiredVeSca(i.keyId,c,l);}}else c&&o?(e.extendLockPeriod(i.keyId,l),e.extendLockAmount(i.keyId,c)):o?e.extendLockPeriod(i.keyId,l):c&&e.extendLockAmount(i.keyId,c);d.length>0&&e.transferObjects(d,n);},extendLockPeriodQuick:async({lockPeriodInDays:a,veScaKey:o,autoCheck:s=!0})=>{let r=await fe(t,e,o),n=t.utils.getUnlockAt(a,r?.unlockAt);s&&We(a,n,r?.unlockAt),r&&e.extendLockPeriod(r.keyId,n);},extendLockAmountQuick:async({scaAmount:a,veScaKey:o,autoCheck:s=!0})=>{let r=R(e),n=await fe(t,e,o);if(s&&Rt(a,n?.unlockAt),n){let i=await t.utils.selectCoins(a,ge,r),[c,d]=e.takeAmountFromCoins(i,a);e.extendLockAmount(n.keyId,c),e.transferObjects([d],r);}},renewExpiredVeScaQuick:async({scaAmount:a,lockPeriodInDays:o,veScaKey:s,autoCheck:r=!0})=>{let n=R(e),i=await fe(t,e,s),c=t.utils.getUnlockAt(o,i?.unlockAt);if(r&&It(a,o,i?.unlockAt),i){let d=[];if(i.lockedScaCoin!==0){let m=e.redeemSca(i.keyId);d.push(m);}let l=await t.utils.selectCoins(a,ge,n),[u,p]=e.takeAmountFromCoins(l,a);d.push(p),e.renewExpiredVeSca(i.keyId,u,c),e.transferObjects(d,n);}},redeemScaQuick:async({veScaKey:a,transferSca:o})=>{let s=R(e),r=await fe(t,e,a);if(ne(r?.unlockAt),r){let n=e.redeemSca(r.keyId);if(o){e.transferObjects([n],s);return}return n}},splitVeScaQuick:async({splitAmount:a,veScaKey:o,transferVeScaKey:s=!0})=>{let r=await ct(t,o,t.address.get("vesca.subsTable")),n=!!e.txBlock.blockData.transactions.find(c=>c.kind==="MoveCall"&&c.target===`${t.address.get("borrowIncentive.id")}::user::unstake_v2`);if(r&&!n)throw new Error("Key cannot be in the subs table, please call unsubscribe vesca or unstake obligation first");let i=e.splitVeSca(o,a);if(s){e.transferObjects([i],R(e));return}else return i},mergeVeScaQuick:async({targetVeScaKey:a,sourceVeScaKey:o})=>{let s=t.address.get("vesca.subsTableId"),[r,n]=await Promise.all([ct(t,a,s),ct(t,o,s)]),i=!!e.txBlock.blockData.transactions.find(l=>l.kind==="MoveCall"&&l.target===`${t.address.get("borrowIncentive.id")}::user::unstake_v2`);if((r||n)&&!i)throw new Error("Both target and source cannot be in the subs table. Please call unsubscribe vesca or unstake obligation first");let[c,d]=await Promise.all([ae(t.utils,o),ae(t.utils,a)]);if(!c||!d)throw new Error("Source or target veSCA not found");return c.unlockAt<d.unlockAt?e.extendLockPeriod(c.keyId,d.unlockAt/1e3):c.unlockAt>d.unlockAt&&e.extendLockPeriod(d.keyId,c.unlockAt/1e3),e.mergeVeSca(a,o)}}),ja=(t,e)=>{let a=e instanceof Transaction$1?new SuiTxBlock(e):e||new SuiTxBlock,o=Jo({builder:t,txBlock:a}),s=new Proxy(a,{get:(n,i)=>i in o?Reflect.get(o,i):Reflect.get(n,i)}),r=Zo({builder:t,txBlock:s});return new Proxy(s,{get:(n,i)=>i in r?Reflect.get(r,i):Reflect.get(n,i)})};var as=({builder:t,txBlock:e})=>{let a={referralPgkId:t.address.get("referral.id"),referralBindings:t.address.get("referral.referralBindings"),referralRevenuePool:t.address.get("referral.referralRevenuePool"),authorizedWitnessList:t.address.get("referral.authorizedWitnessList"),referralTiers:t.address.get("referral.referralTiers"),version:t.address.get("referral.version")},o=t.address.get("vesca.table"),s=e.sharedObjectRef({objectId:SUI_CLOCK_OBJECT_ID$1,mutable:!1,initialSharedVersion:"1"});return {bindToReferral:r=>{t.moveCall(e,`${a.referralPgkId}::referral_bindings::bind_ve_sca_referrer`,[a.referralBindings,e.pure.id(r),o,s],[]);},claimReferralTicket:r=>{let n=t.utils.parseCoinType(r);return t.moveCall(e,`${a.referralPgkId}::scallop_referral_program::claim_ve_sca_referral_ticket`,[a.version,o,a.referralBindings,a.authorizedWitnessList,a.referralTiers,s],[n])},burnReferralTicket:(r,n)=>{let i=t.utils.parseCoinType(n);t.moveCall(e,`${a.referralPgkId}::scallop_referral_program::burn_ve_sca_referral_ticket`,[a.version,r,a.referralRevenuePool,s],[i]);},claimReferralRevenue:(r,n)=>{let i=t.utils.parseCoinType(n);return t.moveCall(e,`${a.referralPgkId}::referral_revenue_pool::claim_revenue_with_ve_sca_key`,[a.version,a.referralRevenuePool,r,s],[i])}}},os=({builder:t,txBlock:e})=>({claimReferralRevenueQuick:async(a,o=[...t.constants.whitelist.lending])=>{let s=R(e),r=[];for(let n of o)if(n==="sui"){let i=e.claimReferralRevenue(a,n);r.push(i);}else {let i=e.claimReferralRevenue(a,n);try{let c=await t.suiKit.suiInteractor.selectCoins(s,1/0,t.utils.parseCoinType(n));e.mergeCoins(i,c.slice(0,500));}catch{}finally{r.push(i);}}r.length>0&&e.transferObjects(r,s);}}),_a=(t,e)=>{let a=e instanceof Transaction$1?new SuiTxBlock(e):e||new SuiTxBlock,o=as({builder:t,txBlock:a}),s=new Proxy(a,{get:(n,i)=>i in o?Reflect.get(o,i):Reflect.get(n,i)}),r=os({builder:t,txBlock:s});return new Proxy(s,{get:(n,i)=>i in r?Reflect.get(r,i):Reflect.get(n,i)})};var rs=({builder:t,txBlock:e})=>{let a={pkgId:t.address.get("loyaltyProgram.id"),scaRewardPool:t.address.get("loyaltyProgram.rewardPool")},o={object:t.address.get("vesca.object"),protocolConfig:t.address.get("vesca.config"),veScaTable:t.address.get("vesca.table"),subsTable:t.address.get("vesca.subsTable")},s={pkgId:t.address.get("veScaLoyaltyProgram.id"),veScaRewardPool:t.address.get("veScaLoyaltyProgram.veScaRewardPool")};return {claimLoyaltyRevenue:r=>t.moveCall(e,`${a.pkgId}::reward_pool::redeem_reward`,[a.scaRewardPool,r]),claimVeScaLoyaltyReward:r=>t.moveCall(e,`${s.pkgId}::ve_sca_reward::redeem_reward`,[s.veScaRewardPool,r,o.protocolConfig,o.veScaTable,o.subsTable])}},ns=({builder:t,txBlock:e})=>({claimLoyaltyRevenueQuick:async a=>{a=a??(await t.query.getVeScas())[0]?.keyObject;let o=R(e);if(!a)throw new Error(`No veScaKey found for user ${o}`);let s=e.claimLoyaltyRevenue(a),r=t.constants.coinTypes.sca;if(!r)throw new Error("Coin type sca not found");await t.utils.mergeSimilarCoins(e,s,r,R(e)),e.transferObjects([s],o);},claimVeScaLoyaltyRewardQuick:async a=>{a=a??(await t.query.getVeScas())[0]?.keyObject;let o=R(e);if(!a)throw new Error(`No veScaKey found for user ${o}`);let s=e.claimVeScaLoyaltyReward(a);e.transferObjects([s],o);}}),Ma=(t,e)=>{let a=e instanceof Transaction?new SuiTxBlock(e):e||new SuiTxBlock,o=rs({builder:t,txBlock:a}),s=new Proxy(a,{get:(n,i)=>i in o?Reflect.get(o,i):Reflect.get(n,i)}),r=ns({builder:t,txBlock:s});return new Proxy(s,{get:(n,i)=>i in r?Reflect.get(r,i):Reflect.get(n,i)})};var cs=({builder:t,txBlock:e})=>{let a={pkgId:t.address.get("scoin.id")};return {mintSCoin:(o,s)=>{let r=t.utils.parseSCoinType(o);if(!r)throw new Error(`Invalid marketCoinName name: ${o}`);return t.moveCall(e,`${a.pkgId}::s_coin_converter::mint_s_coin`,[t.utils.getSCoinTreasury(o),s],[r,t.utils.parseUnderlyingSCoinType(o)])},burnSCoin:(o,s)=>{let r=t.utils.parseSCoinType(o);if(!r)throw new Error(`Invalid sCoin name: ${o}`);return t.moveCall(e,`${a.pkgId}::s_coin_converter::burn_s_coin`,[t.utils.getSCoinTreasury(o),s],[r,t.utils.parseUnderlyingSCoinType(o)])}}},ls=({builder:t,txBlock:e})=>({mintSCoinQuick:async(a,o)=>{let s=R(e),{leftCoin:r,takeCoin:n}=await t.selectMarketCoin(e,a,o,s);return e.transferObjects([r],s),e.mintSCoin(a,n)},burnSCoinQuick:async(a,o)=>{let s=R(e),{leftCoin:r,takeCoin:n}=await t.selectSCoin(e,a,o,s);return e.transferObjects([r],s),e.burnSCoin(a,n)}}),Fa=(t,e)=>{let a=e instanceof Transaction$1?new SuiTxBlock(e):e||new SuiTxBlock,o=cs({builder:t,txBlock:a}),s=new Proxy(a,{get:(n,i)=>i in o?Reflect.get(o,i):Reflect.get(n,i)}),r=ls({builder:t,txBlock:s});return new Proxy(s,{get:(n,i)=>i in r?Reflect.get(r,i):Reflect.get(n,i)})};var Ka=(t,e)=>{let a=ja(t,e),o=Ma(t,a),s=Ra(t,o),r=_a(t,s),n=Fa(t,r),i=xa(t,n),c=ka(t,i);return new Proxy(c,{get:(d,l)=>l in a?Reflect.get(a,l):l in s?Reflect.get(s,l):l in r?Reflect.get(r,l):l in i?Reflect.get(i,l):l in o?Reflect.get(o,l):l in n?Reflect.get(n,l):Reflect.get(d,l)})};var lt=class{_queryClient;constructor(e={}){this._queryClient=e.queryClient??new QueryClient(this.defaultQueryClientConfig);}get queryClient(){return this._queryClient}set queryClient(e){this._queryClient=e;}get defaultQueryClientConfig(){return Tt}},me=lt;var dt=class extends me{axiosInstance;constructor(e={}){super(e),this.axiosInstance=e.axiosInstance??us.create({baseURL:e.baseUrl,headers:{"Content-Type":"application/json",Accept:"application/json"},timeout:e.axiosTimeout??8e3});}async post(e,a,o,s){if(Array.isArray(a)){let r=a,n=o,i=s;return this.queryClient.fetchQuery({queryKey:r,queryFn:()=>this.axiosInstance.post(e,n,i).then(c=>c)})}else {let r=a,n=o;return this.axiosInstance.post(e,r,n)}}async get(e,a,o){if(Array.isArray(a)){let s=a,r=o;return this.queryClient.fetchQuery({queryKey:s,queryFn:()=>this.axiosInstance.get(e,r).then(n=>n)})}else {let s=a;return this.axiosInstance.get(e,s)}}async put(e,a,o,s){if(Array.isArray(a)){let r=a,n=o,i=s;return this.queryClient.fetchQuery({queryKey:r,queryFn:()=>this.axiosInstance.put(e,n,i).then(c=>c)})}else {let r=a,n=o;return this.axiosInstance.put(e,r,n)}}async delete(e,a,o){if(Array.isArray(a)){let s=a,r=o;return this.queryClient.fetchQuery({queryKey:s,queryFn:()=>this.axiosInstance.delete(e,r).then(n=>n)})}else {let s=a;return this.axiosInstance.delete(e,s)}}},be=dt;var ut={core:{version:"",versionCap:"",object:"",market:"",adminCap:"",coinDecimalsRegistry:"",obligationAccessStore:"",coins:{cetus:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},wapt:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},wsol:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},wbtc:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},weth:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},wusdc:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},wusdt:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},sui:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},afsui:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},hasui:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},vsui:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}},sca:{id:"",metaData:"",treasury:"",symbol:"",coinType:"",decimals:0,oracle:{supra:"",switchboard:"",pyth:{feed:"",feedObject:""}}}},oracles:{xOracle:"",xOracleCap:"",primaryPriceUpdatePolicyObject:"",secondaryPriceUpdatePolicyObject:"",primaryPriceUpdatePolicyVecsetId:"",secondaryPriceUpdatePolicyVecsetId:"",supra:{registry:"",registryCap:"",holder:""},switchboard:{registry:"",registryCap:"",registryTableId:"",state:""},pyth:{registry:"",registryCap:"",state:"",wormhole:"",wormholeState:""}},packages:{coinDecimalsRegistry:{id:"",upgradeCap:""},math:{id:"",upgradeCap:""},whitelist:{id:"",upgradeCap:""},x:{id:"",upgradeCap:""},protocol:{id:"",upgradeCap:""},protocolWhitelist:{id:"",upgradeCap:""},query:{id:"",upgradeCap:""},supra:{id:"",upgradeCap:""},pyth:{id:"",upgradeCap:""},switchboard:{id:"",upgradeCap:""},xOracle:{id:"",upgradeCap:""},testCoin:{id:"",upgradeCap:""}}},spool:{id:"",adminCap:"",object:"",pools:{sweth:{id:"",rewardPoolId:""},ssui:{id:"",rewardPoolId:""},swusdc:{id:"",rewardPoolId:""},swusdt:{id:"",rewardPoolId:""},scetus:{id:"",rewardPoolId:""},safsui:{id:"",rewardPoolId:""},shasui:{id:"",rewardPoolId:""},svsui:{id:"",rewardPoolId:""}},config:""},borrowIncentive:{id:"",adminCap:"",object:"",query:"",incentivePools:"",incentiveAccounts:"",config:""},vesca:{id:"",object:"",adminCap:"",tableId:"",table:"",treasury:"",config:"",subsTable:"",subsTableId:"",subsWhitelist:""},referral:{id:"",version:"",object:"",adminCap:"",referralBindings:"",bindingTableId:"",referralRevenuePool:"",revenueTableId:"",referralTiers:"",tiersTableId:"",authorizedWitnessList:""},loyaltyProgram:{id:"",object:"",rewardPool:"",userRewardTableId:""},veScaLoyaltyProgram:{id:"",object:"",veScaRewardPool:"",veScaRewardTableId:""},scoin:{id:"",coins:{ssui:{coinType:"",treasury:"",metaData:"",symbol:""},scetus:{coinType:"",treasury:"",metaData:"",symbol:""},ssca:{coinType:"",treasury:"",metaData:"",symbol:""},swusdc:{coinType:"",treasury:"",metaData:"",symbol:""},swusdt:{coinType:"",treasury:"",metaData:"",symbol:""},sweth:{coinType:"",treasury:"",metaData:"",symbol:""},safsui:{coinType:"",treasury:"",metaData:"",symbol:""},shasui:{coinType:"",treasury:"",metaData:"",symbol:""},svsui:{coinType:"",treasury:"",metaData:"",symbol:""}}}},pt=class{constructor(e={}){this.params=e;this.scallopAxios=new be({...this.defaultParamValues,...e}),this.network=e.network??"mainnet",this.addressId=e.addressId??this.defaultParamValues.addressId,this.auth=e.auth??"",e.forceAddressesInterface&&this.initializeForcedAddresses(e.forceAddressesInterface);}currentAddresses;addressId;network;auth;scallopAxios;addressMap=new Map;defaultParamValues={addressId:"67c44a103fe1b8c454eb9699",network:"mainnet"};initializeForcedAddresses(e){let a=["localnet","devnet","testnet","mainnet"];Object.entries(e).forEach(([o,s])=>{if(a.includes(o)){let r=o;this.addressMap.set(r,s),r===this.network&&(this.currentAddresses=s);}});}get axiosClient(){return this.scallopAxios}get queryClient(){return this.axiosClient.queryClient}get defaultValues(){return this.params.defaultValues}getId(){return this.addressId}get(e){if(this.currentAddresses)return e.split(".").reduce((o,s)=>typeof o=="object"?o[s]:o,this.currentAddresses)||void 0}set(e,a){if(this.currentAddresses){let o=e.split(".");o.reduce((s,r,n)=>{if(n===o.length-1)s[r]=a;else return s[r]},this.currentAddresses);}return this.currentAddresses}switchCurrentAddresses(e){return this.addressMap.has(e)&&(this.currentAddresses=this.addressMap.get(e),this.network=e),this.currentAddresses}getAddresses(e){return e?this.addressMap.get(e):this.currentAddresses??this.addressMap.get(this.network)}setAddresses(e,a){let o=a||this.network;o===this.network&&(this.currentAddresses=e),this.addressMap.set(o,e);}getAllAddresses(){return Object.fromEntries(this.addressMap)}async create(e){let{addresses:a,network:o,auth:s,memo:r}=e??{},n=s||this.auth||void 0,i=o||this.network,c=a||this.currentAddresses||this.addressMap.get(i)||ut;if(n!==void 0){this.addressMap.clear(),this.setAddresses(c,i);let d=await this.axiosClient.post("/addresses",JSON.stringify({...Object.fromEntries(this.addressMap),memo:r}),{headers:{"Content-Type":"application/json","api-key":s||this.auth}});if(d.status===201){for(let[l,u]of Object.entries(d.data))["localnet","devnet","testnet","mainnet"].includes(l)&&(l===this.network&&(this.currentAddresses=u),this.addressMap.set(l,u));return this.addressId=d.data.id,this.getAllAddresses()}else throw Error("Failed to create addresses.")}else throw Error("You don't have permission to access this request.")}async readApi({url:e,queryKey:a,config:o}){let s=await this.axiosClient.get(e,a,o);if(s.status===200)return s.data;throw Error(`Error: ${s.status}; Failed to read ${e} ${s.statusText}`)}async read(e){let a=e||this.addressId||void 0;if(a!==void 0){let o=await(async()=>{let r=(this.params.urls?.addresses??[At]).map(n=>`${ce(n)}/addresses/${a}`);for(let n of r)try{return await this.readApi({url:n,queryKey:N.api.getAddresses({addressId:a})})}catch(i){console.error(`${i}`);}return {id:"",mainnet:this.defaultValues?.addresses?.mainnet??ut}})(),s=r=>["localnet","devnet","testnet","mainnet"].includes(r);for(let[r,n]of Object.entries(o))s(r)&&typeof n=="object"&&(r===this.network&&(this.currentAddresses=n),this.addressMap.set(r,n));return this.addressId=o.id,this.getAllAddresses()}else throw Error("Please provide API addresses id.")}async update(e){let{id:a,addresses:o,network:s,auth:r,memo:n}=e??{},i=r||this.auth||void 0,c=a||this.addressId||void 0,d=s||this.network,l=o||this.currentAddresses||this.addressMap.get(d)||ut;if(c===void 0)throw Error("Require specific addresses id to be updated.");if(i!==void 0){a!==this.addressId&&this.addressMap.clear(),this.setAddresses(l,d);let u=await this.axiosClient.put(`/addresses/${c}`,JSON.stringify({...Object.fromEntries(this.addressMap),memo:n}),{headers:{"Content-Type":"application/json","api-key":r||this.auth}});if(u.status===200){for(let[p,m]of Object.entries(u.data))["localnet","devnet","testnet","mainnet"].includes(p)&&(p===this.network&&(this.currentAddresses=m),this.addressMap.set(p,m));return this.addressId=u.data.id,this.getAllAddresses()}else throw Error("Failed to update addresses.")}else throw Error("You don't have permission to access this request.")}async delete(e,a){let o=a||this.auth||void 0,s=e||this.addressId||void 0;if(s===void 0)throw Error("Require specific addresses id to be deleted.");if(o!==void 0)if((await this.axiosClient.delete(`/addresses/${s}`,{headers:{"Content-Type":"application/json","api-key":a||this.auth}})).status===200)this.addressId=void 0,this.currentAddresses=void 0,this.addressMap.clear();else throw Error("Failed to delete addresses.");else throw Error("You don't have permission to access this request.")}},je=pt;var La=t=>Object.keys(t).length===0,ft={lending:new Set,borrowing:new Set,collateral:new Set,packages:new Set,scoin:new Set,spool:new Set,borrowIncentiveRewards:new Set,rewardsAsPoint:new Set,suiBridge:new Set,wormhole:new Set,oracles:new Set,pythEndpoints:new Set,deprecated:new Set,emerging:new Set},fs=t=>Object.entries(t).filter(([e,a])=>!!a&&(Array.isArray(a)||a instanceof Set)).reduce((e,[a,o])=>(e[a]=o instanceof Set?o:new Set(o),e),{}),mt=class extends je{constructor(a={}){super(a);this.params=a;}_poolAddresses={};_whitelist=ft;coinDecimals={};coinNameToOldMarketCoinTypeMap={};scoinRawNameToSCoinNameMap={};scoinTypeToSCoinNameMap={};wormholeCoinTypeToCoinNameMap={};voloCoinTypeToCoinNameMap={};suiBridgeCoinTypeToCoinNameMap={};coinTypes={};sCoinTypes={};coinTypeToCoinNameMap={};supportedBorrowIncentiveRewards=new Set;get protocolObjectId(){return this.get("core.object")??"0xefe8b36d5b2e43728cc323298626b83177803521d195cfb11e15b910e892fddf"}get isInitialized(){let a=["lending","collateral","borrowing","packages","scoin","spool","oracles","pythEndpoints","emerging"];return this.isAddressInitialized()&&!La(this.poolAddresses)&&a.every(o=>this.whitelist[o].size>0)}get whitelist(){return new Proxy(this._whitelist,{get:(a,o)=>a[o]??ft[o]})}get poolAddresses(){return new Proxy(this._poolAddresses,{get:(a,o)=>a[o]??void 0})}get defaultValues(){return this.params.defaultValues}isAddressInitialized({networkType:a="mainnet"}={}){let o=this.getAddresses(a);return !!o&&!La(o)}parseToOldMarketCoin(a){return `${this.protocolObjectId}::reserve::MarketCoin<${a}>`}async init({networkType:a="mainnet",force:o=!1,addressId:s,constantsParams:r=this.params}={}){let n=this.getAddresses(a);if((!n||Object.keys(n).length===0||o)&&await this.read(s),r.forcePoolAddressInterface&&(this._poolAddresses=r.forcePoolAddressInterface),r.forceWhitelistInterface&&(this._whitelist=fs(r.forceWhitelistInterface)),this.isInitialized&&!o){this.initConstants();return}let[i,c]=await Promise.all([this.readWhiteList(),this.readPoolAddresses()]);this.params.forceWhitelistInterface||(this._whitelist=Object.keys(this._whitelist).reduce((d,l)=>{let u=l,p=i[u];return d[u]=p instanceof Set?p:Array.isArray(p)?new Set(p):new Set,d},{})),this.params.forcePoolAddressInterface||(this._poolAddresses=Object.fromEntries(Object.entries(c).filter(([d])=>Object.values(this._whitelist).some(l=>l.has(d))).map(([d,l])=>{let u=Object.fromEntries(Object.entries(l).map(([p,m])=>[p,typeof m=="boolean"?m??!1:m||void 0]));return [d,u]}))),this.initConstants();}initConstants(){this.coinDecimals=Object.fromEntries([...Object.entries(this.poolAddresses).filter(([o,s])=>!!s).map(([o,s])=>[o,s.decimals]),...Object.entries(this.poolAddresses).filter(([o,s])=>!!s?.sCoinName).map(([o,s])=>[s.sCoinName,s.decimals])]),this.coinTypes=Object.fromEntries([...Object.entries(this.poolAddresses).filter(([o,s])=>!!s).map(([o,s])=>[o,s?.coinType]),...Object.entries(this.poolAddresses).filter(([o,s])=>!!s&&s.sCoinName&&s.sCoinType).map(([o,s])=>[s.sCoinName,s.sCoinType])]),this.coinTypeToCoinNameMap=Object.fromEntries(Object.entries(this.coinTypes).map(([o,s])=>[s,o])),this.wormholeCoinTypeToCoinNameMap=Object.fromEntries(Object.entries(this.poolAddresses).filter(([o,s])=>!!s&&this.whitelist.wormhole.has(o)).map(([o,s])=>[s.coinType,s.coinName])),this.coinNameToOldMarketCoinTypeMap=Object.fromEntries(Object.entries(this.poolAddresses).filter(([o,s])=>!!s).map(([o,s])=>[s.coinName,this.parseToOldMarketCoin(s.coinType)])),this.scoinRawNameToSCoinNameMap=Object.fromEntries(Object.entries(this.poolAddresses).filter(([o,s])=>!!s&&s.sCoinType&&s.sCoinName).map(([o,s])=>[parseStructTag(s.sCoinType).name,s.sCoinName])),this.scoinTypeToSCoinNameMap=Object.fromEntries(Object.entries(this.poolAddresses).filter(([o,s])=>!!s&&s.sCoinType&&s.sCoinName).map(([o,s])=>[s.sCoinType,s.sCoinName]));let a=this.poolAddresses.vsui?.coinType;a&&(this.voloCoinTypeToCoinNameMap={[a]:"vsui"}),this.suiBridgeCoinTypeToCoinNameMap=Object.fromEntries(Object.entries(this.poolAddresses).filter(([o,s])=>!!s&&this.whitelist.suiBridge.has(s.coinName)).map(([o,s])=>[s.coinType,s.coinName])),this.sCoinTypes=Object.fromEntries(Object.entries(this.poolAddresses).filter(([o,s])=>!!s&&s.sCoinName&&s.sCoinType).map(([o,s])=>[s.sCoinName,s.sCoinType])),this.supportedBorrowIncentiveRewards=new Set([...Object.values(this.poolAddresses).filter(o=>!!o).map(o=>o.sCoinName?[o.coinName,o.sCoinName]:[o.coinName]).flat()]);}async readWhiteList(){let a=await(async()=>{let o=(this.params.urls?.whitelist??["https://sui.apis.scallop.io/pool/whitelist"]).map(ce);for(let s of o)try{return await this.readApi({url:s,queryKey:N.api.getWhiteList()})}catch(r){console.error(`${r}`);}return this.defaultValues?.whitelist??ft})();return Object.fromEntries(Object.entries(a).filter(([o,s])=>Array.isArray(s)||s instanceof Set).map(([o,s])=>[o,s instanceof Set?s:new Set(s)]))}async readPoolAddresses(){let a=(this.params.urls?.poolAddresses??["https://sui.apis.scallop.io/pool/addresses"]).map(ce);for(let o of a)try{return await this.readApi({url:o,queryKey:N.api.getPoolAddresses()})}catch(s){console.error(`${s}`);}return this.defaultValues?.poolAddresses??{}}},Ne=mt;var Va=t=>{let e;return "suiClients"in t&&t.suiClients&&t.suiClients?.length>0?e={suiClients:t.suiClients}:e={fullnodeUrls:"fullnodeUrls"in t?t?.fullnodeUrls??Ue:Ue},new SuiKit({...t,...e})};var gs=10,_e=(t,e)=>{let a={...t};for(let o in e)e[o]&&typeof e[o]=="object"&&!Array.isArray(e[o])?a[o]=_e(t[o]||{},e[o]):a[o]=e[o];return a},Be=class{constructor(e=10){this.capacity=e;this.refillRate=this.capacity/1e3,this.tokens=this.capacity,this.lastRefillTime=Date.now();}tokens;lastRefillTime;refillRate;refill(){let e=Date.now(),o=(e-this.lastRefillTime)*this.refillRate;this.tokens=Math.min(this.capacity,this.tokens+o),this.lastRefillTime=e;}getTimeToNextToken(){if(this.refill(),this.tokens>=1)return 0;let e=1-this.tokens;return Math.ceil(e/this.refillRate)}async acquireToken(){for(;;){let e=this.getTimeToNextToken();if(e===0){if(this.tokens>=1){this.tokens-=1;return}continue}await new Promise(a=>setTimeout(a,e)),this.refill();}}async execute(e){return await this.acquireToken(),await e()}},bt=class extends me{suiKit;_walletAddress;_tokensPerSecond;rateLimiter;constructor(e={}){super(e),this.suiKit=e.suiKit??Va(e),this._tokensPerSecond=e.tokensPerSecond??gs,this.rateLimiter=new Be(this._tokensPerSecond),this._walletAddress=e.walletAddress??this.suiKit.currentAddress;}switchFullNodes(e){this.suiKit.suiInteractor.switchFullNodes(e);}get client(){return this.suiKit.client}get walletAddress(){return this._walletAddress}set walletAddress(e){this._walletAddress=e;}get tokensPerSecond(){return this._tokensPerSecond}set tokensPerSecond(e){this._tokensPerSecond=e,this.rateLimiter=new Be(this._tokensPerSecond);}get currentFullNode(){try{return this.suiKit.suiInteractor.currentFullNode}catch{return ""}}signAndSendTxn(e,a){return this.suiKit.signAndSendTxn(e,a)}async callWithRateLimiter(e,a){return await this.queryClient.fetchQuery({queryKey:e,queryFn:()=>this.rateLimiter.execute(a)})}async queryGetNormalizedMoveFunction(e){let{address:a,module:o,name:s}=parseStructTag(e);return await this.callWithRateLimiter(N.rpc.getNormalizedMoveFunction({target:e}),()=>this.client.getNormalizedMoveFunction({package:a,module:o,function:s}))}async queryGetObject(e,a){return a={...a,showOwner:!0,showContent:!0,showType:!0},await this.callWithRateLimiter(N.rpc.getObject({objectId:e,options:a,node:this.currentFullNode}),()=>this.client.getObject({id:e,options:a}))}async queryGetObjects(e,a){if(e.length===0)return [];a??={showContent:!0,showOwner:!0,showType:!0};let o=await this.callWithRateLimiter(N.rpc.getObjects({objectIds:e,node:this.currentFullNode}),()=>this.suiKit.getObjects(e,{showOwner:a?.showOwner,showContent:a?.showContent,showType:a?.showType}));return o.forEach(s=>{let r=N.rpc.getObject({objectId:s.objectId,node:this.currentFullNode});this.queryClient.getQueriesData({exact:!1,queryKey:r}).forEach(([i,c])=>{c||(c={data:c}),this.queryClient.setQueryData(i,_e(c,{data:s,error:null}),{updatedAt:Date.now()});});}),o}async queryGetOwnedObjects(e){let a=await this.callWithRateLimiter(N.rpc.getOwnedObjects(e),()=>this.client.getOwnedObjects(e));return a&&a.data.length>0&&a.data.filter(o=>!!o.data).forEach(o=>{let s=N.rpc.getObject({objectId:o.data.objectId,node:this.currentFullNode});this.queryClient.getQueriesData({exact:!1,queryKey:s}).forEach(([n,i])=>{this.queryClient.setQueryData(n,_e(i,{data:o.data,error:null}),{updatedAt:Date.now()});});}),a}async queryGetDynamicFields(e){return await this.callWithRateLimiter(N.rpc.getDynamicFields(e),()=>this.client.getDynamicFields(e))}async queryGetDynamicFieldObject(e){let a=await this.callWithRateLimiter(N.rpc.getDynamicFieldObject(e),()=>this.client.getDynamicFieldObject(e));if(a?.data){let o=N.rpc.getObject({objectId:a.data.objectId,node:this.currentFullNode});this.queryClient.getQueriesData({exact:!1,queryKey:o}).forEach(([r,n])=>{this.queryClient.setQueryData(r,_e(n,{data:a.data,error:null}),{updatedAt:Date.now()});});}return a}async queryGetAllCoinBalances(e){return await this.callWithRateLimiter(N.rpc.getAllCoinBalances({activeAddress:e,node:this.currentFullNode}),async()=>{let a=await this.client.getAllBalances({owner:e});return a?a.reduce((s,r)=>(r.totalBalance!=="0"&&(s[normalizeStructTag(r.coinType)]=r),s),{}):{}})}async queryGetCoinBalance(e){return e.coinType?(await this.queryGetAllCoinBalances(e.owner))[normalizeStructTag(e.coinType)]??null:null}async queryInspectTxn({queryTarget:e,args:a,typeArgs:o}){let s=new SuiTxBlock;if(!await this.queryGetNormalizedMoveFunction(e))throw new Error("Invalid query target");let n=await Promise.all((a??[]).map(async i=>{if(typeof i!="string")return i;let c=(await this.queryGetObject(i))?.data;return c||i}));return s.moveCall(e,n,o),await this.callWithRateLimiter(N.rpc.getInspectTxn({queryTarget:e,args:a,typeArgs:o,node:this.currentFullNode}),()=>this.suiKit.inspectTxn(s))}},Me=bt;var gt=class{pythEndpoints;scallopSuiKit;constants;timeout;constructor(e={}){this.constants=e.scallopConstants??new Ne(e),this.scallopSuiKit=e.scallopSuiKit??new Me({queryClient:this.constants.queryClient,...e}),this.pythEndpoints=e.pythEndpoints??["https://hermes.pyth.network"],this.timeout=e.axiosTimeout??4e3;}get walletAddress(){return this.scallopSuiKit.walletAddress}get suiKit(){return this.scallopSuiKit.suiKit}get queryClient(){return this.constants.queryClient}get address(){return this.constants}isSuiBridgeAsset(e){return this.constants.whitelist.suiBridge.has(e)}isWormholeAsset(e){return this.constants.whitelist.wormhole.has(e)}isMarketCoin(e){let a=e.slice(1).toLowerCase();return e.charAt(0).toLowerCase()==="s"&&this.constants.whitelist.lending.has(a)}async init({force:e=!1}={}){await this.constants.init({force:e});}parseCoinName(e){return e.slice(1)}parseSymbol(e){return this.isMarketCoin(e)?this.constants.poolAddresses[this.parseCoinName(e)]?.sCoinSymbol??"":this.constants.poolAddresses[e]?.symbol??""}parseCoinType(e,a=!1){return a?this.constants.coinNameToOldMarketCoinTypeMap[e]??"":this.constants.coinTypes[e]??""}parseSCoinName(e){if(this.isMarketCoin(e)&&this.constants.whitelist.scoin.has(e))return e;{let a=`s${e}`;return this.constants.whitelist.scoin.has(a)?a:void 0}}parseSCoinTypeNameToMarketCoinName(e){return this.constants.scoinRawNameToSCoinNameMap[e]??e}parseSCoinType(e){return this.constants.sCoinTypes[e]??""}parseSCoinNameFromType(e){return this.constants.scoinTypeToSCoinNameMap[e]}parseUnderlyingSCoinType(e){let a=this.parseCoinName(e);return this.parseCoinType(a)}getSCoinTreasury(e){return this.address.get(`scoin.coins.${e}.treasury`)}parseMarketCoinType(e){return this.parseCoinType(this.isMarketCoin(e)?this.parseCoinName(e):e,!0)}parseMarketCoinName(e){return `s${e}`}getSpoolRewardCoinName=()=>"sui";getCoinDecimal(e){return this.constants.coinDecimals[e]??0}getCoinWrappedType(e){if(this.isSuiBridgeAsset(e))return {from:"Sui Bridge",type:"Asset from Sui Bridge"};if(this.isWormholeAsset(e))return {from:"Wormhole",type:"Portal from Ethereum"}}parseCoinNameFromType(e){e=normalizeStructTag(e);let{address:a,module:o,name:s,typeParams:r}=parseStructTag(e);return a===this.constants.protocolObjectId&&o==="reserve"&&s==="MarketCoin"?this.parseMarketCoinName((typeof r[0]=="string"?parseStructTag(r[0]):r[0]).name.toLowerCase()):this.constants.coinTypeToCoinNameMap[e]||this.constants.scoinTypeToSCoinNameMap[e]||parseStructTag(e).name.toLowerCase()}async selectCoins(e,a=SUI_TYPE_ARG,o){return o=o??this.walletAddress,await this.suiKit.suiInteractor.selectCoins(o,e,a)}async mergeSimilarCoins(e,a,o,s=this.walletAddress){try{let r=await this.selectCoins(Number.MAX_SAFE_INTEGER,o,s);r.length>0&&e.mergeCoins(a,r.slice(0,500).map(e.objectRef));}catch{}}async getObligationCoinNames(e){let a=await Te(this,e);if(!a)return;let o=a.collaterals.map(i=>`0x${i.type.name}`),s=a.debts.map(i=>`0x${i.type.name}`);return [...new Set([...o,...s])].map(i=>this.parseCoinNameFromType(i))}parseDataFromPythPriceFeed(e){let o=[...this.constants.whitelist.lending].find(s=>this.address.get(`core.coins.${s}.oracle.pyth.feed`)===e.id);if(o){let s=e.getPriceUnchecked();return {coinName:o,price:s.getPriceAsNumberUnchecked(),publishTime:Number(s.publishTime)*10**3}}else throw new Error(`Invalid feed id: ${e.id}`)}async getPythPrice(e,a){let o=this.address.get(`core.coins.${e}.oracle.pyth.feedObject`);if(a=a||(await this.scallopSuiKit.queryGetObject(o))?.data,a){let s=a;if(s.content&&"fields"in s.content){let r=s.content.fields,n=Number(r.price_info.fields.price_feed.fields.price.fields.expo.fields.magnitude),i=Number(r.price_info.fields.price_feed.fields.price.fields.expo.fields.negative),c=Number(r.price_info.fields.price_feed.fields.price.fields.price.fields.magnitude),d=Number(r.price_info.fields.price_feed.fields.price.fields.price.fields.negative);return c*10**((i?-1:1)*n)*(d?-1:1)}}return 0}async getPythPrices(e){let a=e.reduce((r,n)=>{let i=this.address.get(`core.coins.${n}.oracle.pyth.feedObject`);return i&&(r[i]?r[i].push(n):r[i]=[n]),r},{}),s=(await this.scallopSuiKit.queryGetObjects(Object.keys(a))).reduce((r,n)=>(a[n.objectId].forEach(i=>{r[i]=n;}),r),{});return (await Promise.all(Object.entries(s).map(async([r,n])=>({coinName:r,price:await this.getPythPrice(r,n)})))).reduce((r,n)=>(r[n.coinName]=n.price,r),{})}async getCoinPrices(e=[...new Set([...this.constants.whitelist.lending,...this.constants.whitelist.collateral])]){let a={},o=this.pythEndpoints,s=new Set(e);for(let r of o){let n=Array.from(s.values()).reduce((d,l)=>{let u=this.address.get(`core.coins.${l}.oracle.pyth.feed`)??this.constants.poolAddresses[l]?.pythFeed;return d.push([l,u]),d},[]);if(n.length===0)break;let i=n.map(([d,l])=>l),c=new SuiPriceServiceConnection(r,{timeout:this.timeout});try{let d=await this.queryClient.fetchQuery({queryKey:N.oracle.getPythLatestPriceFeeds(),queryFn:async()=>await c.getLatestPriceFeeds(i),staleTime:3e4,gcTime:3e4});d&&d.forEach((l,u)=>{let p=n[u][0],m=this.parseDataFromPythPriceFeed(l);a[p]=m.price,s.delete(p);});}catch(d){console.error(d.message);}if(s.size===0)break}return s.size>0&&(a={...a,...await this.getPythPrices(Array.from(s.values()))},s.clear()),a}parseAprToApy(e,a=365){return (1+e/a)**a-1}parseApyToApr(e,a=365){return ((1+e)**(1/a)-1)*a}getUnlockAt(e,a){let o=Math.floor(new Date().getTime()/1e3),s=a?Math.max(Math.floor(a/1e3)-o,0):0,r=0;if(s===0){let n=(e??1)*86400;r=Math.min(o+n,o+126144e3);}else {let n=Math.min(e?e*86400+s:s,126144e3);r=o+n;}return Ft(r)}getSupportedPoolAddresses(){return this.constants.poolAddresses?Object.values(this.constants.poolAddresses).filter(e=>e!==void 0&&this.constants.whitelist.lending.has(e.coinName)):[]}},De=gt;var ht=class extends be{constructor(e={}){e.baseUrl=e.indexerApiUrl??Pt,super(e);}async getMarket(){let e=await this.get("/api/market/migrate",N.api.getMarket());if(e.status===200)return {pools:e.data.pools.reduce((a,o)=>(a[o.coinName]=o,a),{}),collaterals:e.data.collaterals.reduce((a,o)=>(a[o.coinName]=o,a),{})};throw Error("Failed to getMarket.")}async getMarketPools(){return (await this.getMarket()).pools}async getMarketPool(e){return (await this.getMarketPools())[e]}async getMarketCollaterals(){return (await this.getMarket()).collaterals}async getMarketCollateral(e){return (await this.getMarketCollaterals())[e]}async getSpools(){let e=await this.get("/api/spools/migrate",N.api.getSpools());if(e.status===200)return e.data.spools.reduce((a,o)=>(a[o.marketCoinName]=o,a),{});throw Error("Failed to getSpools.")}async getSpool(e){return (await this.getSpools())[e]}async getBorrowIncentivePools(){let e=await this.get("/api/borrowIncentivePools/migrate",N.api.getBorrowIncentivePool());if(e.status===200)return e.data.borrowIncentivePools.reduce((a,o)=>(Array.isArray(o.points)&&(o.points=o.points.reduce((s,r)=>(s[r.coinName]=r,s),{})),a[o.coinName]=o,a),{});throw Error("Failed to getBorrowIncentivePools.")}async getBorrowIncentivePool(e){return (await this.getBorrowIncentivePools())[e]}async getTotalValueLocked(){let e=await this.get("/api/market/tvl",N.api.getTotalValueLocked());if(e.status===200)return e.data;throw Error("Failed to getTotalValueLocked.")}async getCoinPrice(e){return (await this.getMarketPool(e))?.coinPrice??0}async getCoinPrices(){let e=await this.getMarketPools();return Object.entries(e).reduce((a,[o,s])=>(s&&(a[o]=s.coinPrice),a),{})}},Fe=ht;var wt=class{indexer;utils;constructor(e){this.utils=e.utils??new De(e),this.indexer=e.indexer??new Fe({queryClient:this.utils.queryClient,...e}),this.initIndexerFallback();}initIndexerFallback(){this.queryMarket=L.call(this,this.queryMarket),this.getMarketPools=L.call(this,this.getMarketPools),this.getMarketPool=L.call(this,this.getMarketPool),this.getMarketCollaterals=L.call(this,this.getMarketCollaterals),this.getMarketCollateral=L.call(this,this.getMarketCollateral),this.getSpools=L.call(this,this.getSpools),this.getSpool=L.call(this,this.getSpool),this.getBorrowIncentivePools=L.call(this,this.getBorrowIncentivePools),this.getLendings=L.call(this,this.getLendings),this.getLending=L.call(this,this.getLending),this.getObligationAccounts=L.call(this,this.getObligationAccounts),this.getObligationAccountsByIds=L.call(this,this.getObligationAccountsByIds),this.getObligationAccountById=L.call(this,this.getObligationAccountById),this.getObligationAccount=L.call(this,this.getObligationAccount),this.getTvl=L.call(this,this.getTvl);}async init(e=!1){await this.utils.init({force:e});}get constants(){return this.utils.constants}get walletAddress(){return this.utils.walletAddress}get scallopSuiKit(){return this.utils.scallopSuiKit}get address(){return this.utils.address}async queryMarket(e){return await Gt(this,e?.indexer,e?.coinPrices)}async getMarketPools(e=[...this.constants.whitelist.lending],a){return await Ht(this,e,a?.indexer,a?.coinPrices)}async getMarketPool(e,a){return (await this.getMarketPools(void 0,a)).pools[e]}async getMarketCollaterals(e=[...this.constants.whitelist.collateral],a){return await Xt(this,e,a?.indexer)}async getMarketCollateral(e,a){return await He(this,e,a?.indexer)}async getObligations(e=this.walletAddress){return await se(this,e)}async queryObligation(e){return Te(this,e)}async getCoinAmounts(e,a=this.walletAddress){return await Yt(this,e,a)}async getCoinAmount(e,a=this.walletAddress){return await Ye(this,e,a)}async getMarketCoinAmounts(e,a=this.walletAddress){return await Jt(this,e,a)}async getMarketCoinAmount(e,a=this.walletAddress){return await Je(this,e,a)}async getPriceFromPyth(e){return await tt(this,e)}async getPricesFromPyth(e){return await ia(this,e)}async getSpools(e,a){return await ma(this,e,a?.indexer,a?.marketPools,a?.coinPrices)}async getSpool(e,a){return (await this.getSpools(void 0,a))[e]}async getAllStakeAccounts(e=this.walletAddress){return await de(this,e)}async getStakeAccounts(e,a=this.walletAddress){return (await this.getAllStakeAccounts(a))[e]??[]}async getStakePools(e=[...this.constants.whitelist.spool]){let a={};for(let o of e){let s=await st(this,o);s&&(a[o]=s);}return a}async getStakePool(e){return await st(this,e)}async getStakeRewardPools(e=[...this.constants.whitelist.spool]){let a={};return await Promise.allSettled(e.map(async o=>{let s=await rt(this,o);s&&(a[o]=s);})),a}async getStakeRewardPool(e){return await rt(this,e)}async getBorrowIncentivePools(e=[...this.constants.whitelist.lending],a){return await Kt(this,e,a?.indexer,a?.marketPools,a?.coinPrices)}async getBorrowIncentiveAccounts(e,a){return await Lt(this,e,a)}async getLendings(e,a=this.walletAddress,o){return await aa(this,e,a,o?.marketPools,o?.coinPrices,o?.indexer)}async getLending(e,a=this.walletAddress,o){return await et(this,e,a,o?.indexer)}async getObligationAccounts(e=this.walletAddress,a){return await oa(this,e,a?.market,a?.coinPrices,a?.indexer)}async getObligationAccountsByIds(e,a){return await sa(this,e,a?.market,a?.coinPrices,a?.indexer)}async getObligationAccountById(e,a){return await Ae(this,e,"",a?.indexer,a?.market,a?.coinPrices,{})}async getObligationAccount(e,a=this.walletAddress,o){let s=await this.getObligationAccounts(a,o);return Object.values(s).find(r=>r?.obligationId===e)}async getTvl(e){return await ra(this,e?.indexer)}async getVeSca(e){return await ae(this.utils,e)}async getVeScas({walletAddress:e=this.walletAddress,excludeEmpty:a=!1}={}){return await Oe(this,e,a)}async getVeScaTreasuryInfo(){return await ya(this.utils)}async getVeScaKeyIdFromReferralBindings(e=this.walletAddress){return await la(this,e)}async getBindedObligationId(e){return await Vt(this,e)}async getBindedVeScaKey(e){return await Et(this,e)}async getLoyaltyProgramInfos(e){return await ea(this,e)}async getVeScaLoyaltyProgramInfos(e){return await ta(this,e)}async getSCoinTotalSupply(e){return await da(this,e)}async getSCoinAmounts(e,a=this.walletAddress){return await ua(this,e,a)}async getSCoinAmount(e,a=this.walletAddress){let o=this.utils.parseSCoinName(e);return o?await ot(this,o,a):0}async getSCoinSwapRate(e,a){return await pa(this,e,a)}async getFlashLoanFees(e=[...this.constants.whitelist.lending]){return await Zt(this,e)}async getPoolSupplyLimit(e){return await Ce(this.utils,e)}async getPoolBorrowLimit(e){return await ke(this.utils,e)}async getIsolatedAssets(e=!1){return await qt(this,e)}async isIsolatedAsset(e){return oe(this.utils,e)}async getCoinPriceByIndexer(e){return this.indexer.getCoinPrice(e)}async getCoinPricesByIndexer(){return this.indexer.getCoinPrices()}async getAllCoinPrices(e){return ca(this,e?.marketPools,e?.coinPrices,e?.indexer)}async getPoolAddresses(e=this.address.getId()){if(!e)throw new Error("apiAddressId is required");return ga(e)}async getUserPortfolio(e){return na(this,e?.walletAddress??this.walletAddress,e?.indexer??!1)}async getPriceUpdatePolicies(){return await wa(this)}async getAssetOracles(){let[e,a]=await Promise.all([nt(this.utils,"primary"),nt(this.utils,"secondary")]);return [...this.constants.whitelist.lending].reduce((o,s)=>(o[s]={primary:e?.[s]??[],secondary:a?.[s]??[]},o),{})}async getSwitchboardOnDemandAggregatorObjectIds(e){return await ha(this,e)}},Ke=wt;var St=class{query;usePythPullModel;useOnChainXOracleList;sponsoredFeeds;constructor(e){this.query=e.query??new Ke(e),this.usePythPullModel=e.usePythPullModel??!0,this.useOnChainXOracleList=e.useOnChainXOracleList??!0,this.sponsoredFeeds=e.sponsoredFeeds??[];}get utils(){return this.query.utils}get constants(){return this.utils.constants}get walletAddress(){return this.utils.walletAddress}get scallopSuiKit(){return this.utils.scallopSuiKit}get suiKit(){return this.scallopSuiKit.suiKit}get address(){return this.utils.address}async init(e=!1){await this.query.init(e);}createTxBlock(e){return Ka(this,e)}async selectCoin(e,a,o,s=this.walletAddress,r=!1){if(a==="sui"&&!r){let[n]=e.splitSUIFromGas([o]);return {takeCoin:n}}else {let n=this.utils.parseCoinType(a),i=await this.utils.selectCoins(o,n,s),[c,d]=e.takeAmountFromCoins(i,o);return {takeCoin:c,leftCoin:d}}}async selectMarketCoin(e,a,o,s=this.walletAddress){let r=this.utils.parseMarketCoinType(a),n=await this.utils.selectCoins(o,r,s),i=n.reduce((l,u)=>(l+=Number(u.balance),l),0),[c,d]=e.takeAmountFromCoins(n,Math.min(o,i));return {takeCoin:c,leftCoin:d,totalAmount:i}}async selectSCoin(e,a,o,s=this.walletAddress){let r=this.utils.parseSCoinType(a),n=await this.utils.selectCoins(o,r,s),i=n.reduce((l,u)=>(l+=Number(u.balance),l),0),[c,d]=e.takeAmountFromCoins(n,Math.min(i,o));return {takeCoin:c,leftCoin:d,totalAmount:i}}async selectSCoinOrMarketCoin(e,a,o,s=this.walletAddress){let r=o,n={sCoins:[],marketCoins:[],leftCoins:[]};try{let{leftCoin:d,takeCoin:l,totalAmount:u}=await this.selectSCoin(e,a,r,s);if(n.leftCoins.push(d),n.sCoins.push(l),r-=u,r>0){let{leftCoin:p,takeCoin:m}=await this.selectMarketCoin(e,a,o,s);e.transferObjects([p],s),n.marketCoins.push(m);}}catch{let{takeCoin:l,leftCoin:u}=await this.selectMarketCoin(e,a,o,s);n.leftCoins.push(u),n.marketCoins.push(l);}e.transferObjects(n.leftCoins,s);let i=n.marketCoins.length>0?n.marketCoins.length>1?e.mergeCoins(n.marketCoins[0],n.marketCoins.slice(1)):n.marketCoins[0]:void 0;return {sCoin:n.sCoins.length>0?n.sCoins.length>1?e.mergeCoins(n.sCoins[0],n.sCoins.slice(1)):n.sCoins[0]:void 0,marketCoin:i}}async signAndSendTxBlock(e){return await this.scallopSuiKit.suiKit.signAndSendTxn(e)}moveCall(e,a,o,s){return e.moveCall(a,o,s)}},Le=St;var Ct=class{builder;networkType;constructor(e){this.builder=e.builder??new Le(e),this.networkType=e.networkType??"mainnet";}get query(){return this.builder.query}get utils(){return this.query.utils}get constants(){return this.utils.constants}get walletAddress(){return this.utils.walletAddress}get scallopSuiKit(){return this.utils.scallopSuiKit}get address(){return this.builder.address}async init(e=!1){await this.builder.init(e);}async queryMarket(){return await this.query.queryMarket()}async getObligations(e){let a=e??this.walletAddress;return await this.query.getObligations(a)}async queryObligation(e){return await this.query.queryObligation(e)}async getAllStakeAccounts(e){let a=e??this.walletAddress;return await this.query.getAllStakeAccounts(a)}async getStakeAccounts(e,a){let o=a??this.walletAddress;return await this.query.getStakeAccounts(e,o)}async getStakePool(e){return await this.query.getStakePool(e)}async getStakeRewardPool(e){return await this.query.getStakeRewardPool(e)}async openObligation(e=!0){let a=this.builder.createTxBlock();return a.openObligationEntry(),e?await this.scallopSuiKit.signAndSendTxn(a):a.txBlock}async depositCollateral(e,a,o=!0,s,r,n){let i=this.builder.createTxBlock(),c=r??this.walletAddress;i.setSender(c);let d=s??(await this.query.getObligations(c))[0]?.id;if(d)await i.addCollateralQuick(a,e,d,n);else {let[l,u,p]=i.openObligation();await i.addCollateralQuick(a,e,l,n),i.returnObligation(l,p),i.transferObjects([u],c);}return o?await this.scallopSuiKit.signAndSendTxn(i):i.txBlock}async withdrawCollateral(e,a,o=!0,s,r,n,i){let c=this.builder.createTxBlock(),d=n??this.walletAddress;c.setSender(d);let l=await c.takeCollateralQuick(a,e,s,r,{isSponsoredTx:i});return c.transferObjects([l],d),o?await this.scallopSuiKit.signAndSendTxn(c):c.txBlock}async deposit(e,a,o=!0,s){let r=this.builder.createTxBlock(),n=s??this.walletAddress;r.setSender(n);let i=await r.depositQuick(a,e);return r.transferObjects([i],n),o?await this.scallopSuiKit.signAndSendTxn(r):r.txBlock}async depositAndStake(e,a,o=!0,s,r){let n=this.builder.createTxBlock(),i=r??this.walletAddress;n.setSender(i);let c=this.utils.parseMarketCoinName(e),d=await this.query.getStakeAccounts(c),l=s??d[0]?.id,u=await n.depositQuick(a,e,!1);if(l)await n.stakeQuick(u,c,l);else {let p=n.createStakeAccount(c);await n.stakeQuick(u,c,p),n.transferObjects([p],i);}return o?await this.scallopSuiKit.signAndSendTxn(n):n.txBlock}async withdraw(e,a,o=!0,s){let r=this.builder.createTxBlock(),n=s??this.walletAddress;r.setSender(n);let i=await r.withdrawQuick(a,e);return r.transferObjects([i],n),o?await this.scallopSuiKit.signAndSendTxn(r):r.txBlock}async borrow(e,a,o=!0,s,r,n,i){let c=this.builder.createTxBlock(),d=n??this.walletAddress;c.setSender(d);let l=this.constants.whitelist.lending.has(e);o&&l&&await c.unstakeObligationQuick(s,r);let u=await c.borrowQuick(a,e,s,r,{isSponsoredTx:i});return c.transferObjects([u],d),o&&l&&await c.stakeObligationWithVeScaQuick(s,r),o?await this.scallopSuiKit.signAndSendTxn(c):c.txBlock}async repay(e,a,o=!0,s,r,n,i){let c=this.builder.createTxBlock(),d=n??this.walletAddress;c.setSender(d);let l=this.constants.whitelist.lending.has(e);return o&&l&&await c.unstakeObligationQuick(s,r),await c.repayQuick(a,e,s,i),o&&l&&await c.stakeObligationWithVeScaQuick(s,r),o?await this.scallopSuiKit.signAndSendTxn(c):c.txBlock}async flashLoan(e,a,o,s=!0,r){let n=this.builder.createTxBlock(),i=r??this.walletAddress;n.setSender(i);let[c,d]=n.borrowFlashLoan(a,e);return n.repayFlashLoan(await o(n,c),d,e),s?await this.scallopSuiKit.signAndSendTxn(n):n.txBlock}async createStakeAccount(e,a=!0,o){let s=this.builder.createTxBlock(),r=o??this.walletAddress;s.setSender(r);let n=s.createStakeAccount(e);return s.transferObjects([n],r),a?await this.scallopSuiKit.signAndSendTxn(s):s.txBlock}async stake(e,a,o=!0,s,r){let n=this.builder.createTxBlock(),i=r??this.walletAddress;n.setSender(i);let c=await this.query.getStakeAccounts(e),d=s??c[0]?.id;if(d)await n.stakeQuick(a,e,d);else {let l=n.createStakeAccount(e);await n.stakeQuick(a,e,l),n.transferObjects([l],i);}return o?await this.scallopSuiKit.signAndSendTxn(n):n.txBlock}async unstake(e,a,o=!0,s,r){let n=this.builder.createTxBlock(),i=r??this.walletAddress;n.setSender(i);let c=await n.unstakeQuick(a,e,s);if(c){let d=this.utils.parseSCoinType(e);if(!d)throw new Error(`Invalid sCoin type: ${e}`);await this.utils.mergeSimilarCoins(n,c,d,R(n));}return n.transferObjects([c],i),o?await this.scallopSuiKit.signAndSendTxn(n):n.txBlock}async unstakeAndWithdraw(e,a,o=!0,s,r){let n=this.builder.createTxBlock(),i=r??this.walletAddress;n.setSender(i);let c=await n.unstakeQuick(a,e,s,!1),d=this.utils.parseCoinName(e);if(c){let l=n.withdraw(c,d);await this.utils.mergeSimilarCoins(n,l,this.utils.parseCoinType(d),R(n)),n.transferObjects([l],i);}else throw new Error(`No stake found for ${e}`);return o?await this.scallopSuiKit.signAndSendTxn(n):n.txBlock}async claim(e,a=!0,o,s){let r=this.builder.createTxBlock(),n=s??this.walletAddress;r.setSender(n);let i=await r.claimQuick(e,o);return r.transferObjects(i,n),a?await this.scallopSuiKit.signAndSendTxn(r):r.txBlock}async stakeObligation(e,a,o=!0,s){let r=this.builder.createTxBlock(),n=s??this.walletAddress;return r.setSender(n),await r.stakeObligationWithVeScaQuick(e,a),o?await this.scallopSuiKit.signAndSendTxn(r):r.txBlock}async unstakeObligation(e,a,o=!0,s){let r=this.builder.createTxBlock(),n=s??this.walletAddress;return r.setSender(n),await r.unstakeObligationQuick(e,a),o?await this.scallopSuiKit.signAndSendTxn(r):r.txBlock}async claimBorrowIncentive(e,a,o=!0,s){let r=this.builder.createTxBlock(),n=s??this.walletAddress;r.setSender(n);let i={},c=await this.query.getObligationAccount(e);if(!c)throw new Error("Obligation not found");let d=Object.values(c.borrowIncentives).filter(l=>!!l).flatMap(({rewards:l})=>l.filter(({availableClaimAmount:u})=>u>0)).flatMap(({coinName:l})=>l);for(let l of d){let u=await r.claimBorrowIncentiveQuick(l,e,a);i[l]?i[l].push(u):i[l]=[u];}return r.transferObjects(Object.values(i).map(l=>{let u=l[0];return l.length>1&&r.mergeCoins(u,l.slice(1)),u}),n),o?await this.scallopSuiKit.signAndSendTxn(r):r.txBlock}async migrateAllMarketCoin(e=!0,a=!0,o){let s=o??this.walletAddress,r=this.builder.createTxBlock();r.setSender(s);let n=[];for(let i of this.constants.whitelist.scoin){let c=[];try{let{takeCoin:d}=await this.builder.selectMarketCoin(r,i,Number.MAX_SAFE_INTEGER,s);if(d){let l=r.mintSCoin(i,d);c.push(l);}}catch(d){if(!d.toString().includes("No valid coins found for the transaction"))throw d}if(e&&this.constants.whitelist.spool.has(i))try{let d=await r.unstakeQuick(Number.MAX_SAFE_INTEGER,i);d&&c.push(d);}catch{}if(c.length>0){let d=c[0];c.length>1&&r.mergeCoins(d,c.slice(1));let l=this.utils.parseSCoinType(i);await this.utils.mergeSimilarCoins(r,d,l,s),n.push(d);}}return n.length>0&&r.transferObjects(n,s),a?await this.scallopSuiKit.signAndSendTxn(r):r.txBlock}async claimAllUnlockedSca(e=!0,a){let o=a??this.walletAddress,s=(await this.query.getVeScas({walletAddress:o})??[]).map(({keyObject:i})=>i);if(s.length===0)throw new Error("No veSCA found in the wallet");let r=[],n=this.builder.createTxBlock();if(n.setSender(o),await Promise.all(s.map(async i=>{try{let c=await n.redeemScaQuick({veScaKey:i,transferSca:!1});if(!c)return;r.push(c);}catch{}})),r.length===0)throw new Error("No unlocked SCA found in the veSCA accounts");return r.length>1&&n.mergeCoins(r[0],r.slice(1)),await this.utils.mergeSimilarCoins(n,r[0],"sca",o),e?await this.scallopSuiKit.signAndSendTxn(n):{tx:n.txBlock,scaCoin:r[0]}}async mintTestCoin(e,a,o=!0,s){if(!(this.networkType==="testnet"))throw new Error("Only be used on the test network.");let n=this.builder.createTxBlock(),i=s??this.walletAddress,c=this.address.get("core.packages.testCoin.id"),d=this.address.get(`core.coins.${e}.treasury`),l=`${c}::${e}::mint`,u=n.moveCall(l,[d,a]);return n.transferObjects([u],i),o?await this.scallopSuiKit.signAndSendTxn(n):n.txBlock}},Ve=Ct;var kt=class{client;constructor(e){this.client=e.client??new Ve(e);}async init(e=!1){await this.client.init(e);}async createScallopClient(){return await this.init(),this.client}async createScallopBuilder(){return await this.init(),this.client.builder}async createScallopQuery(){return await this.init(),this.client.query}async createScallopUtils(){return await this.init(),this.client.utils}async createScallopIndexer(){return await this.init(),this.client.query.indexer}async getScallopConstants(){return await this.init(),this.client.constants}},Ua=kt;

export { At as API_BASE_URL, Tt as DEFAULT_CACHE_OPTIONS, ks as IS_VE_SCA_TEST, $ as MAX_LOCK_DURATION, re as MAX_LOCK_ROUNDS, qe as MIN_INITIAL_LOCK_AMOUNT, Qe as MIN_TOP_UP_AMOUNT, Ee as OLD_BORROW_INCENTIVE_PROTOCOL_ID, vs as POOL_ADDRESSES, Ue as RPC_PROVIDERS, ge as SCA_COIN_TYPE, Pt as SDK_API_BASE_URL, Ua as Scallop, je as ScallopAddress, Le as ScallopBuilder, Ve as ScallopClient, Ne as ScallopConstants, Fe as ScallopIndexer, Ke as ScallopQuery, Me as ScallopSuiKit, De as ScallopUtils, Rs as TEST_ADDRESSES, Z as UNLOCK_ROUND_DURATION, Ts as USE_TEST_ADDRESS, Is as WHITELIST, N as queryKeys, xt as xOracleList };
